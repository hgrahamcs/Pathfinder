{"version":3,"sources":["components/navbar/TopBar.tsx","components/navbar/Buttons.tsx","components/navbar/DropDowns.tsx","components/panel/Checkbox.tsx","components/panel/RadioButtonGroup.tsx","components/panel/SteppedButtonRange.tsx","components/panel/SettingPanels.tsx","components/panel/DraggablePanel.tsx","pathfinding/structures/Hash.ts","components/grid/GridVisualization.tsx","pathfinding/core/Components.ts","pathfinding/core/Grid.ts","components/grid/TileFg.tsx","components/grid/SolidFg.tsx","assets/weight.svg","components/grid/WeightFg.tsx","components/grid/GridForeground.tsx","components/grid/Stats.tsx","components/grid/GridBackground.tsx","pathfinding/core/PlusNavigator.ts","pathfinding/core/Navigator.ts","pathfinding/algorithms/Heuristics.ts","pathfinding/algorithms/Pathfinder.ts","pathfinding/algorithms/Node.ts","pathfinding/structures/Heap.ts","pathfinding/algorithms/AStarPathfinder.ts","pathfinding/algorithms/BFSPathfinder.ts","pathfinding/structures/Stack.ts","pathfinding/algorithms/DFSPathfinder.ts","pathfinding/algorithms/BiAStarPathfinder.ts","pathfinding/algorithms/BiBFSPathfinder.ts","pathfinding/algorithms/BestFirstPathfinder.ts","pathfinding/algorithms/DijkstraPathfinder.ts","pathfinding/algorithms/BiDijkstraPathfinder.ts","pathfinding/builders/PathfinderBuilder.ts","pathfinding/algorithms/TerrainGenerator.ts","pathfinding/algorithms/TerrainRandomGenerator.ts","pathfinding/algorithms/TerrainMazeGenerator.ts","pathfinding/builders/TerrainGeneratorBuilder.ts","utils/VirtualTimer.ts","components/grid/PathfindingVisualizer.tsx","assets/react.png","components/tutorial/Tutorial.tsx","components/tutorial/TutorialPages.tsx","assets/weight-tile.png","assets/start-goal.png","components/PathfindingApp.tsx","utils/AppSettings.ts","App.tsx","index.tsx"],"names":["TopBar","bar","React","createRef","ref","this","style","width","window","screen","availWidth","className","props","children","Component","SYMBOL_COLOR","DIMENSION","VisualizeButton","height","rx","fill","points","x","active","onMouseDown","e","preventDefault","onClick","paused","onResume","onPause","xmlns","getResumeSymbol","getPauseSymbol","onStartStop","getStopSymbol","SettingsButton","Clickable","tabIndex","onKeyPress","click","DropDown","windowOnClick","hide","state","up","display","fade","addEventListener","removeEventListener","setState","stopPropagation","isHidden","show","undefined","dropDownClass","contentClassName","dropDownContentClass","toggle","nativeEvent","getHighlightClass","text","arrowClass","contentStyle","AlgorithmDropDown","dropDown","current","key","algText","onChange","ClearDropDown","onClickPath","onClickTiles","onClickReset","MazeDropDown","onClickMaze","onClickMazeHorizontal","onClickMazeVertical","onClickRandomTerrain","TilesDropDown","cost","onClickTileType","Checkbox","checked","defaultChecked","prevState","type","disabled","boxStyle","defaultProps","RadioButtonGroup","i","length","push","index","Children","toArray","radioButtons","SteppedButtonRange","interval","callback","wasClicked","intervals","value","default","step","min","minus","setInterval","max","plus","clearInterval","onMinus","onMouseUp","cancel","onMouseLeave","onKeyDown","onPlus","VisualSettings","defaultShowArrows","onChangeShowArrows","disabledTree","SpeedSettings","speedText","String","initialSpeed","sliderStyle","onChangeSpeed","AlgorithmSettings","defaultAlg","onChangeBidirectional","HeuristicSettings","heuristic","getIndex","defaultHeuristic","onClickManhattan","onClickEuclidean","onClickChebyshev","onClickOctile","DraggablePanel","draggable","draggableContainer","draggableContent","dragging","prevX","prevY","stopDrag","mouseDown","clientY","clientX","touchStart","touch","touches","changedTouches","mouseUp","mouseMove","drag","touchMove","top","left","document","container","offsetTop","offsetLeft","content","innerHeight","innerWidth","offsetHeight","offsetWidth","visibleStyle","minHeight","getPosition","renderDraggable","draggableStyle","onTouchStart","title","onClickXButton","HashSet","map","HashTable","data","values","table","Object","assign","stringify","point","y","ARROW_COLOR","TILE_CLASS","clone","array","arr","slice","GridVisualization","tileWidth","tileClass","visualization","createEmptyViz","arrows","prevProps","row","generation","doVizGeneration","generations","doArrowGeneration","renderViz","id","markerWidth","markerHeight","refX","refY","orient","settings","showArrows","renderArrows","offset","arrowList","arrow","first","from","second","to","firstX","firstY","secondX","secondY","offsetX","offsetY","x1","y1","x2","y2","stroke","strokeWidth","markerEnd","tiles","viz","renderTile","color","backgroundColor","fontSize","tile","newArrow","add","createTileData","isSolid","pathCost","RectGrid","nodes","createEmptyGrid","solid","mutate","console","str","log","JSON","grid","mutateTile","get","inBounds","TileFg","size","position","borderColor","SolidFg","doTileAnimation","tileSize","WeightFg","backgroundImage","Weight","ARROW_PATH_COLOR","pointsEqual","point1","point2","isControlKey","button","GridForeground","svg","tilePointer","drawing","erasing","draggingInitial","draggingGoal","disable","initialKey","goalKey","end","path","initial","goal","cloneNewSize","getBoundingClientRect","bounds","getBoundingRect","onPress","onDrag","xCoordinate","yCoordinate","calculatePoint","isEmpty","drawTile","eraseTile","moveInitial","moveGoal","mutateDefault","getHeight","getWidth","canMoveEndPoint","onTilesDragged","Math","floor","renderEndTile","renderPath","onContextMenu","onMouseMove","onEndingEvent","onTouchMoveCapture","onTouchEnd","onTouchCancel","renderTilesGrid","lines","renderPathArrow","renderWeightText","paddingTop","textAlign","cursor","Stats","textLog","scrollTop","scrollHeight","time","toFixed","algorithm","readOnly","unselectable","onDrop","GridBackground","renderTiles","PlusNavigator","a","b","manhattan","abs","euclidean","dx","dy","sqrt","octile","SQRT2","chebyshev","nullHeuristic","reconstructPath","bottomLeaf","reconstructPathReversed","reverse","parent","Pathfinder","navigator","recentSearch","node","Node","child","AStarNode","g","fScore","BestFirstNode","h","DijkstraNode","Heap","compare","elements","siftUp","val","peek","move","pop","siftDown","pos","swap","right","AStarPathfinder","func","heuristicFunc","p","getNavigator","getGrid","clearRecentSearch","openFrontier","f","closedSet","openSet","root","currentNode","currentPoint","currentKey","remove","has","addRecent","equals","neighbors","neighbor","neighborPoint","neighborKey","stepCost","neighborNode","addChild","BFSPathfinder","frontier","visited","shift","next","Stack","DFSPathfinder","BiAStarPathfinder","startOpenFrontier","startOpenSet","endOpenFrontier","endOpenSet","initialRoot","goalRoot","startCurrentNode","startCurrentPointKey","concat","doAStarExpansion","endCurrentNode","endCurrentPointKey","structures","endPoint","BiBFSPathfinder","startVisited","endVisited","startFrontier","endFrontier","doBFSExpansion","BestFirstPathfinder","DijkstraPathfinder","BiDijkstraPathfinder","doDijkstraExpansion","CREATE_NAVIGATOR","CREATE_HEURISTIC","CREATE_PATHFINDER","PathfinderBuilder","toLowerCase","Error","createHeuristic","createNavigator","createPathfinder","TerrainGenerator","ignore","shouldIgnore","TerrainRandomGenerator","tileData","topLeft","bottomRight","random","draw","getTerrain","divideWidthNoSkew","divideWidthHSkew","divideWidthVSkew","canDrawHole","getMidPoint","range","mid","getRand","TerrainMazeGenerator","slant","divideWidth","getSolid","divide","chamber","widthOf","heightOf","randX","toDraw","edgeBlocked","randY","drawArr","leftChamber","rightChamber","topChamber","bottomChamber","TerrainGeneratorBuilder","VirtualTimer","countDown","timeout","timeStarted","timeRemaining","finished","Date","now","setTimeout","clearTimeout","calcLength","len","calcCost","PathfindingVisualizer","background","foreground","visualized","visualizing","visualTimeouts","wasPaused","mazeTile","onWindowResize","w","documentElement","clientWidth","clientHeight","tilesX","tilesY","onWindowBlur","isPaused","pausePathfinding","onWindowFocus","resumePathfinding","clearPath","erasePath","nextProps","nextState","changeTile","pause","resume","pathfinder","getPathfinder","findPath","getRecentGenerations","visualizeGenerations","addArrowGenerations","drawPath","enableAnimations","clearVisualization","toggleDisable","clear","onChangeVisualizing","promises","baseIncrement","delayInc","delay","generationSet","forEach","promise","Promise","resolve","visualizeGenerationAndArrows","all","then","disableAnimations","algorithmKey","bidirectional","hasBidirectional","makeBidirectional","setAlgorithm","setHeuristic","heuristicKey","setNavigator","navigatorKey","build","t0","performance","t2","getRecentNodes","getAlgorithmName","unshift","doPathfinding","mazeType","useMazeTile","clearTiles","calcEndPointInView","newState","prevGrid","generator","setDimensions","setGeneratorType","setIgnorePoints","setTileData","generateTerrain","drawGrid","calcEndPoint","xEnd","yEnd","xFloor","yFloor","yDecimal","ceil","round","resetPoints","KEY_SHOW","Tutorial","page","localStorage","setItem","getItem","lastPage","showPanel","prev","IntroductionPage","alt","src","Icon","ExplanationPage","DrawingPage","EndpointsPage","AlgorithmsPage","FinishPage","href","PathfindingApp","visualizer","algDropDown","clrDropDown","mazeDropDown","tilesDropDown","windowOnResize","useIcon","heuristicDisabled","bidirectionalDisabled","arrowsDisabled","scoreDisabled","panelShow","mobile","test","userAgent","doDelayedPathfinding","clearVisualizationChecked","clearTilesChecked","createTerrain","usesHeuristic","usesWeights","icon","hideSettings","disabledScore","changeShowArrows","changeSpeed","changeBidirectional","changeManhattan","changeEuclidean","changeChebyshev","changeOctile","showTutorial","location","reload","onClickAlgDrop","alg","changeAlgo","onClickMazeDrop","createMaze","createMazeHSkew","createMazeVSkew","createRandomTerrain","onClickClrDrop","resetBoard","onClickTilesDrop","toggleSettings","changeButtonActiveState","App","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.ac5605e6.chunk.js","sourcesContent":["import React, {RefObject} from 'react';\n\nclass TopBar extends React.Component\n{\n    private bar: RefObject<HTMLDivElement> = React.createRef();\n\n    render() {\n        return (\n            <div\n                ref={this.bar}\n                style={{\n                    width: window.screen.availWidth\n                }}\n                className='top-navbar'\n            >\n                {this.props.children}\n            </div>\n        );\n    }\n}\n\nexport default TopBar;","import React from 'react';\n\ninterface VProps {\n    active: boolean,\n    paused: boolean,\n    onStartStop: ()  => void,\n    onPause: ()  => void,\n    onResume: ()  => void,\n}\n\ninterface ButtonProps {\n    onClick: ()  => void\n}\n\nconst SYMBOL_COLOR = 'rgb(230,230,230)';\nconst OFFSET = 14;\nconst DIMENSION = 47 - 2 * OFFSET;\n\nexport class VisualizeButton extends React.Component<VProps>\n{\n    getStopSymbol() {\n        return (\n            <rect\n                width={DIMENSION}\n                height={DIMENSION}\n                rx={4}\n                fill={SYMBOL_COLOR}\n            />\n        );\n    }\n\n    getResumeSymbol() {\n        const midY = DIMENSION / 2;\n        return (\n            <polygon\n                points={`${0},${0} ${0},${DIMENSION} ${DIMENSION},${midY}`}\n                className={'track round'}\n                fill={SYMBOL_COLOR}\n            />\n        );\n    }\n\n    getPauseSymbol() {\n        return (\n            <svg>\n                <rect\n                    width={DIMENSION/2.5}\n                    height={DIMENSION}\n                    rx={3}\n                    fill={SYMBOL_COLOR}\n                />\n                <rect\n                    width={DIMENSION/2.5}\n                    height={DIMENSION}\n                    x={0.2*DIMENSION + DIMENSION/2.5}\n                    rx={3}\n                    fill={SYMBOL_COLOR}\n                />\n            </svg>\n        );\n    }\n\n    /**\n     * If button is \"Active\" two red half buttons should be rendered\n     *  One has the stop symbol, the other has either pause or resume symbol\n     *      (depends on if button state is paused)\n     *  stop button invokes onStartStop event, pause resume each invoke respective events\n     * Otherwise, a single green button should be rendered\n     *  invokes the onStartStop event\n     */\n    render() {\n        if(this.props.active) {\n            return (\n                <div className={'half-button-wrapper'}>\n                    <button\n                        onMouseDown={e => e.preventDefault()}\n                        className={'center half-button-left red-button half-viz-button'}\n                        onClick={this.props.paused ? this.props.onResume : this.props.onPause}\n                    >\n                        <svg\n                            xmlns='http://www.w3.org/2000/svg'\n                            className='svg-icon'\n                            width={DIMENSION}\n                            height={DIMENSION}\n                        >\n                            {this.props.paused ? this.getResumeSymbol() : this.getPauseSymbol()}\n                        </svg>\n                    </button>\n                    <button\n                        onMouseDown={e => e.preventDefault()}\n                        className={'center half-button-right red-button half-viz-button'}\n                        onClick={this.props.onStartStop}\n                    >\n                        <svg\n                            xmlns='http://www.w3.org/2000/svg'\n                            className='svg-icon'\n                            width={DIMENSION}\n                            height={DIMENSION}\n                        >\n                            {this.getStopSymbol()}\n                        </svg>\n                    </button>\n                </div>\n            );\n        } else {\n            return (\n                <button\n                    onMouseDown={e => e.preventDefault()}\n                    className={'button green-button viz-button'}\n                    onClick={this.props.onStartStop}\n                >\n                    Visualize!\n                </button>\n            );\n        }\n    }\n}\n\nexport class SettingsButton extends React.Component<ButtonProps>\n{\n    render() {\n        return (\n            <button\n                onMouseDown={e => e.preventDefault()}\n                className='special-button'\n                onClick={this.props.onClick}\n            >\n                Settings\n            </button>\n        );\n    }\n}","import React, {RefObject} from 'react';\n\nexport interface DropDownProps {\n    onClick: () => void,\n    text: string,\n    dropDownClass?: string\n    dropDownContentClass?: string\n}\n\nexport interface DropDownState {\n    up: boolean,\n    display: string,\n    fade: string\n}\n\ninterface DropDownTextState {\n    text: string\n}\n\ninterface AlgProps {\n    onClick: () => void,\n    onChange: (alg: string) => void\n}\n\ninterface ClrProps {\n    onClick: () => void,\n    onClickPath: () => void,\n    onClickTiles: () => void,\n    onClickReset: () => void;\n}\n\ninterface MazeProps {\n    onClick: () => void,\n    onClickMaze: () => void,\n    onClickMazeHorizontal: () => void,\n    onClickMazeVertical: () => void,\n    onClickRandomTerrain: () => void\n}\n\ninterface TileProps {\n    onClick: () => void,\n    onClickTileType: (cost: number) => void\n}\n\ninterface ClickableProps {\n    click: () => void;\n}\n\nclass Clickable extends React.Component<ClickableProps>\n{\n    render() {\n        return (\n            <div\n                tabIndex={0}\n                onKeyPress={this.props.click}\n                onClick={this.props.click}\n            >\n                {this.props.children}\n            </div>\n        )\n    }\n}\n\nclass DropDown extends React.Component<DropDownProps, DropDownState>\n{\n    protected constructor(props: DropDownProps) {\n        super(props);\n        this.state = {\n            up: true,\n            display: 'none',\n            fade: 'fade-in'\n        };\n    }\n\n    windowOnClick = () => {\n        this.hide();\n    }\n\n    /**\n     * Binds window listeners.\n     * Hides the drop down if clicked anywhere else\n     */\n    componentDidMount() {\n        window.addEventListener('click', this.windowOnClick);\n    }\n\n    componentWillUnmount() {\n        window.removeEventListener('click', this.windowOnClick);\n    }\n\n    show() {\n        this.setState({\n            up: false,\n            display: 'block',\n        });\n    }\n\n    hide() {\n        this.setState({\n            display: 'none',\n            up: true,\n        });\n    }\n\n    toggle(e: Event) {\n        e.stopPropagation();\n        this.props.onClick();\n        if(this.isHidden()) {\n            this.show();\n        } else {\n            this.hide();\n        }\n    }\n\n    isHidden() {\n        return this.state.display === 'none';\n    }\n\n    /**\n     * Gets the style that will determine if the dropdown content should be displayed or not\n     */\n    contentStyle() {\n        return {\n            display: this.state.display\n        }\n    }\n\n    /**\n     * Gets the css class determining if the arrow should be facing up or down\n     *  If the dropdown is extended the arrow faces down, otherwise it faces up\n     */\n    arrowClass() {\n        return this.state.up ? 'arrowUp' : 'arrowDown';\n    }\n\n    /**\n     * Gets the css class that highlights the dropdown if the dropdown is extended\n     */\n    getHighlightClass() {\n        return !this.state.up ? 'drop-down-button-down drop-down-button-up' : 'drop-down-button-up'\n    }\n\n    /**\n     * Renders the dropdown button, and its arrow\n     * The children will be rendered in the dropdown content\n     */\n    render() {\n        const className = this.props.dropDownClass === undefined ? '' : this.props.dropDownClass;\n        const contentClassName = this.props.dropDownContentClass === undefined ? '' : this.props.dropDownContentClass;\n        return (\n            <div\n                tabIndex={0}\n                className={'drop-down ' + className}\n                onMouseDown={e => e.preventDefault()}\n                onKeyPress={(e) => this.toggle(e.nativeEvent)}\n                onClick={(e) => this.toggle(e.nativeEvent)}\n            >\n                <div\n                    className={'drop-down-button ' + this.getHighlightClass()}\n                >\n                    <div className='drop-down-button-wrapper'>\n                        <span className='drop-down-text'>{this.props.text}</span>\n                        <span\n                            className={this.arrowClass()}\n                        />\n                    </div>\n                </div>\n                <div\n                    style={this.contentStyle()}\n                    className={this.state.fade + ' drop-down-content ' + contentClassName}\n                >\n                    {this.props.children}\n                </div>\n            </div>\n        );\n    }\n}\n\nexport class AlgorithmDropDown extends React.Component<AlgProps, DropDownTextState>\n{\n    private dropDown: RefObject<DropDown> = React.createRef();\n\n    constructor(props: AlgProps) {\n        super(props);\n        this.state = {\n            text: 'A* Search'\n        };\n    }\n\n    hide() {\n        this.dropDown.current!.hide();\n    }\n\n    onChange(key: string, algText: string) {\n        this.props.onChange(key);\n        this.setState({\n            text: algText\n        });\n    }\n\n    render() {\n        return (\n            <DropDown\n                ref={this.dropDown}\n                onClick={this.props.onClick}\n                text={this.state.text}\n                dropDownContentClass='alg-drop-down-content'\n            >\n                <Clickable click={() => this.onChange('a*', 'A* Search')}>A* Search</Clickable>\n                <Clickable click={() => this.onChange('dijkstra', 'Dijkstra')}>Dijkstra's Algorithm</Clickable>\n                <Clickable click={() => this.onChange('best-first', 'Best First')}>Best First Search</Clickable>\n                <Clickable click={() => this.onChange('bfs', 'Breadth First')}>Breadth First Search</Clickable>\n                <Clickable click={() => this.onChange('dfs', 'Depth First')}>Depth First Search</Clickable>\n            </DropDown>\n        );\n    }\n}\n\nexport class ClearDropDown extends React.Component<ClrProps>\n{\n    private dropDown: RefObject<DropDown> = React.createRef();\n\n    hide() {\n        this.dropDown.current!.hide();\n    }\n\n    render() {\n        return (\n            <DropDown\n                ref={this.dropDown}\n                onClick={this.props.onClick}\n                text='Reset'\n                dropDownContentClass='clr-drop-down-content'\n            >\n                <Clickable click={this.props.onClickPath}>Clear Path</Clickable>\n                <Clickable click={this.props.onClickTiles}>Clear Tiles</Clickable>\n                <Clickable click={this.props.onClickReset}>Reset Grid</Clickable>\n            </DropDown>\n        );\n    }\n}\n\nexport class MazeDropDown extends React.Component<MazeProps>\n{\n    private dropDown: RefObject<DropDown> = React.createRef();\n\n    hide() {\n        this.dropDown.current!.hide();\n    }\n\n    render() {\n        return (\n            <DropDown\n                ref={this.dropDown}\n                onClick={this.props.onClick}\n                text='Terrain'\n                dropDownContentClass='maze-drop-down-content'\n                dropDownClass='maze-drop-down'\n            >\n                <Clickable click={this.props.onClickMaze}>Recursive Maze Division</Clickable>\n                <Clickable click={this.props.onClickMazeHorizontal}>Horizontal Skewed Maze</Clickable>\n                <Clickable click={this.props.onClickMazeVertical}>Vertical Skewed Maze</Clickable>\n                <Clickable click={this.props.onClickRandomTerrain}>Random Terrain</Clickable>\n            </DropDown>\n        );\n    }\n}\n\nexport class TilesDropDown extends React.Component<TileProps, DropDownTextState>\n{\n    private dropDown: RefObject<DropDown> = React.createRef();\n\n    constructor(props: TileProps) {\n        super(props);\n        this.state = {\n            text: 'Wall [∞]'\n        };\n    }\n\n    hide() {\n        this.dropDown.current!.hide();\n    }\n\n    onChange(cost: number, text: string) {\n        this.props.onClickTileType(cost);\n        this.setState({\n            text: text\n        }, () => this.props.onClickTileType(cost));\n    }\n\n    render() {\n        return (\n            <DropDown\n                ref={this.dropDown}\n                onClick={this.props.onClick}\n                text={this.state.text}\n                dropDownContentClass='tiles-drop-down-content'\n                dropDownClass='tiles-drop-down'\n            >\n                <Clickable click={() => this.onChange(-1, 'Wall [∞]')}>Wall [∞]</Clickable>\n                <Clickable click={() => this.onChange(2, 'Weight [2]')}>Weight [2]</Clickable>\n                <Clickable click={() => this.onChange(3, 'Weight [3]')}>Weight [3]</Clickable>\n                <Clickable click={() => this.onChange(5, 'Weight [5]')}>Weight [5]</Clickable>\n            </DropDown>\n        );\n    }\n}","import React from 'react';\n\ninterface IProps {\n    boxStyle: string,\n    defaultChecked: boolean,\n    disabled?: boolean,\n    onChange: (checked: boolean) => void\n}\n\ninterface IState {\n    checked: boolean\n}\n\nclass Checkbox extends React.Component<IProps,IState>\n{\n    public static defaultProps = {\n        disabled: false\n    };\n\n    constructor(props: IProps) {\n        super(props);\n        this.state = {\n            checked: this.props.defaultChecked\n        }\n    }\n\n    /**\n     * Trigger callback and toggle checkbox checked state\n     */\n    onChange() {\n        this.setState(prevState => ({\n            checked: !prevState.checked\n        }), () => this.props.onChange(this.state.checked));\n    }\n\n    render() {\n        return(\n            <div>\n                <input\n                    checked={this.state.checked}\n                    type='checkbox'\n                    disabled={this.props.disabled}\n                    className={this.props.boxStyle}\n                    onKeyPress={() => this.onChange()}\n                    onChange={() => this.onChange()}\n                />\n                {this.props.children}\n            </div>\n        );\n    };\n}\n\nexport default Checkbox;","import React from 'react';\n\ninterface IProps {\n    boxStyle: string,\n    defaultChecked: number,\n    disabled: boolean,\n    onChange: (() => void)[]\n}\n\ninterface IState {\n    checked: boolean[];\n}\n\nclass RadioButtonGroup extends React.Component<IProps, IState>\n{\n    static defaultProps = {\n        disabled: false\n    };\n\n    constructor(props: IProps) {\n        super(props);\n        const checked: boolean[] = [];\n        for(let i = 0; i < this.props.onChange.length; i++) {\n            checked.push(i === this.props.defaultChecked);\n        }\n        this.state = {\n            checked: checked\n        }\n    }\n\n    /**\n     * Set all radio buttons to checked aside from the index\n     * of the one that was changed\n     * Trigger callback\n     * @param index\n     */\n    onChange(index: number) {\n        const checked: boolean[] = [];\n        for(let i = 0; i < this.props.onChange.length; i++) {\n            checked.push(i === index);\n        }\n        this.setState({\n            checked: checked\n        }, () => this.props.onChange[index]());\n    }\n\n    /**\n     * Render a radio button for each child\n     */\n    render() {\n        const children = React.Children.toArray(this.props.children);\n        const radioButtons: JSX.Element[] = [];\n        for(let i = 0; i < this.props.onChange.length; i++) {\n            radioButtons.push(\n                <div key={i}>\n                    <input\n                        checked={this.state.checked[i]}\n                        type='radio'\n                        disabled={this.props.disabled}\n                        className={this.props.boxStyle}\n                        onChange={() => this.onChange(i)}\n                    />\n                    {children[i]}\n                </div>\n            );\n        }\n        return radioButtons;\n    };\n}\n\nexport default RadioButtonGroup;","import React from 'react';\n\ninterface IProps {\n    min: number,\n    max: number,\n    default: number,\n    step: number,\n    sliderStyle: string,\n    onChange: (val: number) => void\n}\n\ninterface IState {\n    value: number\n}\n\nconst HOLD_DELAY = 120;\n\nclass SteppedButtonRange extends React.Component<IProps, IState>\n{\n    private interval: NodeJS.Timeout | undefined;\n    private callback: (() => void) | undefined; //set to either plus or minus\n\n    private wasClicked: boolean = false;\n\n    //tracks how many times the button has changed its value while being held down\n    private intervals: number = 0;\n\n    constructor(props: IProps) {\n        super(props);\n        this.state = {\n            value: this.props.default\n        }\n    }\n\n    /**\n     * Reduces the buttons value and invokes the onChange event\n     */\n    minus() {\n        this.setState(prevState => ({\n            value: prevState.value - this.props.step >= this.props.min ?\n                prevState.value - this.props.step : prevState.value\n        }), () => this.props.onChange(this.state.value));\n    }\n\n    /**\n     * Called when the minus button is clicked\n     * Schedules the minus event to be called every few ms\n     *  to simulate the minus button being \"held down\"\n     * @param e\n     */\n    onMinus(e: Event) {\n        e.preventDefault();\n        this.wasClicked = true;\n        this.callback = () => {\n            this.intervals++;\n            this.minus();\n        };\n        this.interval = setInterval(this.callback, HOLD_DELAY);\n    }\n\n    /**\n     * Increases the buttons value and invokes the onChange event\n     */\n    plus() {\n        this.setState(prevState => ({\n            value: prevState.value + this.props.step <= this.props.max ?\n                prevState.value + this.props.step : prevState.value\n        }), () => this.props.onChange(this.state.value));\n    }\n\n    /**\n     * Called when the plus button is clicked\n     * Schedules the plus event to be called every few ms\n     *  to simulate the plus button being \"held down\"\n     * @param e\n     */\n    onPlus(e: Event) {\n        e.preventDefault();\n        this.wasClicked = true;\n        this.callback = () => {\n            this.intervals++;\n            this.plus();\n        };\n        this.interval = setInterval(this.callback, HOLD_DELAY);\n    }\n\n    /**\n     * Cancels all timeouts to prevent the delayed increase/decrease of the value,\n     * If the button was recently clicked and hasn't yet changed its value at least once,\n     *  the callback to be scheduled (either plus or minus) will be invoked\n     */\n    cancel() {\n        if(this.intervals === 0 && this.wasClicked) {\n            (this.callback as () => void)();\n        }\n        clearInterval(this.interval as NodeJS.Timeout);\n        this.intervals = 0;\n        this.wasClicked = false;\n    }\n\n    /**\n     * Renders the minus button on the left,\n     * The value of the button in the middle,\n     * and the plus button on the right\n     */\n    render() {\n        return (\n            <div className='button-range-wrapper'>\n                <button\n                    className='range-button minus'\n                    onMouseDown={e => this.onMinus(e.nativeEvent)}\n                    onMouseUp={() => this.cancel()}\n                    onMouseLeave={() => this.cancel()}\n                    onKeyDown={(e) => {\n                        if(e.key === 'Enter') {\n                            this.minus();\n                        }\n                    }}\n                >\n                    -\n                </button>\n                <div\n                    className='range-value'\n                >\n                    {this.state.value}\n                </div>\n                <button\n                    className='range-button plus'\n                    onMouseDown={e => this.onPlus(e.nativeEvent)}\n                    onMouseUp={() => this.cancel()}\n                    onMouseLeave={() => this.cancel()}\n                    onKeyDown={(e) => {\n                        if(e.key === 'Enter') {\n                            this.plus()\n                        }\n                    }}\n                >\n                    +\n                </button>\n            </div>\n        );\n    }\n}\n\nexport default SteppedButtonRange;","import React from 'react';\nimport Checkbox from './Checkbox';\nimport RadioButtonGroup from './RadioButtonGroup';\nimport SteppedButtonRange from './SteppedButtonRange';\n\ninterface VisualProps {\n    defaultShowArrows: boolean,\n    onChangeShowArrows: () => void,\n    disabledTree: boolean,\n    disabledScore: boolean\n}\n\ninterface SpeedProps {\n    onChange: (value: number) => void,\n    initialSpeed: number\n}\n\ninterface AlgorithmProps {\n    defaultAlg: boolean,\n    onChangeBidirectional: (checked: boolean) => void,\n    disabled: boolean\n}\n\ninterface HeuristicProps {\n    defaultHeuristic: string\n    onClickManhattan: () => void,\n    onClickEuclidean: () => void,\n    onClickChebyshev: () => void,\n    onClickOctile: () => void,\n    disabled: boolean\n}\n\nexport const SPEED_STEP = 5;\nexport const SPEED_MIN = 20;\nexport const SPEED_MAX = 200;\n\nexport class VisualSettings extends React.Component<VisualProps>\n{\n    render() {\n        return (\n            <div>\n                <div className='draggable-content-title'>Visualization</div>\n                <Checkbox\n                    defaultChecked={this.props.defaultShowArrows}\n                    boxStyle='box'\n                    onChange={this.props.onChangeShowArrows}\n                    disabled={this.props.disabledTree}\n                >\n                    Show Tree\n                </Checkbox>\n            </div>\n        );\n    }\n}\n\nexport class SpeedSettings extends React.Component<SpeedProps>\n{\n    constructor(props: SpeedProps) {\n        super(props);\n        this.state = {\n            speedText: String(this.props.initialSpeed)\n        }\n    }\n\n    /**\n     * Callback function to be called when slider is changed\n     * Call another callback and change text\n     * @param value\n     */\n    onChangeSpeed(value: number) {\n        this.props.onChange(value);\n    }\n\n    render() {\n        return (\n            <div className='slider-container'>\n                <div className='slider-text'>\n                    Period\n                </div>\n                <SteppedButtonRange\n                    min={SPEED_MIN}\n                    max={SPEED_MAX}\n                    step={SPEED_STEP}\n                    default={this.props.initialSpeed}\n                    sliderStyle='slider speed-slider'\n                    onChange={(value: number) => this.onChangeSpeed(value)}\n                />\n            </div>\n        );\n    }\n}\n\nexport class AlgorithmSettings extends React.Component<AlgorithmProps>\n{\n    constructor(props: AlgorithmProps) {\n        super(props);\n        this.state = {\n            disabled: false\n        }\n    }\n\n    render() {\n        return (\n            <div>\n                <div className='draggable-content-title'>Algorithm</div>\n                <Checkbox\n                    defaultChecked={this.props.defaultAlg}\n                    boxStyle='box'\n                    disabled={this.props.disabled}\n                    onChange={this.props.onChangeBidirectional}\n                >\n                    Bidirectional\n                </Checkbox>\n            </div>\n        );\n    }\n}\n\nexport class HeuristicSettings extends React.Component<HeuristicProps>\n{\n    constructor(props: HeuristicProps) {\n        super(props);\n        this.state = {\n            disabled: false\n        }\n    }\n\n    disable() {\n        this.setState({\n            disabled: true\n        })\n    }\n\n    enable() {\n        this.setState({\n            disabled: false\n        })\n    }\n\n    getIndex(heuristic: string) {\n        const mapping: {[key: string]: number} = {\n            'manhattan': 0,\n            'euclidean': 1,\n            'chebyshev': 2,\n            'octile': 3\n        }\n        return mapping[heuristic];\n    }\n\n    render() {\n        return (\n            <div>\n                <div className='draggable-content-title'>Heuristic</div>\n                <RadioButtonGroup\n                    boxStyle='box'\n                    defaultChecked={this.getIndex(this.props.defaultHeuristic)}\n                    disabled={this.props.disabled}\n                    onChange={[\n                        this.props.onClickManhattan, this.props.onClickEuclidean,\n                        this.props.onClickChebyshev, this.props.onClickOctile\n                    ]}\n                >\n                    <span key='Manhattan'>Manhattan</span>\n                    <span key='Euclidean'>Euclidean</span>\n                    <span key='Chebyshev'>Chebyshev</span>\n                    <span key='Octile<'>Octile</span>\n                </RadioButtonGroup>\n            </div>\n        )\n    }\n}","import React, {RefObject} from 'react';\n\ninterface IProps {\n    title: string,\n    show: boolean,\n    onClickXButton: () => void,\n    width: number,\n    height: number\n}\n\ninterface IState {\n    top: number,\n    left: number\n}\n\nclass DraggablePanel extends React.Component<IProps, IState>\n{\n    //refs are used to access native DOM\n    private draggable: RefObject<HTMLDivElement> = React.createRef();\n    private draggableContainer: RefObject<HTMLDivElement> = React.createRef();\n    private draggableContent: RefObject<HTMLDivElement> = React.createRef();\n\n    //stores previous mouse location and drag\n    private dragging = false;\n    private prevX = 0;\n    private prevY = 0;\n\n    constructor(props: IProps) {\n        super(props);\n        this.state = {\n            top: -1,\n            left: -1\n        };\n    }\n\n    componentDidMount() {\n        //mouse\n        document.addEventListener('mouseup', this.mouseUp);\n        document.addEventListener('mousemove', this.mouseMove);\n        window.addEventListener('mouseleave', this.mouseUp);\n        //touch\n        document.addEventListener('touchend', this.stopDrag);\n        document.addEventListener('touchmove', this.touchMove);\n    }\n\n    componentWillUnmount() {\n        //mouse\n        document.removeEventListener('mouseup', this.mouseUp);\n        document.removeEventListener('mousemove', this.mouseMove);\n        window.removeEventListener('mouseleave', this.mouseUp);\n        //touch\n        document.removeEventListener('touchend', this.stopDrag);\n        document.removeEventListener('touchmove', this.touchMove);\n    }\n\n    stopDrag = () => {\n        this.dragging = false;\n    }\n\n    /**\n     * Start drag and init prev mouse location when mouse is clicked on draggable\n     * @param e\n     */\n    mouseDown = (e: MouseEvent) => {\n        e.preventDefault();\n        this.prevY = e.clientY;\n        this.prevX = e.clientX;\n        this.dragging = true;\n    }\n\n    /**\n     * Start drag and init prev touch location when finger is clicked on draggable\n     * @param e\n     */\n    touchStart = (e: TouchEvent) => {\n        const touch = e.touches[0] || e.changedTouches[0];\n        this.prevY = touch.clientY;\n        this.prevX = touch.clientX;\n        this.dragging = true;\n    }\n\n    /**\n     * Called when mouse is risen on document stop drag\n     * @param e\n     */\n    mouseUp = (e: Event) => {\n        e.preventDefault();\n        this.dragging = false;\n    }\n\n    /**\n     * Called when the mouse is moved over the document to calculate the new position of\n     * the draggable canvas\n     * @param e\n     */\n    mouseMove = (e: MouseEvent) => {\n        this.drag(e.clientX, e.clientY);\n    }\n\n    /**\n     * Called when the touch is moved over the document to calculate the new position of\n     * the draggable canvas\n     * @param e\n     */\n    touchMove = (e: TouchEvent) => {\n        const touch = e.touches[0] || e.changedTouches[0];\n        this.drag(touch.clientX, touch.clientY);\n    }\n\n    /**\n     * Called when user drags over the document to move the panel\n     * @param clientX\n     * @param clientY\n     */\n    drag(clientX: number, clientY: number) {\n        if(this.dragging) {\n            const container = this.draggableContainer.current!;\n            let top = (container.offsetTop - (this.prevY - clientY))\n            let left = (container.offsetLeft - (this.prevX - clientX));\n            const content = this.draggableContent.current!;\n            const draggable = this.draggable.current!;\n            //stop drag if mouse goes out of bounds\n            if(clientY < 0 || clientY > window.innerHeight\n                || clientX < 0 || clientX > window.innerWidth) {\n                this.dragging = false;\n            }\n            //check if position is out of bounds and prevent the panel from being dragged there\n            if(top < 0) {\n                top = 0;\n            } else if (top > window.innerHeight - draggable.offsetHeight) {\n                top = window.innerHeight - draggable.offsetHeight;\n            }\n            if(left < -content.offsetWidth/2) {\n                left = -content.offsetWidth/2;\n            } else if(left > window.innerWidth - content.offsetWidth/2) {\n                left = window.innerWidth - content.offsetWidth/2;\n            }\n            //set new position\n            this.setState({\n                top: top,\n                left: left\n            });\n            //update previous pos\n            this.prevY = clientY;\n            this.prevX = clientX;\n        }\n    }\n\n    getPosition() {\n        const left = this.state.left;\n        const top = this.state.top;\n        if(left === -1 || top === -1) {\n            return {};\n        }\n        return {\n            left: left + 'px',\n            top: top + 'px',\n        };\n    }\n\n    visibleStyle()  {\n        return this.props.show ? 'block' : 'none';\n    }\n\n    draggableStyle() {\n        return {\n            width: this.props.width,\n            display: this.visibleStyle()\n        }\n    }\n\n    contentStyle() {\n        return {\n            width: this.props.width,\n            minHeight: this.props.height,\n            display: this.visibleStyle()\n        }\n    }\n\n    /**\n     * Renders the draggable component on top with the\n     *  children as the content within the panel\n     */\n    render() {\n        return (\n            <div\n                ref={this.draggableContainer}\n                className='draggable-container'\n                style={this.getPosition()}\n            >\n                {this.renderDraggable()}\n                <div\n                    ref={this.draggableContent}\n                    style={this.contentStyle()}\n                    className='draggable-content'\n                >\n                    <div className='settings-general'>\n                        {this.props.children}\n                    </div>\n                </div>\n            </div>\n        );\n    }\n\n    /**\n     * Renders the draggable component of the panel (just the top)\n     */\n    renderDraggable() {\n        return (\n            <div\n                style={this.draggableStyle()}\n                className='draggable'\n                ref={this.draggable}\n                onMouseDown={e => this.mouseDown(e.nativeEvent)}\n                onTouchStart={e => this.touchStart(e.nativeEvent)}\n            >\n                <div className='draggable-title'>{this.props.title}</div>\n                <div\n                    className='x-button'\n                    tabIndex={0}\n                    onKeyPress={this.props.onClickXButton}\n                    onClick={this.props.onClickXButton}\n                    onMouseDown={e => {\n                        e.stopPropagation();\n                        e.preventDefault();\n                    }}\n                >\n                    <div className='x-text'>\n                        X\n                    </div>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default DraggablePanel;","import {Point} from '../core/Components';\n\n/**\n * A simple data structure that keeps track of whether keys have been added to it\n */\nexport class HashSet\n{\n    private map: {[key: string]: boolean | undefined} = {};\n\n    add(key: string) {\n        this.map[key] = true;\n    }\n\n    remove(key: string) {\n        this.map[key] = undefined;\n    }\n\n    has(key: string) {\n        return this.map[key] !== undefined;\n    }\n\n    clear() {\n        this.map = {};\n    }\n}\n\n/**\n * A simple data structure that stores a type at a key\n */\nexport class HashTable<Value>\n{\n    private map: {[key: string]: Value | undefined} = {};\n\n    add(key: string, data: Value) {\n        this.map[key] = data;\n    }\n\n    remove(key: string) {\n        this.map[key] = undefined;\n    }\n\n    get(key: string) {\n        return this.map[key];\n    }\n\n    has(key: string) {\n        return this.map[key] !== undefined;\n    }\n\n    values() {\n        const values: Value[] = [];\n        for(const i in this.map) {\n            if(this.map[i] !== undefined) {\n                values.push(this.map[i]!);\n            }\n        }\n        return values;\n    }\n\n    clone() {\n        const table = new HashTable<Value>();\n        table.map = Object.assign({}, this.map);\n        return table;\n    }\n\n    clear() {\n        this.map = {};\n    }\n}\n\n/**\n * Serialize point into a unique string\n * @param point\n */\nexport function stringify(point: Point) {\n    return 'x' + point.x + 'y' + point.y;\n}","import React from 'react';\nimport {Node} from '../../pathfinding/algorithms/Node';\nimport {Point} from '../../pathfinding/core/Components';\nimport AppSettings from \"../../utils/AppSettings\";\nimport {HashTable, stringify} from '../../pathfinding/structures/Hash';\n\nconst CLOSED_NODE = 'rgb(198, 237, 238)';\nconst OPEN_NODE = 'rgb(191, 248, 159)';\nconst ARROW_COLOR = 'rgb(153,153,153)';\nconst EMPTY_NODE = 'e';\nconst TILE_CLASS = 'tile';\nconst VIZ_TILE_CLASS = 'tile-viz';\n\nconst BASE_WIDTH = 27;\n\ninterface Arrow {\n    to: Point,\n    from: Point\n}\n\ninterface IProps {\n    settings: AppSettings,\n    tileWidth: number,\n    width: number,\n    height: number\n}\n\n//scores and visualization are parallel arrays\ninterface IState {\n    visualization: string[][],\n    arrows: HashTable<Arrow> //arrows are uniquely defined by where they point to\n}\n\n/**\n * Represents a visualization canvas for the background grid\n * Can be mutated using functions to change the state of the current visualization\n */\nclass GridVisualization extends React.Component<IProps,IState>\n{\n    private readonly tileWidth: number;\n\n    private tileClass: string = TILE_CLASS;\n\n    /**\n     * Constructs a GridVisualization with immutable height and width\n     * @param props\n     */\n    constructor(props: IProps) {\n        super(props);\n        this.tileWidth = this.props.tileWidth;\n        this.state = {\n            visualization: this.createEmptyViz(),\n            arrows: new HashTable()\n        }\n    }\n\n    /**\n     * Checks if new width and height props have been passed in\n     * If so, the Grid must be resized by coping the visualization a new 2d array\n     * with a different size (some elements will be empty or cut off)\n     * @param prevProps\n     */\n    componentDidUpdate(prevProps: Readonly<IProps>) {\n        if(this.props.width !== prevProps.width\n            || this.props.height !== prevProps.height)\n        {\n            const visualization: string[][] = this.createEmptyViz();\n            for(let y = 0; y < this.props.height; y++) {\n                for(let x = 0; x < this.props.width; x++) {\n                    if(y < prevProps.height && x < prevProps.width) {\n                        visualization[y][x] = this.state.visualization[y][x];\n                    }\n                }\n            }\n            this.setState({\n                visualization: visualization\n            });\n        }\n    }\n\n    /**\n     * Create a new empty visualization canvas\n     */\n    createEmptyViz() {\n        const visualization: string[][] = [];\n        for(let y = 0; y < this.props.height; y++) {\n            const row: string[] = [];\n            for(let x = 0; x < this.props.width; x++) {\n                row.push(EMPTY_NODE);\n            }\n            visualization.push(row);\n        }\n        return visualization;\n    }\n\n    /**\n     * Clear the visualization canvas and update UI\n     */\n    clear() {\n        this.setState({\n            visualization: this.createEmptyViz(),\n            arrows: new HashTable()\n        });\n    }\n\n    /**\n     * Perform a generation on a visualization array\n     * @param generation\n     * @param visualization\n     */\n    static doVizGeneration(generation: Node, visualization: string[][]) {\n        for(const node of generation.children) {\n            const point = node.tile.point;\n            visualization[point.y][point.x] = OPEN_NODE;\n        }\n        const point = generation.tile.point;\n        visualization[point.y][point.x] = CLOSED_NODE;\n        return visualization;\n    }\n\n    /**\n     * Visualize generation and update UI\n     * @param generation\n     */\n    visualizeGeneration(generation: Node) {\n        this.setState(prevState => ({\n            visualization: GridVisualization.doVizGeneration(\n                generation,\n                clone(prevState.visualization)\n            )\n        }));\n    }\n\n    enableAnimations() {\n        this.tileClass = VIZ_TILE_CLASS;\n    }\n\n    disableAnimations() {\n        this.tileClass = TILE_CLASS;\n    }\n\n    /**\n     * Visualize generation array and update UI\n     * @param generations\n     */\n    visualizeGenerations(generations: Node[]) {\n        const visualization = this.createEmptyViz();\n        for(const generation of generations) {\n            GridVisualization.doVizGeneration(generation, visualization);\n        }\n        this.setState({\n            visualization: visualization\n        });\n    }\n\n    /**\n     * Perform an arrow generation on an arrow array\n     * @param generation\n     * @param arrows\n     */\n    static doArrowGeneration(generation: Node, arrows: HashTable<Arrow>) {\n        const point = generation.tile.point;\n        for(const node of generation.children) {\n            const childPoint = node.tile.point;\n            const newArrow = {\n                from: point,\n                to: childPoint,\n            };\n            //remove a duplicate arrow to indicate replacement\n            //in A* for example, we could have re-discovered a better path to a tile\n            arrows.add(stringify(newArrow.to), newArrow);\n        }\n        return arrows;\n    }\n\n    /**\n     * Add arrow generation without updating UI\n     * @param generation\n     */\n    addArrowGeneration(generation: Node) {\n        this.setState(prevState => ({\n            arrows: GridVisualization.doArrowGeneration(\n                generation,\n                prevState.arrows.clone()\n            )\n        }));\n    }\n\n    /**\n     * Add arrow generations and update UI\n     * @param generations\n     */\n    addArrowGenerations(generations: Node[]) {\n        const arrows: HashTable<Arrow> = new HashTable();\n        for(const generation of generations) {\n            GridVisualization.doArrowGeneration(generation, arrows)\n        }\n        this.setState({\n            arrows: arrows\n        });\n    }\n\n    /**\n     * Visualize both generation and arrows and update UI\n     * @param generation\n     */\n    visualizeGenerationAndArrows(generation: Node) {\n        this.setState(prevState => ({\n            visualization: GridVisualization.doVizGeneration(\n                generation,\n                clone(prevState.visualization)\n            ),\n            arrows: GridVisualization.doArrowGeneration(\n                generation,\n                prevState.arrows.clone()\n            )\n        }));\n    }\n\n    /**\n     * Renders the visualization in the background with the arrows in front\n     * Arrows may or may not be rendered\n     */\n    render() {\n        return (\n            <div>\n                <div className='bg'>\n                    {this.renderViz()}\n                </div>\n                <svg\n                    xmlns='http://www.w3.org/2000/svg'\n                    className='bg-grid'\n                >\n                    <defs>\n                        <marker\n                            id='arrowhead'\n                            markerWidth='3'\n                            markerHeight='3'\n                            refX='0'\n                            refY='1.5'\n                            orient='auto'\n                            fill={ARROW_COLOR}\n                        >\n                            <polygon points='0 0, 3 1.5, 0 3'/>\n                        </marker>\n                    </defs>\n                    {this.props.settings.showArrows ?\n                        this.renderArrows() :\n                        []\n                    }\n                </svg>\n            </div>\n        );\n    }\n\n    /**\n     * Renders the arrows showing the tree of the visualization\n     * Can only be properly displayed in the svg canvas with the arrowhead marker\n     */\n    renderArrows() {\n        const width = this.tileWidth;\n        const offset = width/2;\n        const arrows: JSX.Element[] = [];\n        const arrowList = this.state.arrows.values();\n        for(let i = 0; i < arrowList.length; i++) {\n            //calculate arrow position and dimensions\n            const arrow = arrowList[i];\n            const first = arrow.from;\n            const second = arrow.to;\n            const firstX = first.x * width;\n            const firstY = first.y * width;\n            const secondX = second.x * width;\n            const secondY = second.y * width;\n            const offsetX = (secondX - firstX)/4;\n            const offsetY = (secondY - firstY)/4;\n            arrows.push(\n                <line\n                    key={'arrow ' + i}\n                    x1={firstX + offset + offsetX}\n                    y1={firstY + offset + offsetY}\n                    x2={secondX + offset - offsetX}\n                    y2={secondY + offset - offsetY}\n                    stroke={ARROW_COLOR}\n                    strokeWidth={2 * this.tileWidth/BASE_WIDTH}\n                    className='line-arrow'\n                    markerEnd='url(#arrowhead)'\n                />\n            );\n        }\n        return arrows;\n    }\n\n    /**\n     * Renders the visualization as a 2d array of jsx elements\n     * It is possible for the height and width props to be out of sync with the\n     *  visualization array if the resize called after new props are passed in hasn't\n     *  finished before render is called again.\n     *  If this happens, any any out of bound visualizations are just empty\n     */\n    renderViz() {\n        const tiles: JSX.Element[][] = [];\n        for(let y = 0; y < this.props.height; y++) {\n            const row: JSX.Element[] = [];\n            for(let x = 0; x < this.props.width; x++) {\n                const inBounds = (this.state.visualization[y]||[])[x] !== undefined;\n                const viz = inBounds ? this.state.visualization[y][x] : EMPTY_NODE;\n                if(viz !== EMPTY_NODE) {\n                    const point = {\n                        x: x, y: y\n                    };\n                    row.push(\n                        this.renderTile(point, viz)\n                    );\n                }\n            }\n            tiles.push(row);\n        }\n        return tiles;\n    }\n\n    /**\n     * Renders a single tile, that may be animated depending on the state\n     * @param point\n     * @param color\n     */\n    renderTile(point: Point, color: string) {\n        const width = this.tileWidth;\n        const top = point.y * width;\n        const left = point.x * width;\n        const style = {\n            backgroundColor: color,\n            width: width + 'px',\n            height: width + 'px',\n            top: top,\n            left: left,\n            fontSize: 10 * width/BASE_WIDTH\n        };\n        return (\n            <div\n                key={point.x + ',' + point.y}\n                style={style}\n                className={this.tileClass}\n            />\n        );\n    }\n}\n\nfunction clone<T>(array: T[][]) {\n    return array.map(\n        (arr) => arr.slice()\n    );\n}\n\nexport default GridVisualization;","/**\n * Represents a point in 2d space\n * Immutable\n */\nexport interface Point\n{\n    readonly x: number;\n    readonly y: number;\n}\n\n/**\n * Represents the data inside a tile\n * Solid tiles cannot be passed while non solid ones can\n * pathCost stores how expensive it is to travel to the tile if it isn't solid\n * Immutable\n */\nexport interface TileData\n{\n    readonly pathCost: number;\n    readonly isSolid: boolean;\n}\n\n/**\n * Represents a tile on the Grid\n */\nexport interface Tile\n{\n    data: TileData;\n    readonly point: Point;\n}\n\n/**\n * Simple function to create a solid tile with path cost of 1\n * @param isSolid\n */\nexport function createTileData(isSolid: boolean): TileData {\n    return {\n        pathCost: 1,\n        isSolid: isSolid\n    }\n}\n\n","import {createTileData, Point, Tile, TileData} from './Components';\n\nexport interface Grid\n{\n    getWidth(): number;\n    getHeight(): number;\n    inBounds(point: Point): boolean;\n    get(point: Point): Tile;\n    isSolid(point: Point): boolean;\n    mutate(point: Point, data: TileData): void;\n    mutateTile(tile: Tile): void;\n    mutateDefault(point: Point, solid: boolean): void;\n    output(console: Console): void;\n    getJson(): string;\n    walkable(point: Point): boolean;\n    isEmpty(point: Point): boolean;\n    clone(): Grid,\n    cloneNewSize(width: number, height: number): Grid;\n}\n\n/**\n * A square grid system that stores nodes in a matrix\n * Uses an x,y system where x corresponds to column of the matrix,\n * and y corresponds to the row of the matrix\n * Tile should be treated like graph nodes\n */\nclass RectGrid implements Grid\n{\n    private readonly tiles: Tile[][];\n    private readonly width: number;\n    private readonly height: number;\n\n    /**\n     * Constructs a grid either with empty or predefined tiles\n     * @param width of the grid\n     * @param height of grid\n     */\n    constructor(width: number, height: number) {\n        this.width = width;\n        this.height = height;\n        this.tiles = createEmptyGrid(width, height);\n    }\n\n    getWidth() {\n        return this.width;\n    }\n\n    getHeight() {\n        return this.height;\n    }\n\n    /**\n     * Checks if a given point is in bounds\n     * Other functions assume arguments are in bounds, this should be used\n     * if there is reasonable doubt about whether a point is in bounds\n     * @param point, to check\n     */\n    inBounds(point: Point) {\n        return point.x >= 0 && point.x < this.width && point.y >= 0 && point.y < this.height;\n    }\n\n    /**\n     * Retrieves a defensive tile for a position\n     * Defensive copy prevents this object from being mutated without calling\n     * a mutate function\n     * @param point, point to get\n     */\n    get(point: Point) {\n        return {\n            point: this.tiles[point.y][point.x].point,\n            data: this.tiles[point.y][point.x].data\n        }\n    }\n\n    /**\n     * Mutates a position's tile to solid or non solid\n     * @param point, point to mutate\n     * @param data to mutate to\n     */\n    mutate(point: Point, data: TileData) {\n        this.tiles[point.y][point.x].data = data;\n    }\n\n    /**\n     * Mutates a a tile by point\n     * @param tile to mutate\n     */\n    mutateTile(tile: Tile) {\n        this.tiles[tile.point.y][tile.point.x].data = tile.data;\n    }\n\n    /**\n     * Mutate tile at point\n     * @param point to mutate at\n     * @param solid to determine what default tile to create\n     */\n    mutateDefault(point: Point, solid: boolean) {\n        this.mutate(\n            point, createTileData(solid)\n        );\n    }\n\n    /**\n     * Outputs the grid to a console\n     * @param console\n     */\n    output(console: Console) {\n        for(let y = 0; y < this.height; y++) {\n            let str = '';\n            for(let x = 0; x < this.width; x++) {\n                str += this.tiles[y][x].data.isSolid + ', ';\n            }\n            console.log(str);\n        }\n    }\n\n    /**\n     * Returns json of tiles\n     */\n    getJson() {\n        return JSON.stringify(this.tiles);\n    }\n\n    /**\n     * Determines if a tile can be walked on\n     * @param point\n     */\n    walkable(point: Point) {\n        return !this.tiles[point.y][point.x].data.isSolid;\n    }\n\n    /**\n     * Determines if a tile isSolid\n     * @param point\n     */\n    isSolid(point: Point) {\n        return this.tiles[point.y][point.x].data.isSolid;\n    }\n\n    /**\n     * Determines if a tile is \"empty\"\n     *  Meaning it isn't solid and it has a pathCost of 1\n     * @param point\n     */\n    isEmpty(point: Point) {\n        const data = this.tiles[point.y][point.x].data;\n        return data.pathCost === 1 && !data.isSolid\n    }\n\n    clone() {\n        const grid = new RectGrid(this.width, this.height);\n        for(let y = 0; y < grid.height; y++) {\n            for(let x = 0; x < grid.width; x++) {\n                const point = {\n                    x: x, y: y\n                }\n                grid.mutateTile(this.get(point));\n            }\n        }\n        return grid;\n    }\n\n    cloneNewSize(width: number, height: number) {\n        const grid = new RectGrid(width, height);\n        for(let y = 0; y < grid.height; y++) {\n            for(let x = 0; x < grid.width; x++) {\n                const point = {\n                    x: x, y: y\n                }\n                if(this.inBounds(point)) {\n                    grid.mutateTile(this.get(point));\n                }\n            }\n        }\n        return grid;\n    }\n}\n\n/**\n * Creates a 2d matrix of empty nodes\n */\nfunction createEmptyGrid(width: number, height: number) {\n    const nodes: Tile[][] = [];\n    for(let y = 0; y < height; y++) {\n        const row: Tile[] = [];\n        for(let x = 0; x < width; x++) {\n            row.push({\n                point: {\n                    x: x, y: y\n                },\n                data: createTileData(false)\n            });\n        }\n        nodes.push(row);\n    }\n    return nodes;\n}\n\nexport default RectGrid;","import React from 'react';\nimport {Point} from '../../pathfinding/core/Components';\n\ninterface TileProps {\n    tileWidth: number,\n    point: Point,\n    color: string,\n}\n\nclass TileFg extends React.Component<TileProps>\n{\n    render() {\n        const size = this.props.tileWidth\n        const top = this.props.point.y * this.props.tileWidth;\n        const left = this.props.point.x * this.props.tileWidth;\n        return (\n            <div\n                style={{\n                    position: 'absolute',\n                    width: size,\n                    height: size,\n                    top: top,\n                    left: left,\n                    backgroundColor: this.props.color,\n                    display: 'block',\n                    borderColor: this.props.color\n                }}\n                className={'svg-tile tile-fg'}\n            />\n        );\n    }\n}\n\nexport default TileFg;","import React from 'react';\nimport {Point} from '../../pathfinding/core/Components';\n\ninterface SolidProps {\n    tileSize: number,\n    point: Point,\n    doTileAnimation: boolean\n}\n\nclass SolidFg extends React.Component<SolidProps>\n{\n    private readonly doTileAnimation: boolean;\n\n    constructor(props: SolidProps) {\n        super(props)\n        this.doTileAnimation = this.props.doTileAnimation;\n    }\n\n    render() {\n        return (\n            <div\n                style={{\n                    position: 'absolute',\n                    left: this.props.point.x * this.props.tileSize,\n                    top: this.props.point.y * this.props.tileSize,\n                    width: this.props.tileSize,\n                    height: this.props.tileSize\n                }}\n                className={this.doTileAnimation ? 'solid-animation' : 'solid'}\n            />\n        );\n    }\n}\n\nexport default SolidFg;","export default __webpack_public_path__ + \"static/media/weight.a40386fb.svg\";","import React from 'react';\nimport {Point} from '../../pathfinding/core/Components';\nimport Weight from '../../assets/weight.svg';\n\ninterface WeightProps {\n    tileSize: number,\n    point: Point,\n    doTileAnimation: boolean\n}\n\nclass WeightFg extends React.Component<WeightProps>\n{\n    private readonly doTileAnimation: boolean;\n\n    constructor(props: WeightProps) {\n        super(props)\n        this.doTileAnimation = this.props.doTileAnimation;\n    }\n\n    render() {\n        return (\n            <div\n                style={{\n                    left: this.props.point.x * this.props.tileSize,\n                    top: this.props.point.y * this.props.tileSize,\n                    width: this.props.tileSize,\n                    height: this.props.tileSize,\n                    backgroundImage: `url(${Weight})`,\n                    position: 'absolute'\n                }}\n                className={this.doTileAnimation ? 'weight-animation' : 'weight'}\n            />\n        );\n    }\n}\n\nexport default WeightFg;","import React, {RefObject} from 'react';\nimport {createTileData, Point, Tile, TileData} from '../../pathfinding/core/Components';\nimport RectGrid, {Grid} from '../../pathfinding/core/Grid';\nimport TileFg from './TileFg';\nimport SolidFg from './SolidFg';\nimport WeightFg from './WeightFg';\n\ninterface IProps {\n    tileSize: number,\n    width: number,\n    height: number,\n    onTilesDragged: () => void,\n    end: Point\n}\n\ninterface IState {\n    grid: Grid,\n    initial: Point,\n    goal: Point,\n    path: Tile[]\n}\n\nconst INITIAL_COLOR = 'rgb(131, 217, 52)';\nconst GOAL_COLOR = 'rgb(203, 75, 14)';\nconst ARROW_PATH_COLOR = 'rgb(73, 79, 250)';\n\nconst BASE_WIDTH = 27;\n\n/**\n * Represents actual tile contents of the Grid itself\n * Will re-render itself when given a new Grid\n * Binds listeners to allow user to \"draw\" on the grid foreground\n */\nclass GridForeground extends React.Component<IProps,IState>\n{\n    private svg: RefObject<SVGSVGElement> = React.createRef();\n\n    private tilePointer: TileData;\n\n    private drawing: boolean = false;\n    private erasing: boolean = false;\n    private draggingInitial: boolean = false;\n    private draggingGoal: boolean = false;\n    private disable: boolean = false;\n\n    private doTileAnimation: boolean = true;\n\n    private initialKey: number = 0;\n    private goalKey: number = 0;\n\n    /**\n     * Constructs a GridForeground with immutable height and width\n     * @param props\n     */\n    constructor(props: IProps) {\n        super(props);\n        const end = this.props.end;\n        this.tilePointer = createTileData(true);\n        this.state = {\n            grid: new RectGrid(this.props.width, this.props.height),\n            path: [],\n            initial: {\n                x: ((end.x)/3) >> 0,\n                y: ((end.y)/3) >> 0\n            },\n            goal: {\n                x: ((2*(end.x)/3) >> 0) - 1,\n                y: ((2*(end.y)/3) >> 0) - 1\n            }\n        }\n    }\n\n    componentDidUpdate(prevProps: IProps) {\n        if(this.props.width !== prevProps.width\n            || this.props.height !== prevProps.height)\n        {\n            this.setState(prevState => ({\n                grid: prevState.grid.cloneNewSize(this.props.width, this.props.height)\n            }));\n        }\n    }\n\n    changeTile(data: TileData) {\n        this.tilePointer = data;\n    }\n\n    toggleDisable() {\n        this.disable = !this.disable;\n    }\n\n    getBoundingRect() {\n        return this.svg.current!.getBoundingClientRect();\n    }\n\n    mouseDown(e: MouseEvent) {\n        e.preventDefault();\n        const bounds = this.getBoundingRect();\n        this.onPress(e.clientX - bounds.left, e.clientY - bounds.top, e.button);\n    }\n\n    mouseUp(e: MouseEvent) {\n        e.preventDefault();\n        if(isControlKey(e.button)) {\n            this.draggingGoal = false;\n            this.draggingInitial = false;\n            this.drawing = false;\n            this.erasing = false;\n        }\n    }\n\n    mouseMove(e: MouseEvent) {\n        const bounds = this.getBoundingRect();\n        this.onDrag(e.clientX - bounds.left, e.clientY - bounds.top);\n    }\n\n    touchStart(e: TouchEvent) {\n        const touch = e.touches[0] || e.changedTouches[0];\n        const bounds = this.getBoundingRect();\n        this.onPress(touch.clientX - bounds.left, touch.clientY - bounds.top, 0);\n    }\n\n    touchMove(e: TouchEvent) {\n        const touch = e.touches[0] || e.changedTouches[0];\n        const bounds = this.getBoundingRect();\n        this.onDrag(touch.clientX - bounds.left, touch.clientY - bounds.top);\n    }\n\n    onEndingEvent(e: Event) {\n        e.preventDefault();\n        this.draggingGoal = false;\n        this.draggingInitial = false;\n        this.drawing = false;\n        this.erasing = false;\n    }\n\n    /**\n     * Responds to the event thrown at screen coordinates on press\n     * @param xCoordinate\n     * @param yCoordinate\n     * @param button\n     */\n    onPress(xCoordinate: number, yCoordinate: number, button: number) {\n        const point = this.calculatePoint(xCoordinate,yCoordinate);\n        if(isControlKey(button)) {\n            if(pointsEqual(point, this.state.initial)) {\n                this.draggingInitial = true;\n            } else if(pointsEqual(point, this.state.goal)) {\n                this.draggingGoal = true;\n            } else if(!this.disable) {\n                if(this.state.grid.isEmpty(point)) {\n                    this.drawing = true;\n                    this.drawTile(point);\n                } else {\n                    this.erasing = true;\n                    this.eraseTile(point);\n                }\n            }\n        }\n    }\n\n    /**\n     * Responds to the event thrown at screen coordinates on drag/move\n     * @param xCoordinate\n     * @param yCoordinate\n     */\n    onDrag(xCoordinate: number, yCoordinate: number) {\n        const point = this.calculatePoint(xCoordinate,yCoordinate);\n        if(this.draggingInitial) {\n            this.moveInitial(point);\n        } else if(this.draggingGoal) {\n            this.moveGoal(point);\n        } else if(!pointsEqual(point, this.state.initial)\n            && !pointsEqual(point, this.state.goal) && !this.disable)\n        {\n            if(this.drawing) {\n                this.drawTile(point);\n            } else if(this.erasing) {\n                this.eraseTile(point);\n            }\n        }\n    }\n\n    /**\n     * Draw an entire new grid on the foreground with disabled animations\n     * @param grid\n     */\n    drawGrid(grid: Grid) {\n        this.doTileAnimation = false;\n        this.setState({\n            grid: grid\n        }, () => this.doTileAnimation = true)\n    }\n\n    /**\n     * Draw tile at point\n     * @param point\n     */\n    drawTile(point: Point) {\n        const grid = this.state.grid.clone();\n        if(grid.inBounds(point)) {\n            grid.mutateTile({\n                point: point,\n                data: this.tilePointer\n            });\n        }\n        this.setState({\n            grid: grid\n        });\n    }\n\n    /**\n     * Checks if a node is visualized, then changes the tile to empty if it isn't\n     * @param point\n     */\n    eraseTile(point: Point) {\n        const grid = this.state.grid.clone();\n        if(grid.inBounds(point)) {\n            grid.mutateDefault(point, false);\n        }\n        this.setState({\n            grid: grid\n        });\n    }\n\n    /**\n     * Clear grid in state\n     */\n    clearTiles() {\n        const grid = this.state.grid.clone();\n        for(let y = 0; y < this.state.grid.getHeight(); y++) {\n            for(let x = 0; x < this.state.grid.getWidth(); x++) {\n                const point = {\n                    x: x, y: y\n                }\n                grid.mutateDefault(point, false);\n            }\n        }\n        this.setState({\n            grid: grid\n        });\n    }\n\n    /**\n     * Moves initial to a new point\n     * @param point\n     */\n    moveInitial(point: Point) {\n        if(this.canMoveEndPoint(point)) {\n            this.initialKey++;\n            this.setState({\n                initial: point\n            }, () => this.props.onTilesDragged());\n        }\n    }\n\n    /**\n     * Moves goal to a new point\n     * @param point\n     */\n    moveGoal(point: Point) {\n        if(this.canMoveEndPoint(point)) {\n            this.goalKey++;\n            this.setState({\n                goal: point\n            }, () => this.props.onTilesDragged());\n        }\n    }\n\n    /**\n     * Checks if we can move any of the end points (goal or initial) to that point\n     * @param point\n     */\n    canMoveEndPoint(point: Point) {\n        return this.state.grid.inBounds(point)\n            && this.state.grid.isEmpty(point)\n            && !pointsEqual(this.state.initial, point)\n            && !pointsEqual(this.state.goal, point)\n            && !this.disable;\n    }\n\n    /**\n     * Draw a path onto the grid\n     * @param path\n     */\n    drawPath(path: Tile[]) {\n        this.setState({\n            path: path.slice()\n        });\n    }\n\n    /**\n     * Erase path from the grid\n     */\n    erasePath() {\n        this.setState({\n            path: []\n        });\n    }\n\n    /**\n     * Converts real screen x,y coordinates into\n     * a 2d point position on the grid\n     * @param xCoordinate\n     * @param yCoordinate\n     */\n    calculatePoint(xCoordinate: number, yCoordinate: number) {\n        return {\n            x: Math.floor(xCoordinate/this.props.tileSize),\n            y: Math.floor(yCoordinate/this.props.tileSize)\n        }\n    }\n\n    resetPoints() {\n        this.initialKey++;\n        this.goalKey++;\n        const end = this.props.end;\n        this.setState({\n            initial: {\n                x: ((end.x)/3) >> 0,\n                y: ((end.y)/3) >> 0\n            },\n            goal: {\n                x: ((2*(end.x)/3) >> 0) - 1,\n                y: ((2*(end.y)/3) >> 0) - 1\n            }\n        });\n    }\n\n    /**\n     * Renders the end tiles (initial and goal) behind\n     * Path arrows are rendered on an svg canvas above the end tiles\n     * The tiles Grid containing the rendered tiles from the grid state is displayed on top\n     *  it also is bound to event listeners to allow grid to be drawn/erased on\n     */\n    render() {\n        return (\n            <div>\n                <div\n                    className='endpoint-tiles-table'\n                >\n                    {this.renderEndTile(this.state.initial, INITIAL_COLOR,'initial' + this.initialKey)}\n                    {this.renderEndTile(this.state.goal, GOAL_COLOR,'goal' + this.goalKey)}\n                </div>\n                <svg\n                    ref={this.svg}\n                    xmlns='http://www.w3.org/2000/svg'\n                    className='arrow-grid'\n                >\n                    <defs>\n                        <marker\n                            id='arrowhead-path'\n                            markerWidth='3'\n                            markerHeight='3'\n                            refX='0'\n                            refY='1.5'\n                            orient='auto'\n                            fill={ARROW_PATH_COLOR}\n                        >\n                            <polygon points='0 0, 3 1.5, 0 3'/>\n                        </marker>\n                    </defs>\n                    {this.renderPath()}\n                </svg>\n                <div\n                    className='tiles-table'\n                    onContextMenu={e => e.preventDefault()}\n                    onMouseDown={e => this.mouseDown(e.nativeEvent)}\n                    onMouseUp={e => this.mouseUp(e.nativeEvent)}\n                    onMouseMove={e => this.mouseMove(e.nativeEvent)}\n                    onMouseLeave={e => this.onEndingEvent(e.nativeEvent)}\n                    onTouchStart={e => this.touchStart(e.nativeEvent)}\n                    onTouchMoveCapture={e => this.touchMove(e.nativeEvent)}\n                    onTouchEnd={e => this.onEndingEvent(e.nativeEvent)}\n                    onTouchCancel={e => this.onEndingEvent(e.nativeEvent)}\n                >\n                    {this.renderTilesGrid()}\n                </div>\n            </div>\n        );\n    }\n\n    /**\n     * Renders the solved path out of pathArrows between neighboring tile\n     * Can only be properly displayed in an svg canvas\n     */\n    renderPath() {\n        const lines: JSX.Element[] = [];\n        for(let i = 0; i < this.state.path.length-1; i++) {\n            const first = this.state.path[i].point;\n            const second = this.state.path[i+1].point;\n            lines.push(this.renderPathArrow(i, first, second));\n        }\n        return lines;\n    }\n\n    /**\n     * Renders a single blue arrow between two points to make up the\n     * path that represents the solved path\n     * Can only be properly displayed in an svg canvas\n     */\n    renderPathArrow(index: number, first: Point, second: Point) {\n        const width = this.props.tileSize;\n        const offset = width/2;\n        const firstX = first.x * width;\n        const firstY = first.y * width;\n        const secondX = second.x * width;\n        const secondY = second.y * width;\n        const offsetX = (secondX - firstX)/4;\n        const offsetY = (secondY - firstY)/4;\n        return (\n            <line\n                key={'path ' + index}\n                x1={firstX + offset + offsetX}\n                y1={firstY + offset + offsetY}\n                x2={secondX + offset - offsetX}\n                y2={secondY + offset - offsetY}\n                stroke={ARROW_PATH_COLOR}\n                strokeWidth={2 * this.props.tileSize/BASE_WIDTH}\n                className='line'\n                markerEnd='url(#arrowhead-path)'\n            />\n        );\n    }\n\n    /**\n     * Iterate through the grid stored in the state and render each tile\n     * Solid tiles are rendered as grey squares\n     * Empty tiles (non solid tiles with a weight/cost of 1)\n     * Weighted tiles with a cost of higher than 1 are rendered with a weight png and a label\n     */\n    renderTilesGrid() {\n        const tiles: JSX.Element[] = [];\n        for(let y = 0; y < this.state.grid.getHeight(); y++) {\n            for(let x = 0; x < this.state.grid.getWidth(); x++) {\n                const point = {\n                    x: x, y: y\n                }\n                const cost = this.state.grid.get(point).data.pathCost;\n                if(this.state.grid.isSolid(point)) {\n                    //render a solid tile div\n                    tiles.push(\n                        <SolidFg\n                            key={x + ',' + y}\n                            point={point}\n                            tileSize={this.props.tileSize}\n                            doTileAnimation={this.doTileAnimation}\n                        />\n                    );\n                } else if(cost > 1) {\n                    //render a weight svg\n                    tiles.push(\n                        <WeightFg\n                            key={x + ',' + y}\n                            point={point}\n                            tileSize={this.props.tileSize}\n                            doTileAnimation={this.doTileAnimation}\n                        />\n                    );\n                    //render a div containing the cost as text\n                    tiles.push(\n                        this.renderWeightText(\n                            point,\n                            cost,\n                            x + ',' + y + ' text'\n                        )\n                    )\n                }\n            }\n        }\n        return tiles;\n    }\n\n    /**\n     * Renders the text (cost of the weight) to be overlay on top of the weight\n     *  The point should be the same as the weight the text is for\n     * @param point\n     * @param cost\n     * @param key\n     */\n    renderWeightText(point: Point, cost: number, key: string) {\n        return (\n            <div\n                key={key}\n                style={{\n                    left: point.x * this.props.tileSize,\n                    top: point.y * this.props.tileSize,\n                    width: this.props.tileSize,\n                    height: this.props.tileSize,\n                    position: 'absolute',\n                    color: 'white',\n                    fontSize: this.props.tileSize / 2.1,\n                    paddingTop: this.props.tileSize / 3.70,\n                    textAlign: 'center',\n                    cursor: 'default'\n                }}\n            >\n                {cost}\n            </div>\n        );\n    }\n\n    renderEndTile(point: Point, color: string, key: string) {\n        return (\n            <TileFg\n                key={key}\n                point={point}\n                tileWidth={this.props.tileSize}\n                color={color}\n            />\n        );\n    }\n}\n\nfunction pointsEqual(point1: Point, point2: Point) {\n    return point1.x === point2.x && point1.y === point2.y;\n}\n\nfunction isControlKey(button: number) {\n    //right or left mouse\n    return button === 0 || button === 2;\n}\n\nexport default GridForeground;","import React, {RefObject} from 'react';\n\ninterface IProps {\n    algorithm: string,\n    length: number,\n    cost: number,\n    time: number,\n    nodes: number\n}\n\nclass Stats extends React.Component<IProps>\n{\n    private readonly textLog: RefObject<HTMLTextAreaElement> = React.createRef();\n\n    componentDidUpdate() {\n        this.textLog.current!.scrollTop = this.textLog.current!.scrollHeight;\n    }\n\n    render() {\n        const time = precise(this.props.time);\n        const text = this.props.algorithm === '' ? '' :\n            `${this.props.algorithm} visited ${this.props.nodes} nodes in ${time} ms. ` +\n            `Path length = ${this.props.length}. Path cost = ${this.props.cost}.`;\n        return(\n            <textarea\n                tabIndex={-1}\n                ref={this.textLog}\n                readOnly={true}\n                className='stats-text-area no-select'\n                value={text}\n                unselectable={'on'}\n                onDrop={() => false}\n            />\n        );\n    }\n}\n\nfunction precise(x: number) {\n    return x.toFixed(2);\n}\n\nexport default Stats;","import React from 'react';\nimport {Point} from '../../pathfinding/core/Components';\n\ninterface IProps {\n    tileWidth: number,\n    width: number,\n    height: number\n}\n\n/**\n * A component for a grid with specific width and height proportions\n */\nclass GridBackground extends React.Component<IProps>\n{\n    private readonly tileWidth: number;\n\n    /**\n     * Constructs a GridVisualization with immutable height and width\n     * @param props\n     */\n    constructor(props: IProps) {\n        super(props);\n        this.tileWidth = this.props.tileWidth;\n    }\n\n    componentDidUpdate(prevProps: IProps) {\n        return this.props.width !== prevProps.width ||\n            this.props.height !== prevProps.height;\n    }\n\n    render() {\n        return (\n            <div>\n                <div className='bg'>\n                    {this.renderTiles()}\n                </div>\n            </div>\n        );\n    }\n\n    renderTiles() {\n        const tiles: JSX.Element[][] = [];\n        for(let y = 0; y < this.props.height; y++) {\n            const row: JSX.Element[] = [];\n            for(let x = 0; x < this.props.width; x++) {\n                const point = {\n                    x: x, y: y\n                };\n                row.push(\n                    this.renderTile(point)\n                );\n            }\n            tiles.push(row);\n        }\n        return tiles;\n    }\n\n    renderTile(point: Point) {\n        const width = this.tileWidth;\n        const top = point.y * this.tileWidth;\n        const left = point.x * this.tileWidth;\n        const style = {\n            backgroundColor: 'white',\n            width: width + 'px',\n            height: width + 'px',\n            top: top,\n            left: left\n        };\n        return (\n            <div\n                key={point.x + ',' + point.y}\n                style={style}\n                className='tile'\n            />\n        );\n    }\n}\n\nexport default GridBackground;","import {Point, Tile} from './Components';\nimport Navigator, {UNIT} from './Navigator';\n\n/**\n * Concretion of a Plus Navigator for a grid\n * Allows movement akin to a 'plus' symbol\n */\nclass PlusNavigator extends Navigator\n{\n    /**\n     * Adds the neighbors of a point to the left, right, top and down\n     * @param point\n     */\n    neighbors(point: Point) {\n        const tiles: Tile[] = [];\n        if(point.x + UNIT < this.grid.getWidth()) {\n            const tile = this.grid.get({\n                x: point.x + UNIT,\n                y: point.y\n            })\n            if(!tile.data.isSolid) {\n                tiles.push(tile);\n            }\n        }\n        if(point.y + UNIT < this.grid.getHeight()) {\n            const tile = this.grid.get({\n                x: point.x,\n                y: point.y + UNIT\n            });\n            if(!tile.data.isSolid) {\n                tiles.push(tile);\n            }\n        }\n        if(point.x - UNIT >= 0) {\n            const tile = this.grid.get({\n                x: point.x - UNIT,\n                y: point.y\n            });\n            if(!tile.data.isSolid) {\n                tiles.push(tile);\n            }\n        }\n        if(point.y - UNIT >= 0) {\n            const tile = this.grid.get({\n                x: point.x,\n                y: point.y - UNIT\n            });\n            if(!tile.data.isSolid) {\n                tiles.push(tile);\n            }\n        }\n        return tiles;\n    }\n\n    /**\n     * Step cost function that works by getting the pathCost stored in the grid\n     * from one point a to b\n     * @param a\n     * @param b to point to travel to\n     */\n    cost(a: Point, b: Point) {\n        return this.grid.get(b).data.pathCost;\n    }\n\n    getType() {\n        return 'plus';\n    }\n}\n\nexport default PlusNavigator;","import {Grid} from './Grid';\nimport {Point, Tile} from './Components';\n\nexport const UNIT = 1; //number of tiles we can move at once\n\n/**\n * Describes an abstract navigator for a grid\n * Provides graph-like traversal for the grid\n * Determines where we can travel to from a certain point,\n * whether we have reached a destination, and the cost to\n * travel to a certain point\n */\nabstract class Navigator\n{\n    protected readonly grid: Grid;\n\n    constructor(grid: Grid) {\n        this.grid = grid;\n    }\n\n    getGrid() {\n        return this.grid;\n    }\n\n    /**\n     * Goal check function: Checks if two points are equal\n     * @param a\n     * @param b\n     */\n    equals(a: Point, b: Point) {\n        return a.x === b.x && a.y === b.y;\n    }\n\n    /**\n     * Step cost function from a to b\n     * @param a\n     * @param b to point to travel to\n     */\n    abstract cost(a: Point, b: Point): number;\n\n    /**\n     * Neighbors function: Gets the available neighbors for a point in a grid we can make\n     * in a given move\n     * @param point\n     */\n    abstract neighbors(point: Point): Tile[];\n\n    abstract getType(): string;\n}\n\nexport default Navigator;","import {Point} from '../core/Components';\n\nexport type HeuristicFunc = (a: Point, b: Point) => number;\n\nexport function manhattan(a: Point, b: Point) {\n    const dx = Math.abs(a.x - b.x) ;\n    const dy = Math.abs(a.y - b.y);\n    return dx + dy;\n}\n\nexport function euclidean(a: Point, b: Point) {\n    const dx = Math.abs(a.x - b.x);\n    const dy = Math.abs(a.y - b.y);\n    return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function octile(a: Point, b: Point) {\n    const dx = Math.abs(a.x - b.x);\n    const dy = Math.abs(a.y - b.y);\n    return Math.SQRT2 * Math.min(dx, dy) + Math.abs(dx - dy);\n}\n\nexport function chebyshev(a: Point, b: Point) {\n    const dx = Math.abs(a.x - b.x);\n    const dy = Math.abs(a.y - b.y);\n    return Math.max(dx, dy);\n}\n\nexport function nullHeuristic() {\n    return 0;\n}","import {Point, Tile} from '../core/Components';\nimport Navigator from '../core/Navigator';\nimport {Node} from './Node';\n\n/**\n * Pathfinder performs algorithms operations on the grid\n * Uses the navigator rank and expand nodes\n */\nabstract class Pathfinder\n{\n    protected recentSearch: Node[] = [];\n    protected navigator: Navigator;\n\n    constructor(navigator: Navigator) {\n        this.navigator = navigator;\n    }\n\n    setNavigator(navigator: Navigator) {\n        this.navigator = navigator;\n    }\n\n    getNavigator() {\n        return this.navigator;\n    }\n\n    getRecentNodes() {\n        return this.recentSearch.length;\n    }\n\n    clearRecentSearch() {\n        this.recentSearch = [];\n    }\n\n    getRecentGenerations() {\n        return this.recentSearch.slice();\n    }\n\n    protected addRecent(node: Node) {\n        this.recentSearch.push(node);\n    }\n\n    abstract getAlgorithmName(): string;\n\n    /**\n     * Finds the best path between initial and goal on the grid\n     * and returns it in an array\n     * @param initial\n     * @param goal\n     */\n    abstract findPath(initial: Point, goal: Point): Tile[];\n}\n\n/**\n * Reconstructs the path from a tree, given the bottomLeaf, and\n * returns the shortest path in an array\n * @param bottomLeaf bottom of the tree to start from\n */\nexport function reconstructPath(bottomLeaf: Node) {\n    return reconstructPathReversed(bottomLeaf).reverse();\n}\n\n/**\n * Reconstructs the path from a tree, given the bottomLeaf, and\n * returns the shortest path in an array\n * @param bottomLeaf bottom of the tree to start from\n */\nexport function reconstructPathReversed(bottomLeaf: Node) {\n    const path: Tile[] = [];\n    while(bottomLeaf.parent !== null) {\n        path.push(bottomLeaf.tile);\n        bottomLeaf = bottomLeaf.parent;\n    }\n    return path;\n}\n\nexport default Pathfinder;","import {Tile} from '../core/Components';\n\n/**\n * Represents a search Tree Node\n */\nexport class Node\n{\n    parent: Node | null = null; //parent node\n    readonly children: Node[] = [];\n    readonly tile: Tile; //stores a graph node\n\n    constructor(tile: Tile) {\n        this.tile = tile;\n    }\n\n    addChild(child: Node) {\n        child.parent = this;\n        this.children.push(child);\n    }\n}\n\n/**\n * Represents an heuristic weighted aStar search tree node\n */\nexport class AStarNode extends Node\n{\n    readonly g: number; //path cost\n    readonly fScore: number; //heuristic\n\n    constructor(tile: Tile, g: number, fScore: number) {\n        super(tile);\n        this.g = g;\n        this.fScore = fScore;\n    }\n\n    f() {\n        return this.fScore;\n    }\n}\n\n/**\n * Represents an heuristic weighted Best First search tree node\n */\nexport class BestFirstNode extends Node\n{\n    readonly h: number; //heuristic\n\n    constructor(tile: Tile, h: number) {\n        super(tile);\n        this.h = h;\n    }\n}\n\n/**\n * Represents an heuristic weighted Dijkstra tree node\n */\nexport class DijkstraNode extends Node\n{\n    readonly g: number; //path cost\n\n    constructor(tile: Tile, g: number) {\n        super(tile);\n        this.g = g;\n    }\n}\n","/**\n * A compare function to determine if a is 'better' (deserves a higher position) than b\n */\nexport type Comparator<E> = (a: E, b: E) => boolean\n\n/**\n * Minimalist Implementation of the heap data structure as an array\n */\nclass Heap<E>\n{\n    private elements: E[] = [];\n    readonly compare: Comparator<E>;\n\n    constructor(compare: Comparator<E>) {\n        this.compare = compare;\n    }\n\n    /**\n     * Returns the size of the heap\n     */\n    getSize() {\n        return this.elements.length;\n    }\n\n    /**\n     * Checks if heap is empty\n     */\n    isEmpty() {\n        return this.elements.length === 0;\n    }\n\n    /**\n     * Add a new element to the heap\n     * @param e\n     */\n    push(e: E) {\n        this.elements.push(e);\n        this.siftUp(this.elements.length-1); //last element\n    }\n\n    /**\n     * Returns the top of the heap without removing it\n     * Fails if heap is empty\n     */\n    peek() {\n        return this.elements[0];\n    }\n\n    /**\n     * Returns the top of the heap and removes it\n     * Fails if heap is empty\n     */\n    pop() {\n        const val = this.peek();\n        this.move(this.elements.length - 1, 0);\n        this.elements.pop();\n        this.siftDown(0);\n        return val;\n    }\n\n    /**\n     * Clear the heap\n     */\n    clear() {\n        this.elements = [];\n    }\n\n    /**\n     * Sifts a new element that is out of order up to the right position\n     * @param pos of new element\n     */\n    private siftUp(pos: number) {\n        let parent = ((pos - 1) / 2) >> 0; //integer division\n        while(parent >= 0) {\n            //if the current position is better than parent\n            if(this.compare(this.elements[pos], this.elements[parent])) {\n                //then current position with parent and move to next\n                this.swap(pos, parent);\n                pos = parent;\n                parent = ((pos - 1) / 2) >> 0;\n            } else {\n                //otherwise stop\n                parent = -1;\n            }\n        }\n    }\n\n    /**\n     * Sifts a new element that is out of order down to the right position\n     * @param pos of new element\n     */\n    private siftDown(pos: number) {\n        const left = 2 * pos + 1;\n        const right = 2 * pos + 2;\n        //stop if the children are out of bounds\n        if(left >= this.elements.length) {\n            return;\n        }\n        //find the better child\n        const child = (right >= this.elements.length || this.compare(this.elements[left], this.elements[right]))\n            ? left : right;\n        //continues to sift down if the child is better than the current position\n        if(this.compare(this.elements[child], this.elements[pos])) {\n            this.swap(child, pos);\n            this.siftDown(child);\n        }\n    }\n\n    /**\n     * Internal move function\n     * @param from\n     * @param to\n     */\n    private move(from: number, to: number) {\n        this.elements[to] = this.elements[from];\n    }\n\n    /**\n     * Internal swap function\n     * @param a\n     * @param b\n     */\n    private swap(a: number, b: number) {\n        let val = this.elements[a];\n        this.elements[a] = this.elements[b];\n        this.elements[b] = val;\n    }\n}\n\nexport default Heap;","import Pathfinder, {reconstructPath} from './Pathfinder';\nimport {euclidean, HeuristicFunc} from './Heuristics';\nimport {AStarNode} from './Node';\nimport {Point} from '../core/Components';\nimport Navigator from '../core/Navigator';\nimport {HashSet, HashTable, stringify} from '../structures/Hash';\nimport Heap from '../structures/Heap';\n\nclass AStarPathfinder extends Pathfinder\n{\n    private readonly heuristicFunc: HeuristicFunc = (a: Point, b: Point) => euclidean(a,b);\n    private readonly p: number; //tie breaker\n\n    constructor(navigator: Navigator, func?: HeuristicFunc) {\n        super(navigator);\n        const grid = this.getNavigator().getGrid();\n        //minimum cost of taking one step / expected maximum path length\n        this.p = 1/(grid.getWidth() * grid.getHeight());\n        if(func !== undefined) {\n            this.heuristicFunc = func;\n        }\n    }\n\n    getAlgorithmName() {\n        return 'A*';\n    }\n\n    /**\n     * Performs aStar algorithm on the grid given an initial and goal point\n     * Always returns the shortest path, and performs well on larger grids\n     * @param initial\n     * @param goal\n     */\n    findPath(initial: Point, goal: Point) {\n        this.clearRecentSearch();\n        const grid = this.navigator.getGrid();\n        //ranks nodes we haven't yet visited by f-score\n        const openFrontier = new Heap<AStarNode>(\n            (a, b) => a.f() < b.f()\n        );\n        //stores points we have already visited so we don't visit them again\n        const closedSet = new HashSet();\n        //stores the contents of the frontier to allow for fast retrieval of f-score\n        const openSet = new HashTable<number>();\n        //add the root to the frontier and start the algorithm\n        const root = new AStarNode(\n            grid.get(initial), 0, 0\n        );\n        openFrontier.push(root);\n        openSet.add(stringify(initial), root.g);\n        //continues until points have been visited\n        while (!openFrontier.isEmpty()) {\n            const currentNode = openFrontier.pop();\n            const currentPoint = currentNode.tile.point;\n            const currentKey = stringify(currentPoint);\n            openSet.remove(currentKey);\n            //a point may be popped off the frontier again if it was re-evaluated, pre-eval nodes should be ignored\n            if(closedSet.has(currentKey)) {\n                continue;\n            }\n            closedSet.add(currentKey);\n            this.addRecent(currentNode);\n            //check if we're found the solution\n            if (this.navigator.equals(currentPoint, goal)) {\n                return reconstructPath(currentNode);\n            }\n            for (const neighbor of this.navigator.neighbors(currentPoint)) {\n                const neighborPoint = neighbor.point;\n                const neighborKey = stringify(neighborPoint);\n                //point has already been visited\n                if(closedSet.has(neighborKey)) {\n                    continue;\n                }\n                const g = currentNode.g + this.stepCost(currentPoint, neighborPoint);\n                const f = g + this.heuristic(neighborPoint, goal);\n                //re-evaluation: a point that is already in the openSet may be added again if the path to get there was less expensive\n                if (!openSet.has(neighborKey) || g < openSet.get(neighborKey)!) {\n                    const neighborNode = new AStarNode(\n                        neighbor, g, f\n                    );\n                    currentNode.addChild(neighborNode);\n                    openFrontier.push(neighborNode);\n                    openSet.add(neighborKey, neighborNode.g);\n                }\n            }\n        }\n        //checked all possible paths: no solution was found\n        return [];\n    }\n\n    /**\n     * Heuristic function used to estimate distance between points a and b\n     * Includes tie breaker to prevent exploring lots of identical paths\n     * @param a\n     * @param b\n     */\n    heuristic(a: Point, b: Point) {\n        return this.heuristicFunc(a, b) * (1 + this.p);\n    }\n\n    /**\n     * The step-cost function to be used, calculating the cost from\n     * currentPoint to neighborPoint. Uses the stepCost function provided by the\n     * navigator by default but can be overridden\n     * @param currentPoint\n     * @param neighborPoint\n     */\n    stepCost(currentPoint: Point, neighborPoint: Point) {\n        return this.navigator.cost(currentPoint, neighborPoint);\n    }\n}\n\nexport default AStarPathfinder;","import Pathfinder, {reconstructPath} from './Pathfinder';\nimport {Node} from './Node';\nimport {Point} from '../core/Components';\nimport {HashSet, stringify} from '../structures/Hash';\n\nclass BFSPathfinder extends Pathfinder\n{\n    getAlgorithmName() {\n        return 'Breadth First Search';\n    }\n\n    /**\n     * Implementation of BFS to find the shortest path from initial to point\n     * Doesn't always return the shortest path, and performs poorly on larger grids\n     * @param initial\n     * @param goal\n     */\n    findPath(initial: Point, goal: Point) {\n        this.clearRecentSearch();\n        const grid = this.navigator.getGrid();\n        //fifo queue to store points we haven't yet visited\n        const frontier: Node[] = [];\n        //stores points we have already visited + points on frontier so we don't visit them more than once\n        const visited = new HashSet();\n        //add the root to the frontier and start the algorithm\n        const root = new Node(grid.get(initial));\n        frontier.push(root); //enqueue\n        visited.add(stringify(initial));\n        //continues until points have been visited\n        while(frontier.length !== 0) { //not empty\n            const currentNode = frontier.shift()!; //dequeue\n            const currentPoint = currentNode.tile.point;\n            this.addRecent(currentNode);\n            //check if we're found the solution\n            if(this.navigator.equals(currentPoint, goal)) {\n                return reconstructPath(currentNode);\n            }\n            for(const neighbor of this.navigator.neighbors(currentPoint)) {\n                const neighborKey = stringify(neighbor.point);\n                //point hasn't been visited, we can add it to frontier\n                if(!visited.has(neighborKey)) {\n                    const neighborNode = new Node(neighbor);\n                    currentNode.addChild(neighborNode);\n                    frontier.push(neighborNode); //enqueue\n                    visited.add(neighborKey);\n                }\n            }\n        }\n        //checked all possible paths: no solution was found\n        return [];\n    }\n}\n\nexport default BFSPathfinder;","/**\n * Stack node\n */\nclass Node<E>\n{\n    next: Node<E> | null = null;\n    data: E;\n\n    constructor(data: E) {\n        this.data = data;\n    }\n}\n\n/**\n * Minimalist Implementation of the stack data structure\n */\nclass Stack<E>\n{\n    private top: Node<E> | null = null;\n    private size: number = 0;\n\n    peek() {\n        return this.top != null ? this.top.data : undefined;\n    }\n\n    push(e: E) {\n        const node = new Node(e);\n        node.next = this.top;\n        this.top = node;\n        this.size++;\n    }\n\n    pop() {\n        const top = this.peek();\n        if(this.top != null) {\n            this.top = this.top.next;\n            this.size--;\n        }\n        return top;\n    }\n\n    isEmpty() {\n        return this.size === 0;\n    }\n\n    getSize() {\n        return this.size;\n    }\n}\n\nexport default Stack;","import Pathfinder, {reconstructPath} from './Pathfinder';\nimport {Node} from './Node';\nimport {Point} from '../core/Components';\nimport {HashSet, stringify} from '../structures/Hash';\nimport Stack from '../structures/Stack';\n\nclass DFSPathfinder extends Pathfinder\n{\n    getAlgorithmName() {\n        return 'Depth First Search';\n    }\n\n    /**\n     * Calls DFS between a start and goal point, will typically not find the 'Best' path,\n     * and will instead find the best path capable for the algorithm\n     * As this algorithm is non optimal it should only be used for educational purposes\n     * @param initial\n     * @param goal\n     */\n    findPath(initial: Point, goal: Point) {\n        this.clearRecentSearch();\n        const grid = this.navigator.getGrid();\n        const root = new Node(grid.get(initial));\n        //lifo stack as control structure for frontier\n        const frontier = new Stack<Node>();\n        //stores points we have already visited so we don't visit them again\n        const visited = new HashSet();\n        //add the root to the frontier and start the algorithm\n        frontier.push(root);\n        while(!frontier.isEmpty()) {\n            const currentNode = frontier.pop()!;\n            const currentPoint = currentNode.tile.point;\n            visited.add(stringify(currentPoint));\n            this.addRecent(currentNode);\n            //check if we're found the solution\n            if(this.navigator.equals(currentPoint, goal)) {\n                return reconstructPath(currentNode);\n            }\n            //neighbors are added in reverse order for a more coherent visualization\n            for(const neighbor of this.navigator.neighbors(currentPoint).reverse()) {\n                const neighborKey = stringify(neighbor.point);\n                //point hasn't been visited, we can add it to frontier\n                if(!visited.has(neighborKey)) {\n                    const neighborNode = new Node(neighbor);\n                    currentNode.addChild(neighborNode);\n                    frontier.push(neighborNode);\n                }\n            }\n        }\n        //checked all possible paths: no solution was found\n        return [];\n    }\n}\n\nexport default DFSPathfinder;\n","import Pathfinder, {reconstructPath, reconstructPathReversed} from './Pathfinder';\nimport {euclidean, HeuristicFunc} from './Heuristics';\nimport {AStarNode} from './Node';\nimport {Point} from '../core/Components';\nimport Navigator from '../core/Navigator';\nimport {HashSet, HashTable, stringify} from '../structures/Hash';\nimport Heap from '../structures/Heap';\n\ninterface ControlStructures {\n    openSet: HashTable<AStarNode>,\n    closedSet: HashSet,\n    openFrontier: Heap<AStarNode>\n}\n\nclass BiAStarPathfinder extends Pathfinder\n{\n    private readonly heuristic: HeuristicFunc = (a: Point, b: Point) => euclidean(a,b);\n\n    constructor(navigator: Navigator, func?: HeuristicFunc) {\n        super(navigator);\n        if(func !== undefined) {\n            this.heuristic = func;\n        }\n    }\n\n    getAlgorithmName() {\n        return 'Bidirectional A*';\n    }\n\n    /**\n     * Performs Bidirectional AStar algorithm on the grid given an initial and goal point\n     *  One frontier is expanded starting from initial node until it reaches goal frontier\n     *  Other frontier is expanded starting from goal node until it reaches initial frontier\n     * Doesn't always returns the shortest path, but performs well on larger grids\n     * @param initial\n     * @param goal\n     */\n    findPath(initial: Point, goal: Point) {\n        this.clearRecentSearch();\n        const grid = this.navigator.getGrid();\n        //stores points we have already visited (from either direction) so we don't visit them again\n        const closedSet = new HashSet();\n        //ranks nodes starting from initial point we haven't yet visited by f-score\n        const startOpenFrontier = new Heap<AStarNode>(\n            (a, b) => a.f() < b.f()\n        );\n        //stores the contents of the frontier starting from initial point to allow for fast retrieval of node (for f-score and reconstruction)\n        const startOpenSet = new HashTable<AStarNode>();\n        //ranks nodes starting from goal point we haven't yet visited by f-score\n        const endOpenFrontier = new Heap<AStarNode>(\n            (a, b) => a.f() < b.f()\n        );\n        //stores the contents of the frontier starting from goal point to allow for fast retrieval of node (for f-score and reconstruction)\n        const endOpenSet = new HashTable<AStarNode>();\n        //add the root to both frontiers and start the algorithm from both directions\n        const initialRoot = new AStarNode(\n            grid.get(initial), 0, 0\n        );\n        startOpenFrontier.push(initialRoot);\n        startOpenSet.add(stringify(initial), initialRoot);\n        const goalRoot = new AStarNode(\n            grid.get(goal), 0, 0\n        );\n        endOpenFrontier.push(goalRoot);\n        endOpenSet.add(stringify(goal), goalRoot);\n        //continues until points have been visited\n        while (!startOpenFrontier.isEmpty() && !endOpenFrontier.isEmpty()) {\n            //expand startOpenFrontier\n            const startCurrentNode = startOpenFrontier.pop();\n            const startCurrentPoint = startCurrentNode.tile.point;\n            const startCurrentPointKey = stringify(startCurrentPoint);\n            startOpenSet.remove(startCurrentPointKey);\n            //a point may be popped off the frontier again if it was re-evaluated, pre-eval nodes should be ignored\n            if(closedSet.has(startCurrentPointKey)) {\n                continue;\n            }\n            closedSet.add(startCurrentPointKey);\n            this.addRecent(startCurrentNode);\n            //check if the end frontier and the start frontier have collided\n            if(endOpenSet.has(startCurrentPointKey)) {\n                if(startCurrentNode.parent != null) {\n                    //path from start to collision + path from collision to goal\n                    //path from goal to collision needs to be reversed (wrong direction)\n                    return reconstructPath(\n                        startCurrentNode.parent!\n                    ).concat(reconstructPathReversed(\n                        endOpenSet.get(startCurrentPointKey)!\n                    )).concat(\n                        grid.get(goal) //must be added because goal is excluded from reconstructReversed algorithm\n                    );\n                } else {\n                    //node has no parent, initial and goal nodes are neighbors\n                    return [grid.get(goal)];\n                }\n            }\n            this.doAStarExpansion({\n                openFrontier: startOpenFrontier,\n                openSet: startOpenSet,\n                closedSet: closedSet\n            }, startCurrentNode, goal);\n            //expand endOpenFrontier\n            const endCurrentNode = endOpenFrontier.pop();\n            const endCurrentPoint = endCurrentNode.tile.point;\n            const endCurrentPointKey = stringify(endCurrentPoint);\n            endOpenSet.remove(endCurrentPointKey);\n            //a point may be popped off the frontier again if it was re-evaluated, pre-eval nodes should be ignored\n            if(closedSet.has(endCurrentPointKey)) {\n                continue;\n            }\n            closedSet.add(endCurrentPointKey);\n            this.addRecent(endCurrentNode);\n            //check if the end frontier and the start frontier have collided\n            if(startOpenSet.has(endCurrentPointKey)) {\n                if(endCurrentNode.parent != null) {\n                    //path from start to collision + path from collision to goal\n                    //path from goal to collision needs to be reversed (wrong direction)\n                    return reconstructPath(\n                        startOpenSet.get(endCurrentPointKey)!\n                    ).concat(reconstructPathReversed(\n                        endCurrentNode.parent!\n                    )).concat(\n                        grid.get(goal) //must be added because goal is excluded from reconstructReversed algorithm\n                    );\n                } else {\n                    //node has no parent, initial and goal nodes are neighbors\n                    return [grid.get(goal)];\n                }\n            }\n            this.doAStarExpansion({\n                openFrontier: endOpenFrontier,\n                openSet: endOpenSet,\n                closedSet: closedSet\n            }, endCurrentNode, initial);\n        }\n        //checked all possible paths: no solution was found\n        return [];\n    }\n\n    /**\n     * Implementation of AStar expansion algorithm for the bidirectional AStar algorithm\n     * @param structures\n     * @param currentNode\n     * @param endPoint\n     * @private\n     */\n    private doAStarExpansion(structures: ControlStructures, currentNode: AStarNode, endPoint: Point) {\n        const currentPoint = currentNode.tile.point;\n        for (const neighbor of this.navigator.neighbors(currentPoint)) {\n            const neighborPoint = neighbor.point;\n            const neighborKey = stringify(neighborPoint);\n            //point has already been visited\n            if(structures.closedSet.has(neighborKey)) {\n                continue;\n            }\n            const g = currentNode.g + this.stepCost(currentPoint, neighborPoint);\n            const f = g + this.heuristic(neighborPoint, endPoint);\n            //re-evaluation: a point that is already in the openSet may be added again if the path to get there was less expensive\n            if (!structures.openSet.has(neighborKey) || g < structures.openSet.get(neighborKey)!.g) {\n                const neighborNode = new AStarNode(\n                    neighbor, g, f\n                );\n                currentNode.addChild(neighborNode);\n                structures.openFrontier.push(neighborNode);\n                structures.openSet.add(neighborKey, neighborNode);\n            }\n        }\n    }\n\n    /**\n     * The step-cost function to be used, calculating the cost from\n     * currentPoint to neighborPoint. Uses the stepCost function provided by the\n     * navigator by default but can be overridden\n     * @param currentPoint\n     * @param neighborPoint\n     */\n    stepCost(currentPoint: Point, neighborPoint: Point) {\n        return this.navigator.cost(currentPoint, neighborPoint);\n    }\n}\n\nexport default BiAStarPathfinder;","import Pathfinder, {reconstructPath, reconstructPathReversed} from './Pathfinder';\nimport {Node} from './Node';\nimport {Point} from '../core/Components';\nimport {HashTable, stringify} from '../structures/Hash';\n\ninterface ControlStructures {\n    frontier: Node[],\n    visited: HashTable<Node>\n}\n\nclass BiBFSPathfinder extends Pathfinder\n{\n    getAlgorithmName() {\n        return 'Bidirectional Breadth First Search';\n    }\n\n    /**\n     * Implementation of Bidirectional BFS to find the shortest path from initial to point\n     *  One frontier is expanded starting from initial node until it reaches goal frontier\n     *  Other frontier is expanded starting from goal node until it reaches initial frontier\n     * Doesn't always return the shortest path, and performs poorly on larger grids\n     * @param initial\n     * @param goal\n     */\n    findPath(initial: Point, goal: Point) {\n        this.clearRecentSearch();\n        const grid = this.navigator.getGrid();\n        //store the nodes visited from start direction + nodes on the start frontier, allows for fast retrieval of node (for reconstruction)\n        const startVisited = new HashTable<Node>();\n        //store the nodes visited from end direction + nodes on the end frontier, allows for fast retrieval of node (for reconstruction)\n        const endVisited = new HashTable<Node>();\n        //fifo queue starting from initial point to store points we haven't yet visited\n        const startFrontier: Node[] = [];\n        //fifo queue starting from goal point to store points we haven't yet visited\n        const endFrontier: Node[] = [];\n        //add the root to both frontiers and start the algorithm from both directions\n        const initialRoot = new Node(grid.get(initial));\n        startFrontier.push(initialRoot);\n        startVisited.add(stringify(initial), initialRoot);\n        const goalRoot = new Node(grid.get(goal));\n        endFrontier.push(goalRoot);\n        endVisited.add(stringify(goal), goalRoot);\n        //continues until points have been visited\n        while(startFrontier.length !== 0 && endFrontier.length !== 0) {\n            //expand startQueue\n            const startCurrentNode = startFrontier.shift()!;\n            const startCurrentPoint = startCurrentNode.tile.point;\n            const startCurrentPointKey = stringify(startCurrentPoint);\n            this.addRecent(startCurrentNode);\n            //check if the end frontier and the start frontier have collided\n            if(endVisited.has(startCurrentPointKey)) {\n                //path from start to collision + path from collision to goal\n                //path from goal to collision needs to be reversed (wrong direction)\n                if(startCurrentNode.parent != null) {\n                    return reconstructPath(\n                        startCurrentNode.parent\n                    ).concat(reconstructPathReversed(\n                        endVisited.get(startCurrentPointKey)!\n                    )).concat(\n                        grid.get(goal) //must be added because goal is excluded from reconstructReversed algorithm\n                    );\n                } else {\n                    return [grid.get(goal)];\n                }\n            }\n            this.doBFSExpansion({\n                frontier: startFrontier,\n                visited: startVisited\n            }, startCurrentNode);\n            //expand endQueue\n            const endCurrentNode = endFrontier.shift()!;\n            const endCurrentPoint = endCurrentNode.tile.point;\n            const endCurrentPointKey = stringify(endCurrentPoint);\n            this.addRecent(endCurrentNode);\n            //check if the end frontier and the start frontier have collided\n            if(startVisited.has(endCurrentPointKey)) {\n                //path from start to collision + path from collision to goal\n                //path from goal to collision needs to be reversed (wrong direction)\n                if(endCurrentNode.parent != null) {\n                    return reconstructPath(\n                        startVisited.get(endCurrentPointKey)!\n                    ).concat(reconstructPathReversed(\n                        endCurrentNode.parent\n                    )).concat(\n                        grid.get(goal) //must be added because goal is excluded from reconstructReversed algorithm\n                    );\n                } else {\n                    return [grid.get(goal)];\n                }\n            }\n            this.doBFSExpansion({\n                frontier: endFrontier,\n                visited: endVisited\n            }, endCurrentNode);\n        }\n        return [];\n    }\n\n    private doBFSExpansion(structures: ControlStructures, currentNode: Node) {\n        const currentPoint = currentNode.tile.point;\n        for(const neighbor of this.navigator.neighbors(currentPoint)) {\n            const neighborKey = stringify(neighbor.point);\n            //point hasn't been visited, we can add it to frontier\n            if(!structures.visited.has(neighborKey)) {\n                const neighborNode = new Node(neighbor);\n                currentNode.addChild(neighborNode);\n                structures.frontier.push(neighborNode);\n                structures.visited.add(neighborKey, neighborNode);\n            }\n        }\n    }\n}\n\nexport default BiBFSPathfinder;","import Pathfinder, {reconstructPath} from './Pathfinder';\r\nimport {euclidean, HeuristicFunc} from './Heuristics';\r\nimport {BestFirstNode} from './Node';\r\nimport {Point} from '../core/Components';\r\nimport Navigator from '../core/Navigator';\r\nimport {HashSet, stringify} from '../structures/Hash';\r\nimport Heap from '../structures/Heap';\r\n\r\nclass BestFirstPathfinder extends Pathfinder\r\n{\r\n    private readonly heuristicFunc: HeuristicFunc = (a: Point, b: Point) => euclidean(a,b);\r\n\r\n    constructor(navigator: Navigator, func?: HeuristicFunc) {\r\n        super(navigator);\r\n        if(func !== undefined) {\r\n            this.heuristicFunc = func;\r\n        }\r\n    }\r\n\r\n    getAlgorithmName() {\r\n        return 'Best-First Search';\r\n    }\r\n\r\n    /**\r\n     * Performs best first search algorithm on the grid given an initial and goal point\r\n     *  Similar to the implementation of AStar, but with a null step cost function\r\n     *  Includes best first search specific optimizations\r\n     * Always returns the shortest path, and performs well on larger grids\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point) {\r\n        this.clearRecentSearch();\r\n        const grid = this.navigator.getGrid();\r\n        //ranks points we haven't yet visited by heuristic\r\n        const frontier = new Heap<BestFirstNode>(\r\n            (a, b) => a.h < b.h\r\n        );\r\n        //stores points we have already visited so we don't visit them again\r\n        const closedSet = new HashSet();\r\n        //add the root to the frontier and start the algorithm\r\n        const root = new BestFirstNode(\r\n            grid.get(initial), 0\r\n        );\r\n        frontier.push(root);\r\n        closedSet.add(stringify(initial));\r\n        //continues until points have been visited\r\n        while (!frontier.isEmpty()) {\r\n            const currentNode = frontier.pop();\r\n            const currentPoint = currentNode.tile.point;\r\n            this.addRecent(currentNode);\r\n            //check if we're found the solution\r\n            if (this.navigator.equals(currentPoint, goal)) {\r\n                return reconstructPath(currentNode);\r\n            }\r\n            for (const neighbor of this.navigator.neighbors(currentPoint)) {\r\n                const neighborPoint = neighbor.point;\r\n                const neighborKey = stringify(neighborPoint);\r\n                const h = this.heuristic(neighborPoint, goal);\r\n                //point hasn't been visited, we can add it to frontier\r\n                if (!closedSet.has(neighborKey)) {\r\n                    const neighborNode = new BestFirstNode(\r\n                        neighbor, h\r\n                    );\r\n                    currentNode.addChild(neighborNode);\r\n                    frontier.push(neighborNode);\r\n                    closedSet.add(neighborKey);\r\n                }\r\n            }\r\n        }\r\n        //checked all possible paths: no solution was found\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Heuristic function used to estimate distance between points a and b\r\n     * @param a\r\n     * @param b\r\n     */\r\n    heuristic(a: Point, b: Point) {\r\n        return this.heuristicFunc(a, b);\r\n    }\r\n}\r\n\r\nexport default BestFirstPathfinder;","import Pathfinder, {reconstructPath} from './Pathfinder';\r\nimport {DijkstraNode} from './Node';\r\nimport {Point} from '../core/Components';\r\nimport {HashSet, stringify} from '../structures/Hash';\r\nimport Heap from '../structures/Heap';\r\n\r\nclass DijkstraPathfinder extends Pathfinder\r\n{\r\n    getAlgorithmName() {\r\n        return 'Dijkstra';\r\n    }\r\n\r\n    /**\r\n     * Performs dijkstra's algorithm on the grid given an initial and goal point\r\n     *  Similar to the implementation of AStar, but with a null heuristic function\r\n     *  Includes dijkstra specific optimizations\r\n     * Always returns the shortest path, and performs poorly on larger grids\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point) {\r\n        this.clearRecentSearch();\r\n        const grid = this.navigator.getGrid();\r\n        //ranks points we haven't yet visited by path cost\r\n        const frontier = new Heap<DijkstraNode>(\r\n            (a, b) => a.g < b.g\r\n        );\r\n        //stores points we have already visited so we don't visit them again\r\n        const closedSet = new HashSet();\r\n        //add the root to the frontier and start the algorithm\r\n        const root = new DijkstraNode(\r\n            grid.get(initial), 0\r\n        );\r\n        frontier.push(root);\r\n        closedSet.add(stringify(initial));\r\n        //continues until points have been visited\r\n        while (!frontier.isEmpty()) {\r\n            const currentNode = frontier.pop();\r\n            const currentPoint = currentNode.tile.point;\r\n            this.addRecent(currentNode);\r\n            //check if we're found the solution\r\n            if (this.navigator.equals(currentPoint, goal)) {\r\n                return reconstructPath(currentNode);\r\n            }\r\n            for (const neighbor of this.navigator.neighbors(currentPoint)) {\r\n                const neighborPoint = neighbor.point;\r\n                const neighborKey = stringify(neighborPoint);\r\n                const g = currentNode.g + this.stepCost(currentPoint, neighborPoint);\r\n                //point hasn't been visited, we can add it to frontier\r\n                if (!closedSet.has(neighborKey)) {\r\n                    const neighborNode = new DijkstraNode(\r\n                        neighbor, g\r\n                    );\r\n                    currentNode.addChild(neighborNode);\r\n                    frontier.push(neighborNode);\r\n                    closedSet.add(neighborKey);\r\n                }\r\n            }\r\n        }\r\n        //checked all possible paths: no solution was found\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * The step-cost function to be used, calculating the cost from\r\n     * currentPoint to neighborPoint. Uses the stepCost function provided by the\r\n     * navigator by default but can be overridden\r\n     * @param currentPoint\r\n     * @param neighborPoint\r\n     */\r\n    stepCost(currentPoint: Point, neighborPoint: Point) {\r\n        return this.navigator.cost(currentPoint, neighborPoint);\r\n    }\r\n}\r\n\r\nexport default DijkstraPathfinder;","import Pathfinder, {reconstructPath, reconstructPathReversed} from './Pathfinder';\r\nimport {DijkstraNode} from './Node';\r\nimport {Point} from '../core/Components';\r\nimport {HashTable, stringify} from '../structures/Hash';\r\nimport Heap from '../structures/Heap';\r\n\r\ninterface ControlStructures {\r\n    frontier: Heap<DijkstraNode>,\r\n    closedSet: HashTable<DijkstraNode>\r\n}\r\n\r\nclass BiDijkstraPathfinder extends Pathfinder\r\n{\r\n    getAlgorithmName() {\r\n        return 'Bidirectional Dijkstra';\r\n    }\r\n\r\n    /**\r\n     * Implementation of Bidirectional Dijkstra to find the shortest path from initial to point\r\n     *  One frontier is expanded starting from initial node until it reaches goal frontier\r\n     *  Other frontier is expanded starting from goal node until it reaches initial frontier\r\n     * Always returns the shortest path, and performs poorly on larger grids\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point) {\r\n        this.clearRecentSearch();\r\n        const grid = this.navigator.getGrid();\r\n        //store the nodes visited from start direction + nodes on the start frontier, allows for fast retrieval of node (for reconstruction)\r\n        const startVisited = new HashTable<DijkstraNode>();\r\n        //store the nodes visited from end direction + nodes on the end frontier, allows for fast retrieval of node (for reconstruction)\r\n        const endVisited = new HashTable<DijkstraNode>();\r\n        //ranks nodes starting from initial point we haven't yet visited by path cost\r\n        const startFrontier = new Heap<DijkstraNode>(\r\n            (a, b) => a.g < b.g\r\n        );\r\n        //ranks nodes starting from goal point we haven't yet visited by path cost\r\n        const endFrontier = new Heap<DijkstraNode>(\r\n            (a, b) => a.g < b.g\r\n        );\r\n        //add the root to both frontiers and start the algorithm from both directions\r\n        const initialRoot = new DijkstraNode(\r\n            grid.get(initial), 0\r\n        );\r\n        startFrontier.push(initialRoot);\r\n        startVisited.add(stringify(initial), initialRoot);\r\n        const goalRoot = new DijkstraNode(\r\n            grid.get(goal), 0\r\n        );\r\n        endFrontier.push(goalRoot);\r\n        endVisited.add(stringify(goal), goalRoot);\r\n        //continues until points have been visited\r\n        while(!startFrontier.isEmpty() && !endFrontier.isEmpty()) {\r\n            //expand startFrontier\r\n            const startCurrentNode = startFrontier.pop();\r\n            const startCurrentPoint = startCurrentNode.tile.point;\r\n            const startCurrentPointKey = stringify(startCurrentPoint);\r\n            this.addRecent(startCurrentNode);\r\n            //check if the end frontier and the start frontier have collided\r\n            if(endVisited.has(startCurrentPointKey)) {\r\n                //path from start to collision + path from collision to goal\r\n                //path from goal to collision needs to be reversed (wrong direction)\r\n                if(startCurrentNode.parent != null) {\r\n                    return reconstructPath(\r\n                        startCurrentNode.parent\r\n                    ).concat(reconstructPathReversed(\r\n                        endVisited.get(startCurrentPointKey)!\r\n                    )).concat(\r\n                        grid.get(goal) //must be added because goal is excluded from reconstructReversed algorithm\r\n                    );\r\n                } else {\r\n                    return [grid.get(goal)];\r\n                }\r\n            }\r\n            this.doDijkstraExpansion({\r\n                frontier: startFrontier,\r\n                closedSet: startVisited\r\n            }, startCurrentNode);\r\n            //expand endFrontier\r\n            const endCurrentNode = endFrontier.pop();\r\n            const endCurrentPoint = endCurrentNode.tile.point;\r\n            const endCurrentPointKey = stringify(endCurrentPoint);\r\n            this.addRecent(endCurrentNode);\r\n            //check if the end frontier and the start frontier have collided\r\n            if(startVisited.has(endCurrentPointKey)) {\r\n                //path from start to collision + path from collision to goal\r\n                //path from goal to collision needs to be reversed (wrong direction)\r\n                if(endCurrentNode.parent != null) {\r\n                    return reconstructPath(\r\n                        startVisited.get(endCurrentPointKey)!\r\n                    ).concat(reconstructPathReversed(\r\n                        endCurrentNode.parent\r\n                    )).concat(\r\n                        grid.get(goal) //must be added because goal is excluded from reconstructReversed algorithm\r\n                    );\r\n                } else {\r\n                    return [grid.get(goal)];\r\n                }\r\n            }\r\n            this.doDijkstraExpansion({\r\n                frontier: endFrontier,\r\n                closedSet: endVisited\r\n            }, endCurrentNode);\r\n        }\r\n        return [];\r\n    }\r\n\r\n    private doDijkstraExpansion(structures: ControlStructures, currentNode: DijkstraNode) {\r\n        const currentPoint = currentNode.tile.point;\r\n        for (const neighbor of this.navigator.neighbors(currentPoint)) {\r\n            const neighborPoint = neighbor.point;\r\n            const neighborKey = stringify(neighborPoint);\r\n            const g = currentNode.g + this.stepCost(currentPoint, neighborPoint);\r\n            //point hasn't been visited, we can add it to frontier\r\n            if (!structures.closedSet.has(neighborKey)) {\r\n                const neighborNode = new DijkstraNode(\r\n                    neighbor, g\r\n                );\r\n                currentNode.addChild(neighborNode);\r\n                structures.frontier.push(neighborNode);\r\n                structures.closedSet.add(neighborKey, neighborNode);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The step-cost function to be used, calculating the cost from\r\n     * currentPoint to neighborPoint. Uses the stepCost function provided by the\r\n     * navigator by default but can be overridden\r\n     * @param currentPoint\r\n     * @param neighborPoint\r\n     */\r\n    stepCost(currentPoint: Point, neighborPoint: Point) {\r\n        return this.navigator.cost(currentPoint, neighborPoint);\r\n    }\r\n}\r\n\r\nexport default BiDijkstraPathfinder;","import Navigator from '../core/Navigator';\nimport PlusNavigator from '../core/PlusNavigator';\nimport {Grid} from '../core/Grid';\nimport {\n    chebyshev,\n    euclidean,\n    HeuristicFunc,\n    manhattan,\n    nullHeuristic,\n    octile\n} from '../algorithms/Heuristics';\nimport Pathfinder from '../algorithms/Pathfinder';\nimport AStarPathfinder from '../algorithms/AStarPathfinder';\nimport BFSPathfinder from '../algorithms/BFSPathfinder';\nimport DFSPathfinder from '../algorithms/DFSPathfinder';\nimport BiAStarPathfinder from '../algorithms/BiAStarPathfinder';\nimport BiBFSPathfinder from \"../algorithms/BiBFSPathfinder\";\nimport BestFirstPathfinder from '../algorithms/BestFirstPathfinder';\nimport DijkstraPathfinder from '../algorithms/DijkstraPathfinder';\nimport BiDijkstraPathfinder from '../algorithms/BiDijkstraPathfinder';\n\nconst CREATE_NAVIGATOR: {[key: string]: ((grid: Grid) => Navigator)} = {\n    'plus': (grid: Grid) => new PlusNavigator(grid),\n}\n\nconst CREATE_HEURISTIC: {[key: string]: (() => HeuristicFunc)} = {\n    'manhattan': () => manhattan,\n    'euclidean': () => euclidean,\n    'chebyshev': () => chebyshev,\n    'octile': () => octile,\n    'null': () => nullHeuristic\n}\n\nconst CREATE_PATHFINDER: {[key: string]: ((navigator: Navigator, heuristic: HeuristicFunc) => Pathfinder)} = {\n    'dijkstra': (navigator) => new DijkstraPathfinder(navigator),\n    'best-first': (navigator, heuristic) => new BestFirstPathfinder(navigator, heuristic),\n    'a*': (navigator, heuristic) => new AStarPathfinder(navigator, heuristic),\n    'bfs': (navigator) => new BFSPathfinder(navigator),\n    'dfs': (navigator) => new DFSPathfinder(navigator),\n    'bi-a*': (navigator, heuristic) => new BiAStarPathfinder(navigator, heuristic),\n    'bi-dijkstra': (navigator) => new BiDijkstraPathfinder(navigator),\n    'bi-bfs': (navigator) => new BiBFSPathfinder(navigator)\n}\n\nclass PathfinderBuilder\n{\n    private navigator: string = 'plus';\n    private algorithm: string = 'a*';\n    private heuristic: string = 'null';\n    private readonly grid: Readonly<Grid>;\n\n    constructor(grid: Readonly<Grid>) {\n        this.grid = grid;\n    }\n\n    setNavigator(navigator: string) {\n        navigator = navigator.toLowerCase();\n        if(CREATE_NAVIGATOR[navigator] == null) {\n            throw new Error('No such navigator pattern exists')\n        } else {\n            this.navigator = navigator;\n        }\n        return this;\n    }\n\n    setAlgorithm(algorithm: string) {\n        algorithm = algorithm.toLowerCase();\n        if(CREATE_PATHFINDER[algorithm] == null) {\n            throw new Error('No such pathfinding algorithm exists')\n        } else {\n            this.algorithm = algorithm;\n        }\n        return this;\n    }\n\n    setHeuristic(heuristic: string) {\n        heuristic = heuristic.toLowerCase();\n        if(CREATE_HEURISTIC[heuristic] == null) {\n            throw new Error('No such heuristic function exists')\n        } else {\n            this.heuristic = heuristic;\n        }\n        return this;\n    }\n\n    /**\n     * Builds a pathfinder with a navigator with the set algorithm, heuristic, and navigator\n     */\n    build() {\n        const createHeuristic = CREATE_HEURISTIC[this.heuristic];\n        const createNavigator = CREATE_NAVIGATOR[this.navigator];\n        const createPathfinder = CREATE_PATHFINDER[this.algorithm];\n        return createPathfinder(createNavigator(this.grid), createHeuristic());\n    }\n\n    static usesHeuristic(algorithm: string) {\n        return algorithm === 'a*' || algorithm === 'bi-a*' ||\n            algorithm === 'best-first';\n    }\n\n    static usesWeights(algorithm: string) {\n        return algorithm === 'a*' || algorithm === 'bi-a*' ||\n            algorithm === 'best-first' || algorithm === 'dijkstra' ||\n            algorithm === 'bi-dijkstra';\n    }\n\n    static hasBidirectional(algorithm: string) {\n        return CREATE_PATHFINDER['bi-' + algorithm] != null;\n    }\n\n    static makeBidirectional(algorithm: string) {\n        return 'bi-' + algorithm;\n    }\n}\n\nexport default PathfinderBuilder;\n\n","import {createTileData, Point, Tile, TileData} from '../core/Components';\nimport {Grid} from '../core/Grid';\nimport {HashSet, stringify} from '../structures/Hash';\n\nabstract class TerrainGenerator\n{\n    protected readonly width: number;\n    protected readonly height: number;\n    protected readonly ignore: HashSet;\n    protected readonly data: TileData;\n\n    protected constructor(width: number, height: number, data?: TileData, ignore?: Point[]) {\n        this.width = width;\n        this.height = height;\n        this.ignore = new HashSet();\n        if(data !== undefined) {\n            this.data = data;\n        } else {\n            this.data = createTileData(true);\n        }\n        if(ignore !== undefined) {\n            for(const i of ignore) {\n                this.ignore.add(stringify(i));\n            }\n        }\n    }\n\n    /**\n     * Draws a tile to the grid\n     * @param grid\n     * @param tile\n     */\n    protected draw(grid: Grid, tile: Tile) {\n        if(!this.shouldIgnore(tile.point)) {\n            grid.mutateTile(tile);\n        }\n    }\n\n    protected getTerrain() {\n        return this.data;\n    }\n\n    protected getSolid() {\n        return {\n            pathCost: 1,\n            isSolid: true\n        }\n    }\n\n    protected shouldIgnore(point: Point) {\n        return this.ignore.has(stringify(point));\n    }\n\n    abstract generateTerrain(topLeft?: Point, bottomRight?: Point): Grid;\n}\n\nexport default TerrainGenerator;","import TerrainGenerator from './TerrainGenerator';\nimport {Point, TileData} from '../core/Components';\nimport RectGrid from '../core/Grid';\n\nclass TerrainRandomGenerator extends TerrainGenerator\n{\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n    constructor(width: number, height: number, tileData?: TileData, ignore?: Point[]) {\n        super(width, height, tileData, ignore);\n    }\n\n    /**\n     * Performs a random terrain generation algorithm where each tile has a 1/4\n     * chance of being solid\n     * @param topLeft optional parameter to specify what point the terrain should start from\n     *  This should not be further up/left than (1,1)\n     * @param bottomRight optional parameter to specify how far down and right the terrain will go\n     *  This should not be further right/down than (width-2,height-2)\n     */\n    generateTerrain(topLeft?: Point, bottomRight?: Point) {\n        const grid = new RectGrid(this.width, this.height);\n        if(topLeft === undefined) {\n            topLeft = {\n                x: 1, y: 1\n            }\n        }\n        if(bottomRight === undefined) {\n            bottomRight = {\n                x: grid.getWidth()-2,\n                y: grid.getHeight()-2\n            }\n        }\n        for(let x = topLeft.x - 1; x <= bottomRight.x + 1; x++) {\n            for(let y = topLeft.y - 1; y <= bottomRight.y + 1; y++) {\n                if(getRand(0, 3) === 0) {\n                    this.draw(grid,{\n                        point: {\n                            x: x, y: y\n                        },\n                        data: this.getTerrain()\n                    });\n                }\n            }\n        }\n        return grid;\n    }\n}\n\n/**\n * Generate a random number between min and max, inclusive for min and max\n * @param min\n * @param max\n */\nfunction getRand(min: number, max: number) {\n    return Math.floor(Math.random() * (max+1-min) + min);\n}\n\nexport default TerrainRandomGenerator;","import TerrainGenerator from './TerrainGenerator';\nimport RectGrid, {Grid} from '../core/Grid';\nimport {createTileData, Point, Tile, TileData} from '../core/Components';\n\nconst LIMIT = 2;\n\nexport const NO_SKEW = 0;\nexport const VERTICAL_SKEW = 1;\nexport const HORIZONTAL_SKEW = 2;\n\ninterface Chamber {\n    topLeft: Point; //min\n    bottomRight: Point; //max\n}\n\nclass TerrainMazeGenerator extends TerrainGenerator\n{\n    private readonly divideWidth: (width: number, height: number) => boolean;\n\n    constructor(width: number, height: number, tileData?: TileData, ignore?: Point[], slant?: number) {\n        super(width, height, tileData, ignore);\n        if(slant === undefined || slant === NO_SKEW) {\n            this.divideWidth = divideWidthNoSkew;\n        } else if(slant === VERTICAL_SKEW) {\n            this.divideWidth = divideWidthVSkew;\n        } else if(slant === HORIZONTAL_SKEW) {\n            this.divideWidth = divideWidthHSkew;\n        } else {\n            throw new Error(\"Invalid recursive maze division skew type\");\n        }\n    }\n\n    /**\n     * Performs the recursive division maze generation algorithm on a new empty grid\n     * by bisecting parts until the maze can no longer be bisected\n     * Params must be within bounds and create a chamber\n     * @param topLeft optional parameter to specify what point the maze should start from\n     *  This should not be further up/left than (1,1)\n     * @param bottomRight optional parameter to specify how far down and right the maze will go\n     *  This should not be further right/down than (width-2,height-2)\n     */\n    generateTerrain(topLeft?: Point, bottomRight?: Point) {\n        const grid = new RectGrid(this.width, this.height);\n        if(topLeft === undefined) {\n            topLeft = {\n                x: 1, y: 1\n            }\n        }\n        if(bottomRight === undefined) {\n            bottomRight = {\n                x: grid.getWidth()-2,\n                y: grid.getHeight()-2\n            }\n        }\n        for(let x = topLeft.x - 1; x <= bottomRight.x + 1; x++) {\n            this.draw(grid,{\n                point: {\n                    x: x, y: topLeft.y - 1\n                },\n                data: this.getSolid()\n            });\n            this.draw(grid,{\n                point: {\n                    x: x, y: bottomRight.y + 1\n                },\n                data: this.getSolid()\n            });\n        }\n        for(let y = topLeft.y - 1; y <= bottomRight.y + 1; y++) {\n            this.draw(grid,{\n                point: {\n                    x: topLeft.x - 1, y: y\n                },\n                data: this.getSolid()\n            });\n            this.draw(grid,{\n                point: {\n                    x: bottomRight.x + 1, y: y\n                },\n                data: this.getSolid()\n            });\n        }\n        this.divide(grid,{\n            topLeft: topLeft,\n            bottomRight: bottomRight,\n        });\n        return grid;\n    }\n\n    /**\n     * Draws a list of tiles to the grid\n     * @param grid\n     * @param tiles\n     */\n    private drawArr(grid: Grid, tiles: Tile[]) {\n        for(const tile of tiles) {\n            this.draw(grid, tile);\n        }\n    }\n\n    /**\n     * Create a line between a region, with an open hole, in a chamber,\n     * and call bisection algorithm on it, and call division algorithms on\n     * its split chambers until no chambers can be bisected\n     * @param grid\n     * @param chamber\n     */\n    divide(grid: Grid, chamber: Chamber) {\n        const width = widthOf(chamber);\n        const height = heightOf(chamber);\n        const min = chamber.topLeft;\n        const max = chamber.bottomRight;\n        if(this.divideWidth(width,height)) {\n            if(width > LIMIT) {\n                //calculate axis\n                const randX = getMidPoint(\n                    min.x, max.x\n                );\n                //create axis wall\n                const toDraw: Tile[] = [];\n                for(let y = min.y; y <= max.y; y++) {\n                    toDraw.push({\n                        point: {\n                            x: randX, y: y\n                        },\n                        data: this.getTerrain()\n                    });\n                }\n                //create holes in axis wall\n                let edgeBlocked = false;\n                if(canDrawHole(grid.get({\n                    x: randX, y: min.y-1\n                }))) {\n                    toDraw.push({\n                        point: {\n                            x: randX, y: min.y\n                        },\n                        data: createTileData(false)\n                    });\n                    edgeBlocked = true;\n                }\n                if(canDrawHole(grid.get({\n                    x: randX, y: max.y+1\n                }))) {\n                    toDraw.push({\n                        point: {\n                            x: randX, y: max.y\n                        },\n                        data: createTileData(false)\n                    });\n                    edgeBlocked = true;\n                }\n                if(!edgeBlocked) {\n                    const randY = getRand(\n                        min.y, max.y,\n                    );\n                    toDraw.push({\n                        point: {\n                            x: randX, y: randY\n                        },\n                        data: createTileData(false)\n                    });\n                }\n                this.drawArr(grid, toDraw);\n                //create children chambers and recurse\n                const leftChamber = {\n                    topLeft: chamber.topLeft,\n                    bottomRight: {\n                        x: randX-1,\n                        y: chamber.bottomRight.y\n                    },\n                };\n                const rightChamber = {\n                    topLeft: {\n                        x: randX+1,\n                        y: chamber.topLeft.y\n                    },\n                    bottomRight: chamber.bottomRight,\n                };\n                this.divide(grid, leftChamber);\n                this.divide(grid, rightChamber);\n            }\n        } else {\n            if(height > LIMIT) {\n                //calculate axis\n                const randY = getMidPoint(\n                    min.y, max.y\n                );\n                //draw axis wall\n                const toDraw: Tile[] = [];\n                for(let x = min.x; x <= max.x; x++) {\n                    toDraw.push({\n                        point: {\n                            x: x, y: randY\n                        },\n                        data: this.getTerrain()\n                    });\n                }\n                //create holes in axis wall\n                let edgeBlocked = false;\n                if(canDrawHole(grid.get({\n                    x: min.x-1, y: randY\n                }))) {\n                    toDraw.push({\n                        point: {\n                            x: min.x, y: randY\n                        },\n                        data: createTileData(false)\n                    });\n                    edgeBlocked = true;\n                }\n                if(canDrawHole(grid.get({\n                    x: max.x+1, y: randY\n                }))) {\n                    toDraw.push({\n                        point: {\n                            x: max.x, y: randY\n                        },\n                        data: createTileData(false)\n                    });\n                    edgeBlocked = true;\n                }\n                if(!edgeBlocked) {\n                    const randX = getRand(\n                        min.x, max.x,\n                    );\n                    toDraw.push({\n                        point: {\n                            x: randX, y: randY\n                        },\n                        data: createTileData(false)\n                    });\n                }\n                this.drawArr(grid, toDraw);\n                //create children chambers and recurse\n                const topChamber = {\n                    topLeft: chamber.topLeft,\n                    bottomRight: {\n                        x: chamber.bottomRight.x,\n                        y: randY-1\n                    },\n                };\n                const bottomChamber = {\n                    topLeft: {\n                        x: chamber.topLeft.x,\n                        y: randY+1\n                    },\n                    bottomRight: chamber.bottomRight,\n                };\n                this.divide(grid, topChamber);\n                this.divide(grid, bottomChamber);\n            }\n        }\n    }\n}\n\nfunction divideWidthNoSkew(width: number, height: number) {\n    return width >= height;\n}\n\nfunction divideWidthHSkew(width: number, height: number) {\n    return width >= height * 2;\n}\n\nfunction divideWidthVSkew(width: number, height: number) {\n    return width * 2 >= height;\n}\n\nfunction widthOf(chamber: Chamber) {\n    return chamber.bottomRight.x - chamber.topLeft.x + 1;\n}\n\nfunction heightOf(chamber: Chamber) {\n    return chamber.bottomRight.y - chamber.topLeft.y + 1;\n}\n\nfunction canDrawHole(tile: Tile) {\n    return tile.data.pathCost === 1 && !tile.data.isSolid;\n}\n\n/**\n * Returns the 'midpoint' to be used\n * @param min\n * @param max\n */\nfunction getMidPoint(min: number, max: number) {\n    const range = max - min;\n    if(range >= 20) {\n        return ((min+max)/2) >> 0;\n    } else if(range > 5) {\n        const mid = ((min+max)/2) >> 0;\n        const points = [mid, mid+1];\n        return points[getRand(0,points.length-1)];\n    } else {\n        return getRand(min+1,max-1);\n    }\n}\n\n/**\n * Generate a random number between min and max, inclusive for min and max\n * @param min\n * @param max\n */\nfunction getRand(min: number, max: number) {\n    return Math.floor(Math.random() * (max+1-min) + min);\n}\n\nexport default TerrainMazeGenerator;","import TerrainRandomGenerator from '../algorithms/TerrainRandomGenerator';\nimport TerrainMazeGenerator from '../algorithms/TerrainMazeGenerator';\nimport {createTileData, Point, TileData} from '../core/Components';\n\nexport const MAZE = 0;\nexport const MAZE_VERTICAL_SKEW = 1;\nexport const MAZE_HORIZONTAL_SKEW = 2;\nexport const RANDOM_TERRAIN = 3;\n\nclass TerrainGeneratorBuilder\n{\n    private width: number = 0;\n    private height: number = 0;\n    private type: number = MAZE;\n    private ignore: Point[] = [];\n    private data: TileData = createTileData(true);\n\n    setDimensions(width: number, height: number) {\n        this.width = width;\n        this.height = height;\n        return this;\n    }\n\n    setGeneratorType(type: number) {\n        this.type = type;\n        return this;\n    }\n\n    setIgnorePoints(ignore: Point[]) {\n        this.ignore = ignore.slice();\n        return this;\n    }\n\n    setTileData(data: TileData) {\n        this.data = data;\n        return this;\n    }\n\n    /**\n     * Builds a terrain generator with the specified type\n     */\n    build() {\n       if(this.type >= RANDOM_TERRAIN) {\n           return new TerrainRandomGenerator(this.width, this.height, this.data, this.ignore);\n       } else {\n           return new TerrainMazeGenerator(this.width, this.height, this.data, this.ignore, this.type);\n       }\n    }\n}\n\nexport default TerrainGeneratorBuilder;","class VirtualTimer\n{\n    private timeout: NodeJS.Timeout;\n    private readonly callback: () => void\n    private timeStarted: number;\n    private timeRemaining: number;\n    private finished: boolean;\n\n    constructor(callback: () => void, countDown: number) {\n        this.callback = callback;\n        this.finished = false;\n        this.timeStarted = Date.now();\n        this.timeRemaining = countDown;\n        this.timeout = setTimeout(() => {\n            callback();\n            this.finished = true;\n        }, this.timeRemaining);\n    }\n\n    clear() {\n        clearTimeout(this.timeout);\n        this.finished = true;\n    }\n\n    pause() {\n        if(!this.finished) {\n            clearTimeout(this.timeout);\n            this.timeRemaining -= Date.now() - this.timeStarted;\n        }\n    }\n\n    resume() {\n        if(!this.finished) {\n            this.timeStarted = Date.now();\n            this.timeout = setTimeout(() => {\n                this.callback();\n                this.finished = true;\n            }, this.timeRemaining);\n        }\n    }\n\n    isFinished() {\n        return this.finished;\n    }\n\n    getNativeTimeout() {\n        return this.timeout;\n    }\n}\n\nexport default VirtualTimer;","import React, {RefObject} from 'react';\nimport GridVisualization from './GridVisualization';\nimport GridForeground from './GridForeground';\nimport Stats from './Stats';\nimport GridBackground from './GridBackground';\nimport {Node} from '../../pathfinding/algorithms/Node';\nimport PathfinderBuilder from '../../pathfinding/builders/PathfinderBuilder';\nimport Pathfinder from '../../pathfinding/algorithms/Pathfinder';\nimport {euclidean} from '../../pathfinding/algorithms/Heuristics';\nimport TerrainGeneratorBuilder, {RANDOM_TERRAIN} from '../../pathfinding/builders/TerrainGeneratorBuilder';\nimport {createTileData, Point, Tile, TileData} from '../../pathfinding/core/Components';\nimport {HashSet, stringify} from '../../pathfinding/structures/Hash';\nimport AppSettings from '../../utils/AppSettings';\nimport VirtualTimer from '../../utils/VirtualTimer';\n\ninterface IProps {\n    tileWidth: number,\n    settings: Readonly<AppSettings>,\n    onChangeVisualizing: (visualizing: boolean) => void;\n}\n\ninterface IState {\n    time: number,\n    length: number,\n    cost: number,\n    nodes: number,\n    algorithm: string,\n    tilesX: number,\n    tilesY: number\n}\n\n/**\n * Component to encapsulate and perform all pathfinding operations\n * Exposes functions to initiate pathfinding or draw terrain\n */\nclass PathfindingVisualizer extends React.Component<IProps,IState>\n{\n    //references to expose background and foreground grids to parent\n    private background: RefObject<GridVisualization> = React.createRef();\n    private foreground: RefObject<GridForeground> = React.createRef();\n\n    private visualized = false;\n    private visualizing = false;\n    private visualTimeouts: VirtualTimer[]  = [];\n    private generations: Node[] = [];\n    private paused = false;\n    private wasPaused = false; //paused before alt tab?\n\n    private mazeTile: TileData = createTileData(true);\n\n    private readonly tileWidth: number\n\n    constructor(props: IProps) {\n        super(props);\n        const w = document.documentElement.clientWidth;\n        const h = document.documentElement.clientHeight;\n        this.tileWidth = this.props.tileWidth;\n        const tilesX = Math.floor(w / this.tileWidth) + 1;\n        const tilesY = Math.floor((h - 75 - 30) / this.tileWidth) + 1;\n        this.state = {\n            time: -1,\n            length: -1,\n            cost: -1,\n            nodes: -1,\n            algorithm: '',\n            tilesX: tilesX,\n            tilesY: tilesY\n        }\n    }\n\n    onWindowResize = () => {\n        const w = document.documentElement.clientWidth;\n        const h = document.documentElement.clientHeight;\n        const tilesX = Math.floor(w / this.tileWidth) + 1;\n        const tilesY = Math.floor((h - 75 - 30) / this.tileWidth) + 1;\n        this.setState(prevState => ({\n            tilesX: prevState.tilesX < tilesX ? tilesX : prevState.tilesX,\n            tilesY: prevState.tilesY < tilesY ? tilesY : prevState.tilesY\n        }));\n    }\n\n    onWindowBlur = () => {\n        this.wasPaused = this.isPaused();\n        if(!this.wasPaused) {\n            this.pausePathfinding();\n        }\n    }\n\n    onWindowFocus = () => {\n        if(this.isPaused() && !this.wasPaused) {\n            this.resumePathfinding();\n        }\n    }\n\n    /**\n     * Automatically pause/resume the visualization when user alt tabs\n     */\n    componentDidMount() {\n        window.addEventListener('resize', this.onWindowResize);\n        window.addEventListener('blur', this.onWindowBlur);\n        window.addEventListener('focus', this.onWindowFocus);\n    }\n\n    componentWillUnmount() {\n        window.removeEventListener('resize', this.onWindowResize);\n        window.removeEventListener('blur', this.onWindowBlur);\n        window.removeEventListener('focus', this.onWindowFocus);\n    }\n\n    /**\n     * Prevents pathfinding grid from being updated unless the algorithm stats\n     * have changed (meaning an algorithm was visualized)\n     * Doesn't prevent Foreground and background from being updated automatically\n     * when their state changes\n     * @param nextProps\n     * @param nextState\n     */\n    shouldComponentUpdate(nextProps: Readonly<IProps>, nextState: Readonly<IState>) {\n        const prevState = this.state;\n        const prevProps = this.props;\n        return JSON.stringify(prevState) !== JSON.stringify(nextState) ||\n            JSON.stringify(prevProps) !== JSON.stringify(nextProps);\n    }\n\n    changeTile(data: TileData) {\n        this.mazeTile = data; //enables weighted terrain\n        this.foreground.current!.changeTile(data);\n    }\n\n    isPaused() {\n        return this.paused;\n    }\n\n    /**\n     * Pause the delayed pathfinding algorithm being performed\n     */\n    pausePathfinding() {\n        this.paused = true;\n        for(const timeout of this.visualTimeouts) {\n            timeout.pause();\n        }\n    }\n\n    /**\n     * Resume the delayed pathfinding algorithm being performed\n     * Will reset the timeouts to the last time the timeout was paused/started\n     * if not properly called while the timeout is paused\n     */\n    resumePathfinding() {\n        this.paused = false;\n        for(const timeout of this.visualTimeouts) {\n            timeout.resume();\n        }\n    }\n\n    /**\n     * Performs the pathfinding algorithm on the grid and visualizes it\n     */\n    doPathfinding() {\n        this.clearPath();\n        const settings = this.props.settings;\n        const pathfinder = this.getPathfinder(settings);\n        const path = this.findPath(pathfinder);\n        this.generations = pathfinder.getRecentGenerations();\n        this.visualizeGenerations(this.generations);\n        this.addArrowGenerations(this.generations);\n        this.drawPath(path);\n    }\n\n    /**\n     * Performs the pathfinding algorithm on the grid and visualizes it with delays between successive\n     * node generations\n     * If the grid is currently visualizing, the visualization stops instead\n     */\n    doDelayedPathfinding() {\n        const settings = this.props.settings;\n        const background = this.background.current!;\n        background.enableAnimations();\n        this.paused = false;\n        this.clearVisualization();\n        this.clearPath();\n        this.visualized = false;\n        const foreground = this.foreground.current!;\n        foreground.toggleDisable();\n        if(!this.visualizing) { //start visualization if not visualizing\n            this.visualizing = true;\n            this.props.onChangeVisualizing(this.visualizing);\n            const pathfinder = this.getPathfinder(settings);\n            const path = this.findPath(pathfinder);\n            const promises: Promise<VirtualTimer>[] = []; //to call function when timeouts finish\n            this.visualTimeouts = [];\n            const baseIncrement = settings.delayInc;\n            let delay = 0;\n            this.generations = pathfinder.getRecentGenerations();\n            const generationSet = new HashSet(); //to keep track of rediscovered nodes\n            this.generations.forEach((generation) => {\n                const promise = new Promise<VirtualTimer>((resolve) => {\n                    //each generation gets a higher timeout\n                    const timeout = new VirtualTimer(() => {\n                        this.visualizeGenerationAndArrows(generation);\n                        resolve(timeout);\n                    }, delay);\n                    this.visualTimeouts.push(timeout);\n                });\n                promises.push(promise);\n                if(!generationSet.has(stringify(generation.tile.point))) {\n                    //rediscovered nodes shouldn't add a delay to visualization\n                    delay += baseIncrement;\n                }\n                generationSet.add(stringify(generation.tile.point));\n            });\n            //call functions when timeouts finish\n            Promise.all(promises).then(() => {\n                this.drawPath(path);\n                foreground.toggleDisable();\n                this.visualizing = false;\n                this.visualized = true;\n                this.props.onChangeVisualizing(this.visualizing);\n                background.disableAnimations();\n            });\n        } else { //stop visualizing if currently visualizing\n            for (const timeout of this.visualTimeouts) {\n                timeout.clear();\n            }\n            this.visualizing = false;\n            this.props.onChangeVisualizing(this.visualizing);\n        }\n    }\n\n    /**\n     * Get the pathfinder for the settings\n     * @param settings\n     */\n    getPathfinder(settings: AppSettings) {\n        const algorithmKey = settings.algorithm;\n        const algorithm = settings.bidirectional && PathfinderBuilder.hasBidirectional(algorithmKey) ?\n            PathfinderBuilder.makeBidirectional(algorithmKey) : algorithmKey;\n        return new PathfinderBuilder(this.foreground.current!.state.grid)\n            .setAlgorithm(algorithm)\n            .setHeuristic(settings.heuristicKey)\n            .setNavigator(settings.navigatorKey)\n            .build();\n    }\n\n    /**\n     * Find path with a given pathfinder, includes benchmarking\n     * @param pathfinder\n     */\n     findPath(pathfinder: Pathfinder) {\n        const foreground = this.foreground.current!;\n        const t0 = performance.now();\n        const path = pathfinder.findPath(foreground.state.initial, foreground.state.goal);\n        const t1 = performance.now();\n        const t2 = t1 - t0;\n        this.setState({\n            time: t2,\n            nodes: pathfinder.getRecentNodes(),\n            length: calcLength(foreground.state.initial, path),\n            cost: calcCost(foreground.state.grid.get(foreground.state.initial), path),\n            algorithm: pathfinder.getAlgorithmName()\n        });\n        return path;\n    }\n\n    /**\n     * Draw path on the grid and change length on ui\n     * @param path\n     */\n    drawPath(path: Tile[]) {\n        const foreground = this.foreground.current!\n        path.unshift(this.foreground.current!.state.grid.get(foreground.state.initial));\n        this.foreground.current!.drawPath(path);\n    }\n\n    /**\n     * Called when child foreground moves a tile\n     */\n    onTilesDragged() {\n        if(this.visualized) {\n            this.clearVisualization();\n            this.doPathfinding();\n            this.visualized = true;\n        }\n    }\n\n    /**\n     * Create terrain on the grid foreground\n     */\n    createTerrain(mazeType: number, useMazeTile: boolean) {\n        if(this.visualizing) {\n            return;\n        }\n        this.clearTiles();\n        this.clearPath();\n        this.clearVisualization();\n        const foreground = this.foreground.current!;\n        const end = this.calcEndPointInView();\n        const newState = (mazeType !== RANDOM_TERRAIN) ? {\n            initial: {\n                x: 1, y: 1\n            },\n            goal: {\n                x: end.x-2, y: end.y-2\n            }\n        } : {\n            initial: {\n                x: 1, y: ((end.y-1) / 2) >> 0\n            },\n            goal: {\n                x: end.x-2, y: ((end.y-1) / 2) >> 0\n            }\n        };\n        foreground.setState(newState,() => {\n            const prevGrid = foreground.state.grid;\n            const generator = new TerrainGeneratorBuilder()\n                .setDimensions(\n                    prevGrid.getWidth(),\n                    prevGrid.getHeight()\n                )\n                .setGeneratorType(mazeType)\n                .setIgnorePoints([foreground.state.initial, foreground.state.goal])\n                .setTileData(useMazeTile ? this.mazeTile : getSolid())\n                .build();\n            const topLeft = {\n                x: 1, y: 1\n            };\n            const bottomRight = {\n                x: end.x-2, y: end.y-2\n            };\n            const grid = generator.generateTerrain(topLeft, bottomRight);\n            foreground.drawGrid(grid);\n        });\n    }\n\n    /**\n     * Calculate the end/goal point in view of the screen\n     * Used to calculate the terrain dimensions\n     */\n    calcEndPointInView() {\n        const end = this.calcEndPoint();\n        const xEnd = end.x;\n        const yEnd = end.y;\n        const xFloor = Math.floor(xEnd);\n        const yFloor = Math.floor(yEnd);\n        const xDecimal = xEnd - xFloor;\n        const yDecimal = yEnd - yFloor;\n        let x = xDecimal > 0.05 ? Math.ceil(xEnd) : xFloor;\n        let y = yDecimal > 0.05 ? Math.ceil(yEnd) : yFloor;\n        if(x > this.state.tilesX) {\n            x = this.state.tilesX\n        }\n        if(y > this.state.tilesY) {\n            y = this.state.tilesY\n        }\n        return {\n            x: x, y: y\n        }\n    }\n\n    calcEndPoint() {\n        const xEnd = Math.round(document.documentElement.clientWidth / this.tileWidth);\n        const yEnd = Math.round((document.documentElement.clientHeight - 30 - 75) / this.tileWidth);\n        return {\n            x: xEnd, y: yEnd\n        }\n    }\n\n    resetPoints() {\n        if(!this.visualizing) {\n            this.foreground.current!.resetPoints();\n        }\n    }\n\n    clearPath = () => {\n        this.foreground.current!.erasePath();\n    }\n\n    clearTiles() {\n        this.foreground.current!.clearTiles();\n    }\n\n    clearTilesChecked() {\n        if(!this.visualizing) {\n            this.foreground.current!.clearTiles();\n        }\n    }\n\n    clearVisualization() {\n        this.visualized = false;\n        this.background.current!.clear();\n    }\n\n    clearVisualizationChecked() {\n        if(!this.visualizing) {\n            this.visualized = false;\n            this.background.current!.clear();\n        }\n    }\n\n    visualizeGenerations(generations: Node[]) {\n        this.background.current!.visualizeGenerations(generations);\n        this.visualized = true;\n    }\n\n    addArrowGenerations(generations: Node[]) {\n        this.background.current!.addArrowGenerations(generations);\n    }\n\n    visualizeGenerationAndArrows(generation: Node) {\n        this.background.current!.visualizeGenerationAndArrows(generation);\n    }\n\n    /**\n     * Renders the sub components of the visualizer needed to show\n     *  the algorithm stats,\n     *  the grid itself,\n     *  the visualization of the algorithm,\n     *  and the maze the pathfinder solves\n     */\n    render() {\n        return (\n            <div>\n                <Stats\n                    algorithm={this.state.algorithm}\n                    length={this.state.length}\n                    cost={this.state.cost}\n                    time={this.state.time}\n                    nodes={this.state.nodes}\n                />\n                <div>\n                    <GridBackground\n                        tileWidth={this.tileWidth}\n                        width={this.state.tilesX}\n                        height={this.state.tilesY}\n                    />\n                    <GridVisualization\n                        ref={this.background}\n                        settings={this.props.settings}\n                        tileWidth={this.tileWidth}\n                        width={this.state.tilesX}\n                        height={this.state.tilesY}\n                    />\n                    <GridForeground\n                        ref={this.foreground}\n                        onTilesDragged={() => this.onTilesDragged()}\n                        tileSize={this.tileWidth}\n                        width={this.state.tilesX}\n                        height={this.state.tilesY}\n                        end={this.calcEndPoint()}\n                    />\n                </div>\n            </div>\n        );\n    }\n}\n\nfunction getSolid() {\n    return {\n        pathCost: 1,\n        isSolid: true\n    }\n}\n\nfunction calcLength(initial: Point, path: Tile[]) {\n    if(path.length === 0) {\n        return 0;\n    }\n    let len = euclidean(initial, path[0].point);\n    for (let i = 0; i < path.length - 1; i++) {\n        len += euclidean(path[i].point, path[i + 1].point);\n    }\n    return +(len).toFixed(3);\n}\n\nfunction calcCost(initial: Tile, path: Tile[]) {\n    if(path.length === 0) {\n        return 0;\n    }\n    let len = euclidean(initial.point, path[0].point) * path[0].data.pathCost;\n    for (let i = 0; i < path.length - 1; i++) {\n        len += euclidean(path[i].point, path[i + 1].point) * path[i + 1].data.pathCost;\n    }\n    return +(len).toFixed(3);\n}\n\nexport default PathfindingVisualizer;","export default __webpack_public_path__ + \"static/media/react.93a4bdf1.png\";","import React from 'react';\r\n\r\nexport const KEY_SHOW = 'visited';\r\n\r\ninterface IProps {}\r\n\r\ninterface IState {\r\n    show: boolean\r\n    page: number\r\n}\r\n\r\nclass Tutorial extends React.Component<IProps,IState>\r\n{\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.state = {\r\n            show: true,\r\n            page: 0\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Hide the tutorial and set key in local storage to true to prevent it from being shown again\r\n     */\r\n    hide() {\r\n        this.setState({\r\n            show: false\r\n        }, () => localStorage.setItem(KEY_SHOW, 'true'));\r\n    }\r\n\r\n    /**\r\n     * Display the child one index to the left\r\n     */\r\n    prev() {\r\n        this.setState(prevState => ({\r\n            page: prevState.page - 1 >= 0 ? prevState.page - 1 : prevState.page\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Display the child one index to the right\r\n     */\r\n    next() {\r\n        const children = React.Children.toArray(this.props.children);\r\n        this.setState(prevState => ({\r\n            page: prevState.page + 1 < children.length ? prevState.page + 1 : prevState.page\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Checks if hide was called before by checking if hide() has been called before\r\n     */\r\n    showPanel() {\r\n        return localStorage.getItem(KEY_SHOW) !== 'true';\r\n    }\r\n\r\n    /**\r\n     * Tutorial page will only be visible if tutorial hasn't been hidden before\r\n     * Render's the page-th child in the panel\r\n     * If the page is the final page, the next button is replaced with a finish button\r\n     */\r\n    render() {\r\n        const children = React.Children.toArray(this.props.children);\r\n        const lastPage = this.state.page + 1 === children.length;\r\n        return(\r\n            <div\r\n                style={{\r\n                    display: this.showPanel() && this.state.show ? 'block' : 'none'\r\n                }}\r\n                className='tutorial-panel'\r\n            >\r\n                <div\r\n                    className='x-tutorial-button'\r\n                    tabIndex={0}\r\n                    onKeyPress={() => this.hide()}\r\n                    onClick={() => this.hide()}\r\n                    onMouseDown={e => {\r\n                        e.stopPropagation();\r\n                        e.preventDefault();\r\n                    }}\r\n                >\r\n                    <div className='x-tutorial-text'>\r\n                        X\r\n                    </div>\r\n                </div>\r\n                <div className='content-top-wrapper'>\r\n                    <div className='content-top'>\r\n                        {this.state.page + 1 }/{children.length}\r\n                    </div>\r\n                </div>\r\n                <div className='content'>\r\n                    {children[this.state.page]}\r\n                </div>\r\n                <div className='tutorial-control-wrapper'>\r\n                    <button\r\n                        className='tutorial-button tutorial-left-button tut-blue-button'\r\n                        onMouseDown={e => e.preventDefault()}\r\n                        onClick={() => this.prev()}\r\n                    >\r\n                        Prev\r\n                    </button>\r\n                    <button\r\n                        className='tutorial-button tutorial-right-button tut-blue-button'\r\n                        onMouseDown={e => e.preventDefault()}\r\n                        onClick={\r\n                            !lastPage ?\r\n                                () => this.next() :\r\n                                () => this.hide()\r\n                        }\r\n                    >\r\n                        {!lastPage ? 'Next' : 'Finish'}\r\n                    </button>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Tutorial;","import React from 'react'\r\nimport Icon from '../../assets/react.png';\r\nimport WeightTileImg from '../../assets/weight-tile.png';\r\nimport StartGoalImg from '../../assets/start-goal.png';\r\n\r\nexport class IntroductionPage extends React.Component\r\n{\r\n    render() {\r\n        return (\r\n            <div key='introduction'>\r\n                <h1 className='tutorial-title'>\r\n                    Welcome to Pathfinder!\r\n                </h1>\r\n                <div className='tutorial-subtext-center'>\r\n                    &emsp;&emsp;\r\n                    Continue reading the tutorial to learn more about this application!\r\n                    Click the X on the top right to skip the tutorial!\r\n                </div>\r\n                <div\r\n                    className='tutorial-img-large-wrapper'\r\n                >\r\n                    <img\r\n                        width={'50%'} height={'50%'}\r\n                        className='icon tutorial-img'\r\n                        alt={''} src={Icon}\r\n                    />\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class ExplanationPage extends React.Component\r\n{\r\n    render() {\r\n        return (\r\n            <div key='explanation'>\r\n                <h1 className='tutorial-title'>\r\n                    What is this application?\r\n                </h1>\r\n                <div className='tutorial-subtext'>\r\n                    &emsp;&emsp;\r\n                    This application is a tool for visualizing pathfinding algorithms.\r\n                    Pathfinding algorithms seek to find the shortest path between two vertices on a graph.\r\n                    This application has adapted the algorithms to perform on a grid where vertices are tiles and\r\n                    edges are 90 degree paths between adjacent tiles.\r\n                </div>\r\n                <div className='tutorial-subtext'>\r\n                    &emsp;&emsp;\r\n                    Some pathfinding algorithms are <i>weighted</i> while other algorithms are <i>unweighted</i>.\r\n                    Weighted algorithms take into account the cost to travel to a tile, and therefore always find the shortest path.\r\n                    Unweighted algorithms don't take into account the cost to travel to a tile, and don't always find the shortest path.\r\n                    The shortest path is the path with the lowest cost between the two points.\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class DrawingPage extends React.Component\r\n{\r\n    render() {\r\n        return (\r\n            <div key='draw'>\r\n                <h1 className='tutorial-title'>\r\n                    Drawing Walls and Weights\r\n                </h1>\r\n                <div className='tutorial-subtext'>\r\n                    &emsp;&emsp;\r\n                    Click and drag on the empty tiles to draw walls or weights.\r\n                    Click and drag on filled tiles to erase.\r\n                    Click the purple drop down menu to change which wall or weight to draw.\r\n                    Generate terrain by clicking the yellow drop down menu.\r\n                </div>\r\n                <div className='tutorial-subtext'>\r\n                    &emsp;&emsp;\r\n                    Walls cannot be traveled to, and are therefore not explored by any of the algorithms.\r\n                    Weights can be traveled to, however they are more costly to travel to. For example,\r\n                    Weight[5] is 5 times more costly to travel to than an empty tile.\r\n                </div>\r\n                <div\r\n                    className='tutorial-img-wrapper'\r\n                >\r\n                    <img\r\n                        src={WeightTileImg}\r\n                        className='tutorial-img'\r\n                        alt='Weight Tile'\r\n                    />\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class EndpointsPage extends React.Component\r\n{\r\n    render() {\r\n        return (\r\n            <div key='end-points'>\r\n                <h1 className='tutorial-title'>\r\n                    Dragging Start and Goal Nodes\r\n                </h1>\r\n                <div className='tutorial-subtext'>\r\n                    &emsp;&emsp;\r\n                    The green node (start) is where the pathfinding algorithms start from,\r\n                    while the red node (goal) is where the algorithm is trying to find the shortest path to.\r\n                    You can move the start and goal nodes by clicking them and dragging them.\r\n                </div>\r\n                <div className='tutorial-subtext'>\r\n                    &emsp;&emsp;\r\n                    You can drag the nodes even after the algorithm has finished being visualized.\r\n                    This allows you to instantly see how paths vary for different start and goal positions.\r\n                </div>\r\n                <div\r\n                    className='tutorial-img-large-wrapper'\r\n                >\r\n                    <img\r\n                        src={StartGoalImg}\r\n                        className='tutorial-img'\r\n                        alt='Start-Goal'\r\n                        width='28%'\r\n                        height='28%'\r\n                    />\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class AlgorithmsPage extends React.Component\r\n{\r\n    render() {\r\n        return (\r\n            <div key='algorithms'>\r\n                <h1 className='tutorial-title'>\r\n                    Pathfinding Algorithms\r\n                </h1>\r\n                <div className='tutorial-text'>\r\n                    <div className='text-row'>\r\n                        <b>Dijkstra's Algorithm</b> (weighted):\r\n                        The most fundamental pathfinding algorithm, it uses path costs to guarantee the shortest path.\r\n                        Out of these algorithms, it is the most expensive to perform and often checks the most nodes.\r\n                    </div>\r\n                    <div className='text-row'>\r\n                        <b>A* Search</b> (weighted):\r\n                        Uses both path costs and heuristics to guarantee the shortest path while exploring less nodes than Dijkstra.\r\n                        Widely considered to be one of the best pathfinding algorithms.\r\n                    </div>\r\n                    <div className='text-row'>\r\n                        <b>Best First Search</b> (unweighted):\r\n                        Uses heuristics to explore nodes closer to the goal.\r\n                        Explores a low amount of nodes, but doesn't guarantee the shortest path.\r\n                    </div>\r\n                    <div className='text-row'>\r\n                        <b>Breadth First Search</b> (unweighted):\r\n                        A solid algorithm that guarantees the shortest path on unweighted grids, however it will\r\n                        fail to find the shortest path on weighted grids.\r\n                        Very cheap to perform on small grids.\r\n                    </div>\r\n                    <div className='text-row'>\r\n                        <b>Depth First Search</b> (unweighted):\r\n                        A poor algorithm for pathfinding that doesn't guarantee the shortest path.\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class FinishPage extends React.Component\r\n{\r\n    render() {\r\n        return (\r\n            <div key='finish'>\r\n                <h1 className='tutorial-title'>\r\n                    Enjoy using Pathfinder!\r\n                </h1>\r\n                <div className='tutorial-subtext-narrow'>\r\n                    &emsp; &emsp;\r\n                    I hope you enjoy using this visualization tool and can learn something from it!\r\n                    If you want to see the tutorial again, just click \"Pathfinding Visualizer\" on the top left corner of your screen.\r\n                    You can see the source code on my github <a\r\n                    href='https://github.com/JosephPrichard/Pathfinder'\r\n                    className='tutorial-link'\r\n                >\r\n                    here\r\n                </a>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\nexport function getTutorialPages() {\r\n    return [\r\n        <IntroductionPage key='intro'/>,\r\n        <ExplanationPage key='explain'/>,\r\n        <DrawingPage key='draw'/>,\r\n        <EndpointsPage key='end'/>,\r\n        <AlgorithmsPage key='alg'/>,\r\n        <FinishPage key='finish'/>\r\n    ];\r\n}","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGoAAABKCAIAAADc71b2AAAD30lEQVR4Xu3a30uTURgHcP+Fgsjwoigi6sJ+gZeKZJJRhkJiP26y1ExLKzJbF2VWiiEVZWqphRk1tZRcYGNobYmmmaI2NE3mD6Zi5mAZ3djbaa87O3vevak7bV2c58tzMT3Pew5+PL7v2TBAcsTUNyu/8F38sITk91UCwNe+ix+WkPy+SgB5heV14e7zJnQV5PMmyMcV5OMK8nEF+biCfFxBPq4gH1eQjyvIxxXk4wrycQX5uIJ8XEE+riAfV5CPK8jHFeTjCvJxBfm4gnxcQT6uIB9XkI8ryMcV5OMK8nEF+biCfFxBPq4gH1dcfCbFf0xiLb5cuy94S4ivy/Xr81lMS9l9P77/7HzXp69qaXja3GromRqfgR0qoasIytdq6NYcuhO6LAFUSuS1+goj7FZEXD6y43KS7yvhAGJ/lwVeyURQvinrzLGwbFYqen16WlRuenR+/Nbz7PcjApPfG3rg9c4Iype6K5cCZcbd+vDGzI4OmccKzlbQhsigFPIdtoFGRL6S7BpKU1Ggg8POvK3voG0Z+27AYUeE45uyfqMoxZer4bB7Gl+00eamunY4LCDfk5uvZI4D27LgmKfkJM0/XrLib8MxAfkyovMX/LNlQ86Dcn/4isS5uV9gVDi+vetOyRy9bYNwTCURq5LlS758gg8Q4fjovWxybBqOqYQeZchOBEPC8e1YmSRbjAxMwDGVxG48o7ZhheM7HKKRLZpqPTxJlfk6YaMblhy2wahwfHlp5bJF9tFiOOYpNSUGuf/g9gtwTEC+5oYuupv0VS0jA+N/qcGekZgNp+VmctiGcwnIR3J851UquMgKW54wOerhUSMiH3mTC3R0n90a7EYtaEgMv+LW4YxwfNVFeuXmInxKMlBG3Uc4l2h80xO2iMD5g8uetSedNNoOmypfZFCK/GL3mjS7Dc4pFt+DnOfUJW5zJstnqYRwcsVsmj/0kaq6pwcTisXHfhTK8BktTA/YhiwfuYRp/BOB+Cz9VtaF4WNKY7a7C7J8pAa6h9k5BeJrrHV9eBeqxkeq0ipJVp0KX6fJ7W2vQHzkzsVCeMcHbn8C8WkLX7MQanyFxlnJZi5U4SvPq2PnFIjPUNPKQrj4NGYLvdktdO8T9493sHdUjc/OtIETDD46XIl1P4WwLmrF8u0PPgcmFIvv7sVn1MILPnDjk0TjGxuapBZL5YtanTo+PAUmFIuP5FH+S+/4lO/YJAH5SC4dKVoq3/UTpXAWR0TkkxyCi+dTs5NYPpPzHyWVP+0/L7rWf6zSsrbH2u4Fq+xhu/JaZbl2n8vWN/HDEpLfV0E+b4J8XKGr/Aa2JBdVbsNn5AAAAABJRU5ErkJggg==\"","export default \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANMAAACUCAYAAAAJWhwNAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAAJaSURBVHhe7d0xahtRFEBRSUWK7CMEl+lTufReXGcN2Y0r1wanTxuT2kuwixRJbPSxGAQq5Av6gnOamekeHy58pnnrfy9Ww4+H59XXzx/H1+mYY8dZLM08x2Y8gXcSE0TEBBExQURMEFnf/3p6+5sHHG/v1/jPv1fj67SuL+7G2+nM8BvWL+mlmedwzYOImCAiJoiICSJigoiYICImiIgJImKCiJggIiaIiAkiYoKImCAiJoiICSJigoiYICImiIgJImKCiJggIiaIiAkiYoKImCAiJoiICSJigoiYICImiIgJInubA2dZdvZlczve4DzsbQ60HW5nhjmcxdLMc7jmQURMEBETRMQEETFBREwQERNExAQRMUFETBARE0TEBBExQURMEBETRMQEETFBREwQERNExAQRMUFETBARE0TEBBExQURMEBETRMQEETFBREwQERNE9padAcex7OyAGeZwFkszz+GaBxExQURMEBETRMQEETFBREwQERNExAQRMUFETBARE0TEBBExQURMEBETRMQEETFBREwQERNExAQRMUFETBARE0TEBBExQURMEBETRMQEETFBREwQERNEbA6EiM2BB8wwh7NYep3jz7dP4+u0Lm8ex9uWax5ExAQRMUFETBARE0TEBBExQURMEBETRMQEETFBREwQERNExAQRMUFETBARE0TEBBExQURMEBETRMQEETFBREwQERNExAQRMUFETBARE0TEBBExQURMELE5kLMzy7KzD99/j7ctmwMPmGEOZ7E08xyueRARE0TEBBExQURMkFit/gPo+a7Roj5QjQAAAABJRU5ErkJggg==\"","import React, {RefObject} from 'react';\nimport TopBar from './navbar/TopBar';\nimport {SettingsButton, VisualizeButton} from './navbar/Buttons';\nimport {\n    AlgorithmDropDown,\n    ClearDropDown,\n    MazeDropDown,\n    TilesDropDown\n} from './navbar/DropDowns';\nimport {\n    AlgorithmSettings,\n    HeuristicSettings, \n    SpeedSettings,\n    VisualSettings\n} from './panel/SettingPanels';\nimport DraggablePanel from './panel/DraggablePanel';\nimport PathfindingVisualizer from './grid/PathfindingVisualizer';\nimport PathfinderBuilder from '../pathfinding/builders/PathfinderBuilder';\nimport {\n    MAZE,\n    MAZE_HORIZONTAL_SKEW,\n    MAZE_VERTICAL_SKEW,\n    RANDOM_TERRAIN\n} from '../pathfinding/builders/TerrainGeneratorBuilder';\nimport Icon from '../assets/react.png';\nimport AppSettings, {getDefaultSettings} from \"../utils/AppSettings\";\nimport Tutorial, {KEY_SHOW} from './tutorial/Tutorial';\nimport {getTutorialPages} from './tutorial/TutorialPages';\n\ninterface IProps {}\n\ninterface IState {\n    settings: AppSettings,\n\n    heuristicDisabled: boolean,\n    bidirectionalDisabled: boolean,\n    arrowsDisabled: boolean,\n    scoreDisabled: boolean\n\n    panelShow: boolean,\n\n    visualizing: boolean,\n    paused: boolean,\n\n    useIcon: boolean\n}\n\nclass PathfindingApp extends React.Component<IProps, IState>\n{\n    //expose grid to parent to connect to button siblings\n    private visualizer: RefObject<PathfindingVisualizer> = React.createRef();\n\n    //drop down refs needed to invoke behavior between dropdowns\n    private algDropDown: RefObject<AlgorithmDropDown> = React.createRef();\n    private clrDropDown: RefObject<ClearDropDown> = React.createRef();\n    private mazeDropDown: RefObject<MazeDropDown> = React.createRef();\n    private tilesDropDown: RefObject<TilesDropDown> = React.createRef();\n\n    private readonly tileWidth: number;\n\n    constructor(props: IProps) {\n        super(props);\n        this.state = {\n            settings: getDefaultSettings(),\n            heuristicDisabled: false,\n            bidirectionalDisabled: false,\n            arrowsDisabled: false,\n            scoreDisabled: false,\n            panelShow: false,\n            visualizing: false,\n            paused: false,\n            useIcon: this.useIcon()\n        }\n        const mobile = isMobile();\n        this.tileWidth =  mobile ? 47 : Math.round(window.screen.availWidth / 57);\n    }\n\n    windowOnResize = () => {\n        this.setState({\n            useIcon: this.useIcon()\n        });\n    }\n\n    /**\n     * Binds window listeners.\n     * Listener is to keep track of screen size to check if we show icon\n     */\n    componentDidMount() {\n        window.addEventListener('resize', this.windowOnResize);\n    }\n\n    componentWillUnmount() {\n        window.removeEventListener('resize', this.windowOnResize);\n    }\n\n    useIcon() {\n        return window.innerWidth <= 850;\n    }\n\n    /**\n     * Called when the drop downs are clicked to prevent more\n     * than one dropdown from being open at a time\n     */\n\n    onClickAlgDrop() {\n        this.clrDropDown.current!.hide();\n        this.mazeDropDown.current!.hide();\n        this.tilesDropDown.current!.hide();\n    }\n\n    onClickClrDrop() {\n        this.algDropDown.current!.hide();\n        this.mazeDropDown.current!.hide();\n        this.tilesDropDown.current!.hide();\n    }\n\n    onClickMazeDrop() {\n        this.clrDropDown.current!.hide();\n        this.algDropDown.current!.hide();\n        this.tilesDropDown.current!.hide();\n    }\n\n    onClickTilesDrop() {\n        this.clrDropDown.current!.hide();\n        this.algDropDown.current!.hide();\n        this.mazeDropDown.current!.hide();\n    }\n\n    /**\n     * Utility functions to change overall state of application\n     * Settings, overall appearance, etc\n     */\n\n    changeButtonActiveState(visualizing: boolean) {\n        this.setState({\n            visualizing: visualizing\n        })\n    }\n\n    toggleSettings() {\n        this.setState(prevState => ({\n            panelShow: !prevState.panelShow\n        }));\n    }\n\n    hideSettings() {\n        this.setState({\n            panelShow: false\n        });\n    }\n\n    doPathfinding() {\n        this.setState({\n            paused: false\n        });\n        this.visualizer.current!.doDelayedPathfinding();\n    }\n\n    pausePathfinding() {\n        this.setState({\n            paused: true\n        });\n        this.visualizer.current!.pausePathfinding();\n    }\n\n    resumePathfinding() {\n        this.setState({\n            paused: false\n        });\n        this.visualizer.current!.resumePathfinding();\n    }\n\n    clearPath() {\n        this.visualizer.current!.clearPath();\n        this.visualizer.current!.clearVisualizationChecked();\n    }\n\n    clearTiles() {\n        this.clearPath();\n        this.visualizer.current!.clearTilesChecked();\n    }\n\n    resetBoard() {\n        this.clearPath();\n        this.clearTiles();\n        this.visualizer.current!.resetPoints();\n    }\n\n    createMaze() {\n        this.visualizer.current!.createTerrain(MAZE, false);\n    }\n\n    createMazeVSkew() {\n        this.visualizer.current!.createTerrain(MAZE_VERTICAL_SKEW, false);\n    }\n\n    createMazeHSkew() {\n        this.visualizer.current!.createTerrain(MAZE_HORIZONTAL_SKEW, false);\n    }\n\n    createRandomTerrain() {\n        this.visualizer.current!.createTerrain(RANDOM_TERRAIN, true);\n    }\n\n    changeTile(cost: number) {\n        this.visualizer.current!.changeTile({\n            isSolid: cost === -1,\n            pathCost: cost\n        });\n    }\n\n    /**\n     * Functions to modify app's settings\n     */\n\n    changeAlgo(algorithm: string) {\n        this.setState(prevState => ({\n            heuristicDisabled: !PathfinderBuilder.usesHeuristic(algorithm),\n            bidirectionalDisabled: !PathfinderBuilder.hasBidirectional(algorithm),\n            scoreDisabled: !PathfinderBuilder.usesWeights(algorithm),\n            settings: {\n                ...prevState.settings,\n                algorithm: algorithm\n            }\n        }));\n    }\n\n    changeShowArrows() {\n        this.setState(prevState => ({\n            settings: {\n                ...prevState.settings,\n                showArrows: !prevState.settings.showArrows\n            }\n        }));\n    }\n\n    changeBidirectional() {\n        this.setState(prevState => ({\n            settings: {\n                ...prevState.settings,\n                bidirectional: !prevState.settings.bidirectional\n            }\n        }));\n    }\n\n    changeSpeed(value: number) {\n        this.setState(prevState => ({\n            settings: {\n                ...prevState.settings,\n                delayInc: value\n            }\n        }));\n    }\n\n    changeManhattan() {\n        this.setState(prevState => ({\n            settings: {\n                ...prevState.settings,\n                heuristicKey: 'manhattan'\n            }\n        }));\n    }\n\n    changeEuclidean() {\n        this.setState(prevState => ({\n            settings: {\n                ...prevState.settings,\n                heuristicKey: 'euclidean'\n            }\n        }));\n    }\n\n    changeChebyshev() {\n        this.setState(prevState => ({\n            settings: {\n                ...prevState.settings,\n                heuristicKey: 'chebyshev'\n            }\n        }));\n    }\n\n    changeOctile() {\n        this.setState(prevState => ({\n            settings: {\n                ...prevState.settings,\n                heuristicKey: 'octile'\n            }\n        }));\n    }\n\n    showTutorial() {\n        localStorage.setItem(KEY_SHOW, 'false');\n    }\n\n    render() {\n        const title: string = 'Pathfinding Visualizer';\n        const icon = this.state.useIcon ?\n            <img\n                width={'100%'} height={'100%'}\n                className='icon'\n                alt={title} src={Icon}\n            /> :\n            title;\n        return (\n            <div>\n                <Tutorial>\n                    {getTutorialPages()}\n                </Tutorial>\n                <DraggablePanel\n                    title='Grid Settings'\n                    show={this.state.panelShow}\n                    onClickXButton={() => this.hideSettings()}\n                    width={350}\n                    height={405}\n                >\n                    <VisualSettings\n                        defaultShowArrows={this.state.settings.showArrows}\n                        disabledTree={this.state.arrowsDisabled}\n                        disabledScore={this.state.scoreDisabled}\n                        onChangeShowArrows={() => this.changeShowArrows()}\n                    />\n                    <SpeedSettings\n                        onChange={(value: number) => this.changeSpeed(value)}\n                        initialSpeed={this.state.settings.delayInc}\n                    />\n                    <AlgorithmSettings\n                        defaultAlg={this.state.settings.bidirectional}\n                        disabled={this.state.bidirectionalDisabled}\n                        onChangeBidirectional={() => this.changeBidirectional()}\n                    />\n                    <HeuristicSettings\n                        defaultHeuristic={this.state.settings.heuristicKey}\n                        disabled={this.state.heuristicDisabled}\n                        onClickManhattan={() => this.changeManhattan()}\n                        onClickEuclidean={() => this.changeEuclidean()}\n                        onClickChebyshev={() => this.changeChebyshev()}\n                        onClickOctile={() => this.changeOctile()}\n                    />\n                </DraggablePanel>\n                <TopBar>\n                    <div\n                        className='title'\n                        tabIndex={0}\n                        style={{\n                            width: this.state.useIcon ? 70 : 'auto',\n                            height: this.state.useIcon ? 52 : '100%'\n                        }}\n                        onClick={() => {\n                            this.showTutorial();\n                            window.location.reload();\n                        }}\n                    >\n                        {icon}\n                    </div>\n                    <AlgorithmDropDown\n                        ref={this.algDropDown}\n                        onClick={() => this.onClickAlgDrop()}\n                        onChange={(alg: string) => this.changeAlgo(alg)}\n                    />\n                    <MazeDropDown\n                        ref={this.mazeDropDown}\n                        onClick={() => this.onClickMazeDrop()}\n                        onClickMaze={() => this.createMaze()}\n                        onClickMazeHorizontal={() => this.createMazeHSkew()}\n                        onClickMazeVertical={() => this.createMazeVSkew()}\n                        onClickRandomTerrain={() => this.createRandomTerrain()}\n                    />\n                    <VisualizeButton\n                        active={this.state.visualizing}\n                        paused={this.state.paused}\n                        onPause={() => this.pausePathfinding()}\n                        onResume={() => this.resumePathfinding()}\n                        onStartStop={() => this.doPathfinding()}\n                    />\n                    <ClearDropDown\n                        ref={this.clrDropDown}\n                        onClick={() => this.onClickClrDrop()}\n                        onClickTiles={() => this.clearTiles()}\n                        onClickPath={() => this.clearPath()}\n                        onClickReset={() => this.resetBoard()}\n                    />\n                    <TilesDropDown\n                        ref={this.tilesDropDown}\n                        onClick={() => this.onClickTilesDrop()}\n                        onClickTileType={(cost: number) => this.changeTile(cost)}\n                    />\n                    <SettingsButton onClick={() => this.toggleSettings()}/>\n                </TopBar>\n                <PathfindingVisualizer\n                    ref={this.visualizer}\n                    onChangeVisualizing={(viz: boolean) => this.changeButtonActiveState(viz)}\n                    settings={this.state.settings}\n                    tileWidth={this.tileWidth}\n                />\n            </div>\n        );\n    }\n}\n\nfunction isMobile() {\n    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n}\n\nexport default PathfindingApp;","import { SPEED_MIN } from \"../components/panel/SettingPanels\";\n\ninterface AppSettings\n{\n    showArrows: boolean,\n    delayInc: number,\n    algorithm: string,\n    heuristicKey: string,\n    navigatorKey: string,\n    bidirectional: boolean\n}\n\nexport function getDefaultSettings(): AppSettings {\n    return {\n        showArrows: true,\n        delayInc: SPEED_MIN,\n        algorithm: 'a*',\n        heuristicKey: 'manhattan',\n        navigatorKey: 'plus',\n        bidirectional: false\n    }\n}\n\nexport default AppSettings;","/*\n * Copyright (c) Joseph Prichard 2022.\n */\n\nimport React from 'react';\nimport './styles/Grid.scss';\nimport './styles/Panels.scss';\nimport './styles/Navbar.scss';\nimport './styles/Tutorial.scss'\nimport PathfindingApp from './components/PathfindingApp';\n\nclass App extends React.Component\n{\n    render() {\n        return (\n            <PathfindingApp/>\n        );\n    }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n    <React.StrictMode>\n        <App/>\n    </React.StrictMode>,\n    document.getElementById('root')\n);\n"],"sourceRoot":""}