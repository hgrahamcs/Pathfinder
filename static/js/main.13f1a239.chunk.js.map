{"version":3,"sources":["view/navbar/TopBar.tsx","view/navbar/Buttons.tsx","view/navbar/DropDown.tsx","view/navbar/DropDownComponents.tsx","view/utility/DraggablePanel.tsx","view/grid/GridBackground.tsx","pathfinding/core/Components.ts","pathfinding/core/Grid.ts","view/grid/TileFg.tsx","view/grid/SolidFg.tsx","view/web-content/weight.svg","view/grid/WeightFg.tsx","view/grid/GridForeground.tsx","view/grid/StatsPanel.tsx","pathfinding/core/PlusNavigator.ts","pathfinding/core/Navigator.ts","pathfinding/algorithms/Heuristics.ts","pathfinding/structures/Hash.ts","pathfinding/structures/Heap.ts","pathfinding/algorithms/Pathfinder.ts","pathfinding/algorithms/Node.ts","pathfinding/algorithms/AStar.ts","pathfinding/algorithms/BFS.ts","pathfinding/structures/Stack.ts","pathfinding/algorithms/DFS.ts","pathfinding/algorithms/BidirectionalAStar.ts","pathfinding/algorithms/BidirectionalBFS.ts","pathfinding/algorithms/PathfinderBuilder.ts","view/utility/VirtualTimer.ts","pathfinding/algorithms/TerrainGenerator.ts","pathfinding/algorithms/TerrainRandomGenerator.ts","pathfinding/algorithms/TerrainMazeGenerator.ts","pathfinding/algorithms/TerrainGeneratorBuilder.ts","view/grid/PathfindingVisualizer.tsx","view/utility/Checkbox.tsx","view/utility/SteppedRangeSlider.tsx","view/utility/RadioButtonGroup.tsx","view/navbar/SettingPanels.tsx","view/SettingsManager.ts","view/PathfindingSettings.ts","view/web-content/react.png","view/PathfindingApp.tsx","App.tsx","index.tsx"],"names":["TopBar","bar","React","createRef","ref","this","style","width","window","screen","availWidth","className","props","children","Component","SYMBOL_COLOR","DIMENSION","VisualizeButton","height","rx","fill","points","x","active","onMouseDown","e","preventDefault","onClick","paused","onResume","onPause","xmlns","getResumeSymbol","getPauseSymbol","onStartStop","getStopSymbol","SettingsButton","DropDown","setState","up","display","stopPropagation","isHidden","show","hide","state","Clickable","tabIndex","onKeyPress","click","AlgorithmDropDown","text","fade","key","algText","onChange","toggle","nativeEvent","arrowClass","contentStyle","ClearDropDown","onClickPath","onClickTiles","onClickReset","MazeDropDown","onClickMaze","onClickMazeHorizontal","onClickMazeVertical","onClickRandomTerrain","TilesDropDown","cost","onClickTileType","DraggablePanel","draggable","draggableContainer","draggableContent","dragging","prevX","prevY","mouseDown","clientY","clientX","touchStart","touch","touches","changedTouches","mouseUp","mouseMove","drag","touchMove","top","left","document","addEventListener","container","current","offsetTop","offsetLeft","content","innerHeight","innerWidth","offsetHeight","offsetWidth","visibleStyle","minHeight","getPosition","renderDraggable","draggableStyle","onTouchStart","title","onClickXButton","ARROW_COLOR","GridBackground","tilesX","tilesY","visualization","createEmptyBg","arrows","y","row","push","generation","prevState","doGeneration","map","arr","slice","generations","doArrowGeneration","renderTiles","id","markerWidth","markerHeight","refX","refY","orient","renderArrows","tileWidth","offset","i","length","arrow","first","from","second","to","firstX","firstY","secondX","secondY","offsetX","offsetY","x1","y1","x2","y2","stroke","strokeWidth","markerEnd","tiles","point","renderTile","color","backgroundColor","tile","point1","point2","newArrow","a","index","indexOf","splice","createTile","isSolid","pathCost","RectGrid","mutateDefault","solid","mutate","nodes","data","createEmptyGrid","console","str","log","JSON","stringify","grid","mutateTile","get","TileFg","nextProps","prevPoint","nextPoint","size","position","borderColor","SolidFg","doTileAnimation","tileSize","WeightFg","backgroundImage","Weight","opacity","weightOpacity","ARROW_PATH_COLOR","pointsEqual","isControlKey","button","GridForeground","svg","tilePointer","drawing","erasing","draggingInitial","draggingGoal","disable","end","calcEndPointInView","path","initial","goal","Math","round","topMargin","getBoundingClientRect","bounds","getBoundingRect","onPress","onDrag","xCoordinate","yCoordinate","calculatePoint","isEmpty","drawTile","eraseTile","moveInitial","moveGoal","clone","inBounds","canMoveEndPoint","onTilesDragged","floor","renderEndTile","renderPath","onContextMenu","onMouseUp","onMouseMove","onMouseLeave","onEndingEvent","onTouchMoveCapture","onTouchEnd","onTouchCancel","renderTilesTable","lines","renderPathArrow","renderWeightText","fontSize","paddingTop","textAlign","cursor","StatsPanel","textLog","scrollTop","scrollHeight","clientHeight","time","toFixed","algorithm","readOnly","value","unselectable","onDrop","PlusNavigator","getWidth","getHeight","b","manhattan","abs","euclidean","dx","dy","sqrt","octile","SQRT2","min","chebyshev","max","nullHeuristic","HashSet","undefined","HashTable","Heap","compare","elements","siftUp","val","peek","move","pop","siftDown","pos","parent","swap","right","child","reconstructPath","bottomLeaf","reconstructPathReversed","reverse","Pathfinder","navigator","recentSearch","node","Node","AStarNode","g","fScore","AStarPathfinder","func","heuristicFunc","p","getNavigator","getGrid","clearRecentSearch","openFrontier","f","closedSet","openSet","root","add","currentNode","currentPoint","currentKey","remove","addRecent","equals","neighbors","neighbor","neighborPoint","neighborKey","has","stepCost","heuristic","neighborNode","addChild","BFSPathfinder","frontier","visited","shift","next","Stack","DFSPathfinder","BiAStarPathfinder","startOpenFrontier","startOpenSet","endOpenFrontier","endOpenSet","initialRoot","goalRoot","startCurrentNode","startCurrentPointKey","concat","doAStarExpansion","endCurrentNode","endCurrentPointKey","structures","endPoint","BiBFSPathfinder","startVisited","endVisited","startFrontier","endFrontier","doBFSExpansion","CREATE_NAVIGATOR","CREATE_HEURISTIC","CREATE_PATHFINDER","PathfinderBuilder","toLowerCase","Error","createHeuristic","createNavigator","createPathfinder","VirtualTimer","callback","countDown","timeout","timeStarted","timeRemaining","finished","Date","now","setTimeout","clearTimeout","TerrainGenerator","ignore","shouldIgnore","TerrainRandomGenerator","tileData","topLeft","bottomRight","random","draw","getTerrain","divideWidthNoSkew","divideWidthHSkew","divideWidthVSkew","canDrawHole","getMidPoint","range","mid","getRand","TerrainMazeGenerator","slant","divideWidth","getSolid","divide","chamber","widthOf","heightOf","randX","toDraw","edgeBlocked","randY","drawArr","leftChamber","rightChamber","topChamber","bottomChamber","TerrainGeneratorBuilder","type","calcLength","len","calcCost","PathfindingVisualizer","background","foreground","stats","visualized","visualizing","visualTimeouts","mazeTile","clearPath","erasePath","w","outerWidth","h","availHeight","outerHeight","nextState","changeTile","settings","showArrows","visualizeAlg","pause","resume","pathfinder","getPathfinder","findPath","getRecentGenerations","canShowArrows","addArrowGenerations","canShowFrontier","visualizeGenerations","drawPath","clearVisualization","toggleDisable","clear","onChangeVisualizing","promises","expand","baseIncrement","delayInc","delay","visualizeGenerationAndArrows","visualizeGeneration","addArrowGeneration","forEach","promise","Promise","resolve","all","then","algorithmKey","bidirectional","hasBidirectional","makeBidirectional","setAlgorithm","setHeuristic","heuristicKey","setNavigator","navigatorKey","build","t0","performance","t2","getRecentNodes","getAlgorithmName","unshift","doPathfinding","mazeType","clearTiles","newState","prevGrid","generator","setDimensions","setGeneratorType","setIgnorePoints","setTileData","generateTerrain","drawGrid","xEnd","yEnd","xFloor","yFloor","yDecimal","ceil","resetPoints","Checkbox","checked","defaultChecked","disabled","boxStyle","defaultProps","SteppedRangeSlider","default","Number","currentTarget","list","step","sliderStyle","onInput","RadioButtonGroup","Children","toArray","radioButtons","VisualSettings","onChangeViz","onChangeShowArrows","onChangeWOpacity","SpeedSettings","speedText","String","initialSpeed","speed","options","onChangeSpeed","AlgorithmSettings","onChangeBidirectional","HeuristicSettings","onClickManhattan","onClickEuclidean","onClickChebyshev","onClickOctile","SettingsManager","algo","PathfindingApp","visualizer","algDropDown","clrDropDown","mazeDropDown","tilesDropDown","settingsManager","heuristicDisabled","bidirectionalDisabled","arrowsDisabled","panelShow","usesHeuristic","changeAlgo","doDelayedPathfinding","pausePathfinding","resumePathfinding","clearVisualizationChecked","clearTilesChecked","createTerrain","useIcon","mobile","test","userAgent","changeSpeed","hideSettings","changeVisualize","changeShowArrows","changeBidirectional","changeManhattan","changeEuclidean","changeChebyshev","changeOctile","href","alt","src","Icon","onClickAlgDrop","alg","onClickClrDrop","resetBoard","onClickTilesDrop","onClickMazeDrop","createMaze","createMazeHSkew","createMazeVSkew","createRandomTerrain","toggleSettings","viz","changeVButtonColor","App","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.13f1a239.chunk.js","sourcesContent":["import React, {RefObject} from 'react';\r\nimport './Navbar.css'\r\n\r\nclass TopBar extends React.Component\r\n{\r\n    private bar: RefObject<HTMLDivElement> = React.createRef();\r\n\r\n    render() {\r\n        return (\r\n            <div ref={this.bar} style={{\r\n                width: window.screen.availWidth\r\n            }} className='top-navbar'>\r\n                {this.props.children}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default TopBar;","import React from 'react';\r\nimport './Navbar.css'\r\n\r\ninterface VProps {\r\n    active: boolean,\r\n    paused: boolean,\r\n    onStartStop: ()  => void,\r\n    onPause: ()  => void,\r\n    onResume: ()  => void,\r\n}\r\n\r\ninterface ButtonProps {\r\n    onClick: ()  => void\r\n}\r\n\r\nconst SYMBOL_COLOR = 'rgb(230,230,230)';\r\nconst OFFSET = 14;\r\nconst DIMENSION = 47 - 2 * OFFSET;\r\n\r\nexport class VisualizeButton extends React.Component<VProps>\r\n{\r\n    getStopSymbol() {\r\n        return (\r\n            <rect width={DIMENSION}\r\n                  height={DIMENSION}\r\n                  rx={4}\r\n                  fill={SYMBOL_COLOR}\r\n            />\r\n        );\r\n    }\r\n\r\n    getResumeSymbol() {\r\n        const midY = DIMENSION / 2;\r\n        return (\r\n            <polygon\r\n                  points={`${0},${0} ${0},${DIMENSION} ${DIMENSION},${midY}`}\r\n                  className={'track round'}\r\n                  fill={SYMBOL_COLOR}\r\n            />\r\n        );\r\n    }\r\n\r\n    getPauseSymbol() {\r\n        return (\r\n            <svg>\r\n                <rect width={DIMENSION/2.5}\r\n                      height={DIMENSION}\r\n                      rx={3}\r\n                      fill={SYMBOL_COLOR}\r\n                />\r\n                <rect width={DIMENSION/2.5}\r\n                      height={DIMENSION}\r\n                      x={0.2*DIMENSION + DIMENSION/2.5}\r\n                      rx={3}\r\n                      fill={SYMBOL_COLOR}\r\n                />\r\n            </svg>\r\n        );\r\n    }\r\n\r\n    render() {\r\n        if(this.props.active) {\r\n            return (\r\n                <div className={'half-button-wrapper'}>\r\n                    <button onMouseDown={e => e.preventDefault()}\r\n                            className={'center half-button-left red-button half-viz-button'}\r\n                            onClick={this.props.paused ? this.props.onResume : this.props.onPause}\r\n                    >\r\n                        <svg xmlns='http://www.w3.org/2000/svg'\r\n                             className='svg-icon'\r\n                             width={DIMENSION}\r\n                             height={DIMENSION}\r\n                        >\r\n                            {this.props.paused ? this.getResumeSymbol() : this.getPauseSymbol()}\r\n                        </svg>\r\n                    </button>\r\n                    <button onMouseDown={e => e.preventDefault()}\r\n                            className={'center half-button-right red-button half-viz-button'}\r\n                            onClick={this.props.onStartStop}\r\n                    >\r\n                        <svg xmlns='http://www.w3.org/2000/svg'\r\n                             className='svg-icon'\r\n                             width={DIMENSION}\r\n                             height={DIMENSION}\r\n                        >\r\n                            {this.getStopSymbol()}\r\n                        </svg>\r\n                    </button>\r\n                </div>\r\n            );\r\n        } else {\r\n            return (\r\n                <button onMouseDown={e => e.preventDefault()}\r\n                        className={'button green-button viz-button'}\r\n                        onClick={this.props.onStartStop}\r\n                >\r\n                    Visualize!\r\n                </button>\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\nexport class SettingsButton extends React.Component<ButtonProps>\r\n{\r\n    render() {\r\n        return (\r\n            <button onMouseDown={e => e.preventDefault()}\r\n                    className='button settings-button'\r\n                    onClick={this.props.onClick}>\r\n                Settings\r\n            </button>\r\n        );\r\n    }\r\n}","import React from 'react';\r\n\r\nexport interface DropDownProps {\r\n    onClick: () => void,\r\n}\r\n\r\nexport interface DropDownState {\r\n    up: boolean,\r\n    display: string,\r\n    fade: string\r\n}\r\n\r\nabstract class DropDown<IProps extends DropDownProps, IState extends DropDownState>\r\n    extends React.Component<IProps, IState>\r\n{\r\n    protected constructor(props: IProps) {\r\n        super(props);\r\n    }\r\n\r\n    show() {\r\n        this.setState({\r\n            up: false,\r\n            display: 'block',\r\n        });\r\n    }\r\n\r\n    hide() {\r\n        this.setState({\r\n            display: 'none',\r\n            up: true,\r\n        });\r\n    }\r\n\r\n    toggle(e: Event) {\r\n        e.stopPropagation();\r\n        this.props.onClick();\r\n        if(this.isHidden()) {\r\n            this.show();\r\n        } else {\r\n            this.hide();\r\n        }\r\n    }\r\n\r\n    isHidden() {\r\n        return this.state.display === 'none';\r\n    }\r\n\r\n    contentStyle() {\r\n        return {\r\n            display: this.state.display\r\n        }\r\n    }\r\n}\r\n\r\nexport default DropDown;","import React from 'react';\r\nimport './Navbar.css'\r\nimport DropDown, {DropDownProps, DropDownState} from './DropDown';\r\n\r\ninterface AlgProps extends DropDownProps {\r\n    onChange: (alg: string) => void\r\n}\r\n\r\ninterface DropDownTextState extends DropDownState {\r\n    text: string,\r\n}\r\n\r\ninterface ClrProps extends DropDownProps {\r\n    onClickPath: () => void,\r\n    onClickTiles: () => void,\r\n    onClickReset: () => void;\r\n}\r\n\r\ninterface MazeProps extends DropDownProps {\r\n    onClickMaze: () => void,\r\n    onClickMazeHorizontal: () => void,\r\n    onClickMazeVertical: () => void,\r\n    onClickRandomTerrain: () => void\r\n}\r\n\r\ninterface TileProps extends DropDownProps {\r\n    onClickTileType: (cost: number) => void\r\n}\r\n\r\ninterface ClickableProps {\r\n    click: () => void;\r\n}\r\n\r\nclass Clickable extends React.Component<ClickableProps>\r\n{\r\n    render() {\r\n        return (\r\n            <div tabIndex={0} onKeyPress={this.props.click} onClick={this.props.click}>{this.props.children}</div>\r\n        )\r\n    }\r\n}\r\n\r\nexport class AlgorithmDropDown extends DropDown<AlgProps, DropDownTextState>\r\n{\r\n    constructor(props: AlgProps) {\r\n        super(props);\r\n        this.state = {\r\n            up: true,\r\n            display: 'none',\r\n            text: 'A* Search',\r\n            fade: 'fade-in'\r\n        };\r\n    }\r\n\r\n    onChange(key: string, algText: string) {\r\n        this.props.onChange(key);\r\n        this.setState({\r\n            text: algText\r\n        });\r\n    }\r\n\r\n    arrowClass() {\r\n        return this.state.up ? 'arrowUp' : 'arrowDown';\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div tabIndex={0} className='alg-drop-down drop-down'\r\n                 onMouseDown={e => e.preventDefault()}\r\n                 onKeyPress={(e) => this.toggle(e.nativeEvent)}\r\n                 onClick={(e) => this.toggle(e.nativeEvent)}\r\n            >\r\n                <div className='alg-drop-down-button drop-down-button'>\r\n                    <span className='alg-drop-down-text drop-down-text'>{this.state.text}</span>\r\n                    <span className={'alg-arr ' + this.arrowClass()}/>\r\n                </div>\r\n                <div style={this.contentStyle()}\r\n                     className={this.state.fade + ' alg-drop-down-content drop-down-content'}\r\n                >\r\n                    <Clickable click={() => this.onChange('a*', 'A* Search')}>A* Search</Clickable>\r\n                    <Clickable click={() => this.onChange('dijkstra', 'Dijkstra')}>Dijkstra's Algorithm</Clickable>\r\n                    <Clickable click={() => this.onChange('best-first', 'Best First')}>Best First Search</Clickable>\r\n                    <Clickable click={() => this.onChange('bfs', 'Breadth First')}>Breadth First Search</Clickable>\r\n                    <Clickable click={() => this.onChange('dfs', 'Depth First')}>Depth First Search</Clickable>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class ClearDropDown extends DropDown<ClrProps, DropDownState>\r\n{\r\n    constructor(props: ClrProps) {\r\n        super(props);\r\n        this.state = {\r\n            up: true,\r\n            display: 'none',\r\n            fade: 'fade-in'\r\n        };\r\n    }\r\n\r\n    arrowClass() {\r\n        return this.state.up ? 'arrowUpW' : 'arrowDownW';\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div tabIndex={0} className='clr-drop-down drop-down'\r\n                 onMouseDown={e => e.preventDefault()}\r\n                 onKeyPress={(e) => this.toggle(e.nativeEvent)}\r\n                 onClick={(e) => this.toggle(e.nativeEvent)}\r\n            >\r\n                <div className='clr-drop-down-button drop-down-button'>\r\n                    <span className='clr-drop-down-text drop-down-text'>Reset</span>\r\n                    <span className={'clr-arr ' + this.arrowClass()}/>\r\n                </div>\r\n                <div style={this.contentStyle()}\r\n                     className={this.state.fade + ' clr-drop-down-content drop-down-content'}\r\n                >\r\n                    <Clickable click={this.props.onClickPath}>Clear Path</Clickable>\r\n                    <Clickable click={this.props.onClickTiles}>Clear Tiles</Clickable>\r\n                    <Clickable click={this.props.onClickReset}>Reset Grid</Clickable>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class MazeDropDown extends DropDown<MazeProps, DropDownState>\r\n{\r\n    constructor(props: MazeProps) {\r\n        super(props);\r\n        this.state = {\r\n            up: true,\r\n            display: 'none',\r\n            fade: 'fade-in'\r\n        };\r\n    }\r\n\r\n    arrowClass() {\r\n        return this.state.up ? 'arrowUpW' : 'arrowDownW';\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div tabIndex={0} className='maze-drop-down drop-down'\r\n                 onMouseDown={e => e.preventDefault()}\r\n                 onKeyPress={(e) => this.toggle(e.nativeEvent)}\r\n                 onClick={(e) => this.toggle(e.nativeEvent)}\r\n            >\r\n                <div className='maze-drop-down-button drop-down-button'>\r\n                    <span className='maze-drop-down-text drop-down-text'>Terrain</span>\r\n                    <span className={'clr-arr ' + this.arrowClass()}/>\r\n                </div>\r\n                <div style={this.contentStyle()}\r\n                     className={this.state.fade + ' maze-drop-down-content drop-down-content'}\r\n                >\r\n                    <Clickable click={this.props.onClickMaze}>Recursive Maze Division</Clickable>\r\n                    <Clickable click={this.props.onClickMazeHorizontal}>Horizontal Skewed Maze</Clickable>\r\n                    <Clickable click={this.props.onClickMazeVertical}>Vertical Skewed Maze</Clickable>\r\n                    <Clickable click={this.props.onClickRandomTerrain}>Random Terrain</Clickable>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class TilesDropDown extends DropDown<TileProps, DropDownTextState>\r\n{\r\n    constructor(props: TileProps) {\r\n        super(props);\r\n        this.state = {\r\n            up: true,\r\n            display: 'none',\r\n            fade: 'fade-in',\r\n            text: 'Wall []'\r\n        };\r\n    }\r\n\r\n    arrowClass() {\r\n        return this.state.up ? 'arrowUpW' : 'arrowDownW';\r\n    }\r\n\r\n    onChange(cost: number, text: string) {\r\n        this.props.onClickTileType(cost);\r\n        this.setState({\r\n            text: text\r\n        }, () => this.props.onClickTileType(cost));\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div tabIndex={0} className='tiles-drop-down drop-down'\r\n                 onMouseDown={e => e.preventDefault()}\r\n                 onKeyPress={(e) => this.toggle(e.nativeEvent)}\r\n                 onClick={(e) => this.toggle(e.nativeEvent)}\r\n            >\r\n                <div className='tiles-drop-down-button drop-down-button'>\r\n                    <span className='tiles-drop-down-text drop-down-text'>{this.state.text}</span>\r\n                    <span className={'clr-arr ' + this.arrowClass()}/>\r\n                </div>\r\n                <div style={this.contentStyle()}\r\n                     className={this.state.fade + ' tiles-drop-down-content drop-down-content'}\r\n                >\r\n                    <Clickable click={() => this.onChange(-1, 'Wall []')}>Wall []</Clickable>\r\n                    <Clickable click={() => this.onChange(2, 'Weight [2]')}>Weight [2]</Clickable>\r\n                    <Clickable click={() => this.onChange(3, 'Weight [3]')}>Weight [3]</Clickable>\r\n                    <Clickable click={() => this.onChange(5, 'Weight [5]')}>Weight [5]</Clickable>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}","import React, {RefObject} from 'react';\r\nimport './DraggablePanel.css'\r\n\r\ninterface IProps {\r\n    title: string,\r\n    show: boolean,\r\n    onClickXButton: () => void,\r\n    width: number,\r\n    height: number\r\n}\r\n\r\ninterface IState {\r\n    top: number,\r\n    left: number\r\n}\r\n\r\nclass DraggablePanel extends React.Component<IProps, IState>\r\n{\r\n    //refs are used to access native DOM\r\n    private draggable: RefObject<HTMLDivElement> = React.createRef();\r\n    private draggableContainer: RefObject<HTMLDivElement> = React.createRef();\r\n    private draggableContent: RefObject<HTMLDivElement> = React.createRef();\r\n\r\n    //stores previous mouse location and drag\r\n    private dragging = false;\r\n    private prevX = 0;\r\n    private prevY = 0;\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.state = {\r\n            top: -1,\r\n            left: -1\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n        //mouse\r\n        document.addEventListener('mouseup', e => {\r\n            this.mouseUp(e);\r\n        });\r\n        document.addEventListener('mousemove', e => {\r\n            this.mouseMove(e);\r\n        });\r\n        window.addEventListener('mouseleave', e => {\r\n            this.mouseUp(e);\r\n        });\r\n        //touch\r\n        document.addEventListener('touchend', () => {\r\n            this.dragging = false;\r\n        });\r\n        document.addEventListener('touchmove', e => {\r\n            this.touchMove(e);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Start drag and init prev mouse location when mouse is clicked on draggable\r\n     * @param e\r\n     */\r\n    mouseDown = (e: MouseEvent) => {\r\n        e.preventDefault();\r\n        this.prevY = e.clientY;\r\n        this.prevX = e.clientX;\r\n        this.dragging = true;\r\n    }\r\n\r\n    /**\r\n     * Start drag and init prev touch location when finger is clicked on draggable\r\n     * @param e\r\n     */\r\n    touchStart = (e: TouchEvent) => {\r\n        const touch = e.touches[0] || e.changedTouches[0];\r\n        this.prevY = touch.clientY;\r\n        this.prevX = touch.clientX;\r\n        this.dragging = true;\r\n    }\r\n\r\n    /**\r\n     * Called when mouse is risen on document stop drag\r\n     * @param e\r\n     */\r\n    mouseUp = (e: Event) => {\r\n        e.preventDefault();\r\n        this.dragging = false;\r\n    }\r\n\r\n    /**\r\n     * Called when the mouse is moved over the document to calculate the new position of\r\n     * the draggable canvas\r\n     * @param e\r\n     */\r\n    mouseMove = (e: MouseEvent) => {\r\n        this.drag(e.clientX, e.clientY);\r\n    }\r\n\r\n    /**\r\n     * Called when the touch is moved over the document to calculate the new position of\r\n     * the draggable canvas\r\n     * @param e\r\n     */\r\n    touchMove = (e: TouchEvent) => {\r\n        const touch = e.touches[0] || e.changedTouches[0];\r\n        this.drag(touch.clientX, touch.clientY);\r\n    }\r\n\r\n    /**\r\n     * Called when user drags over the document to move the panel\r\n     * @param clientX\r\n     * @param clientY\r\n     */\r\n    drag(clientX: number, clientY: number) {\r\n        if(this.dragging) {\r\n            const container = this.draggableContainer.current!;\r\n            let top = (container.offsetTop - (this.prevY - clientY))\r\n            let left = (container.offsetLeft - (this.prevX - clientX));\r\n            const content = this.draggableContent.current!;\r\n            const draggable = this.draggable.current!;\r\n            //stop drag if mouse goes out of bounds\r\n            if(clientY < 0 || clientY > window.innerHeight\r\n                || clientX < 0 || clientX > window.innerWidth) {\r\n                this.dragging = false;\r\n            }\r\n            //check if position is out of bounds and prevent the panel from being dragged there\r\n            if(top < 0) {\r\n                top = 0;\r\n            } else if (top > window.innerHeight - draggable.offsetHeight) {\r\n                top = window.innerHeight - draggable.offsetHeight;\r\n            }\r\n            if(left < -content.offsetWidth/2) {\r\n                left = -content.offsetWidth/2;\r\n            } else if(left > window.innerWidth - content.offsetWidth/2) {\r\n                left = window.innerWidth - content.offsetWidth/2;\r\n            }\r\n            //set new position\r\n            this.setState({\r\n                top: top\r\n            });\r\n            this.setState({\r\n                left: left\r\n            });\r\n            //update previous pos\r\n            this.prevY = clientY;\r\n            this.prevX = clientX;\r\n        }\r\n    }\r\n\r\n    getPosition() {\r\n        const left = this.state.left;\r\n        const top = this.state.top;\r\n        if(left === -1 || top === -1) {\r\n            return {};\r\n        }\r\n        return {\r\n            left: left + 'px',\r\n            top: top + 'px',\r\n        };\r\n    }\r\n\r\n    visibleStyle()  {\r\n        return this.props.show ? 'block' : 'none';\r\n    }\r\n\r\n    draggableStyle() {\r\n        return {\r\n            width: this.props.width,\r\n            display: this.visibleStyle()\r\n        }\r\n    }\r\n\r\n    contentStyle() {\r\n        return {\r\n            width: this.props.width,\r\n            minHeight: this.props.height,\r\n            display: this.visibleStyle()\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div ref={this.draggableContainer} className='draggable-container' style={this.getPosition()}>\r\n                {this.renderDraggable()}\r\n                <div ref={this.draggableContent} style={this.contentStyle()} className='draggable-content'>\r\n                    <div className='settings-general'>\r\n                        {this.props.children}\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    renderDraggable() {\r\n        return (\r\n            <div style={this.draggableStyle()} className='draggable'\r\n                 ref={this.draggable}\r\n                 onMouseDown={e => this.mouseDown(e.nativeEvent)}\r\n                 onTouchStart={e => this.touchStart(e.nativeEvent)}\r\n            >\r\n                <div className='draggable-title'>{this.props.title}</div>\r\n                <div className='x-button' tabIndex={0}\r\n                     onKeyPress={this.props.onClickXButton}\r\n                     onClick={this.props.onClickXButton}\r\n                     onMouseDown={e => {\r\n                         e.stopPropagation();\r\n                         e.preventDefault();\r\n                     }}\r\n                >\r\n                    <div className='x-text'>\r\n                        X\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default DraggablePanel;","import React from 'react';\r\nimport './Grid.css';\r\nimport {Node} from '../../pathfinding/algorithms/Node';\r\nimport {Point} from '../../pathfinding/core/Components';\r\n\r\ninterface Arrow {\r\n    to: Point,\r\n    from: Point\r\n}\r\n\r\ninterface IProps {\r\n    tileWidth: number,\r\n    tilesX: number,\r\n    tilesY: number\r\n}\r\n\r\ninterface IState {\r\n    visualization: string[][],\r\n    arrows: Arrow[]\r\n}\r\n\r\nconst CLOSED_NODE = 'rgb(198, 237, 238)';\r\nconst OPEN_NODE = 'rgb(191, 248, 159)';\r\nconst EMPTY_NODE = 'white';\r\nconst ARROW_COLOR = 'rgb(153,153,153)';\r\n\r\nconst BASE_WIDTH = 27;\r\n\r\nclass GridBackground extends React.Component<IProps,IState>\r\n{\r\n    private readonly width: number;\r\n    private readonly height: number;\r\n\r\n    /**\r\n     * Constructs a GridBackground with immutable height and width\r\n     * @param props\r\n     */\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.width = this.props.tilesX;\r\n        this.height = this.props.tilesY;\r\n        this.state = {\r\n            visualization: this.createEmptyBg(),\r\n            arrows: []\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new empty visualization canvas\r\n     */\r\n    createEmptyBg() {\r\n        const visualization = [];\r\n        for(let y = 0; y < this.height; y++) {\r\n            const row: string[] = [];\r\n            for(let x = 0; x < this.width; x++) {\r\n                row.push(EMPTY_NODE);\r\n            }\r\n            visualization.push(row);\r\n        }\r\n        return visualization;\r\n    }\r\n\r\n    /**\r\n     * Clear the visualization canvas and update UI\r\n     */\r\n    clear() {\r\n        this.setState({\r\n            visualization: this.createEmptyBg(),\r\n            arrows: []\r\n        })\r\n    }\r\n\r\n    /**\r\n     * Perform a generation on a visualization array\r\n     * @param generation\r\n     * @param visualization\r\n     */\r\n    static doGeneration(generation: Node, visualization: string[][]) {\r\n        for(const node of generation.children) {\r\n            const point = node.tile.point;\r\n            visualization[point.y][point.x] = OPEN_NODE;\r\n        }\r\n        const point = generation.tile.point;\r\n        visualization[point.y][point.x] = CLOSED_NODE;\r\n        return visualization;\r\n    }\r\n\r\n    /**\r\n     * Visualize generation and update UI\r\n     * @param generation\r\n     */\r\n    visualizeGeneration(generation: Node) {\r\n        this.setState(prevState => ({\r\n            visualization: GridBackground.doGeneration(\r\n                generation,\r\n                prevState.visualization.map(\r\n                    (arr) => arr.slice()\r\n                )\r\n            )\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Visualize generation array and update UI\r\n     * @param generations\r\n     */\r\n    visualizeGenerations(generations: Node[]) {\r\n        const visualization = this.createEmptyBg();\r\n        for(const generation of generations) {\r\n            GridBackground.doGeneration(generation, visualization);\r\n        }\r\n        this.setState({\r\n            visualization: visualization\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Perform an arrow generation on an arrow array\r\n     * @param generation\r\n     * @param arrows\r\n     */\r\n    static doArrowGeneration(generation: Node, arrows: Arrow[]) {\r\n        const point = generation.tile.point;\r\n        for(const node of generation.children) {\r\n            const childPoint = node.tile.point;\r\n            const newArrow = {\r\n                from: point,\r\n                to: childPoint,\r\n            };\r\n            //remove a duplicate arrow to indicate replacement\r\n            //in A* for example, we could have re-discovered a better path to a tile\r\n            for(let i = 0; i < arrows.length; i++) {\r\n                const a = arrows[i];\r\n                if(pointsEqual(a.to, newArrow.to)) {\r\n                    const index = arrows.indexOf(a);\r\n                    arrows.splice(index, 1);\r\n                    i--;\r\n                }\r\n            }\r\n            arrows.push(newArrow);\r\n        }\r\n        return arrows;\r\n    }\r\n\r\n    /**\r\n     * Add arrow generation without updating UI\r\n     * @param generation\r\n     */\r\n    addArrowGeneration(generation: Node) {\r\n        this.setState(prevState => ({\r\n            arrows: GridBackground.doArrowGeneration(\r\n                generation,\r\n                prevState.arrows.slice()\r\n            )\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Add arrow generations and update UI\r\n     * @param generations\r\n     */\r\n    addArrowGenerations(generations: Node[]) {\r\n        const arrows: Arrow[] = [];\r\n        for(const generation of generations) {\r\n            GridBackground.doArrowGeneration(generation, arrows)\r\n        }\r\n        this.setState({\r\n            arrows: arrows\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Visualize both generation and arrows and update UI\r\n     * @param generation\r\n     */\r\n    visualizeGenerationAndArrows(generation: Node) {\r\n        this.setState(prevState => ({\r\n            visualization: GridBackground.doGeneration(\r\n                generation,\r\n                prevState.visualization.map(\r\n                    (arr) => arr.slice()\r\n                )\r\n            ),\r\n            arrows: GridBackground.doArrowGeneration(\r\n                generation,\r\n                prevState.arrows.slice()\r\n            )\r\n        }));\r\n    }\r\n\r\n    render() {\r\n        // console.timeEnd('time');\r\n        // console.time('time');\r\n        return (\r\n            <div>\r\n                <div className='bg'>\r\n                    {this.renderTiles()}\r\n                </div>\r\n                <svg xmlns='http://www.w3.org/2000/svg' className='bg-grid'>\r\n                    <defs>\r\n                        <marker id='arrowhead' markerWidth='3' markerHeight='3'\r\n                                refX='0' refY='1.5' orient='auto'\r\n                                fill={ARROW_COLOR}\r\n                        >\r\n                            <polygon points='0 0, 3 1.5, 0 3'/>\r\n                        </marker>\r\n                    </defs>\r\n                    {this.renderArrows()}\r\n                </svg>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    renderArrows() {\r\n        const width = this.props.tileWidth;\r\n        const offset = width/2;\r\n        const arrows: JSX.Element[] = [];\r\n        for(let i = 0; i < this.state.arrows.length; i++) {\r\n            //calculate arrow position and dimensions\r\n            const arrow = this.state.arrows[i];\r\n            const first = arrow.from;\r\n            const second = arrow.to;\r\n            const firstX = first.x * width;\r\n            const firstY = first.y * width;\r\n            const secondX = second.x * width;\r\n            const secondY = second.y * width;\r\n            const offsetX = (secondX - firstX)/4;\r\n            const offsetY = (secondY - firstY)/4;\r\n            arrows.push(<line key={'arrow ' + i}\r\n                              x1={firstX + offset + offsetX}\r\n                              y1={firstY + offset + offsetY}\r\n                              x2={secondX + offset - offsetX}\r\n                              y2={secondY + offset - offsetY}\r\n                              stroke={ARROW_COLOR}\r\n                              strokeWidth={2 * this.props.tileWidth/BASE_WIDTH}\r\n                              className='line-arrow'\r\n                              markerEnd='url(#arrowhead)' />);\r\n        }\r\n        return arrows;\r\n    }\r\n\r\n    renderTiles() {\r\n        const tiles: JSX.Element[][] = [];\r\n        for(let y = 0; y < this.height; y++) {\r\n            const row: JSX.Element[] = [];\r\n            for(let x = 0; x < this.width; x++) {\r\n                const point = {\r\n                    x: x, y: y\r\n                };\r\n                row.push(\r\n                    this.renderTile(point, this.state.visualization[point.y][point.x])\r\n                );\r\n            }\r\n            tiles.push(row);\r\n        }\r\n        return tiles;\r\n    }\r\n\r\n    renderTile(point: Point, color: string) {\r\n        const width = this.props.tileWidth;\r\n        const top = point.y * this.props.tileWidth;\r\n        const left = point.x * this.props.tileWidth;\r\n        const style = {\r\n            backgroundColor: color,\r\n            width: width + 'px',\r\n            height: width + 'px',\r\n            top: top,\r\n            left: left\r\n        };\r\n        return (\r\n            <div key={point.x + ',' + point.y} style={style} className='tile'/>\r\n        );\r\n    }\r\n}\r\n\r\nfunction pointsEqual(point1: Point, point2: Point) {\r\n    return point1.x === point2.x && point1.y === point2.y;\r\n}\r\n\r\nexport default GridBackground;","/**\r\n * Represents a point in 2d space\r\n * Immutable\r\n */\r\nexport interface Point\r\n{\r\n    readonly x: number;\r\n    readonly y: number;\r\n}\r\n\r\n/**\r\n * Represents the data inside a tile\r\n * Solid tiles cannot be passed while non solid ones can\r\n * pathCost stores how expensive it is to travel to the tile if it isn't solid\r\n * Immutable\r\n */\r\nexport interface TileData\r\n{\r\n    readonly pathCost: number;\r\n    readonly isSolid: boolean;\r\n}\r\n\r\n/**\r\n * Represents a tile on the Grid\r\n */\r\nexport interface Tile\r\n{\r\n    data: TileData;\r\n    readonly point: Point;\r\n}\r\n\r\n/**\r\n * Simple function to create a solid tile with path cost of 1\r\n * @param isSolid\r\n */\r\nexport function createTile(isSolid: boolean) {\r\n    return {\r\n        pathCost: 1,\r\n        isSolid: isSolid\r\n    }\r\n}\r\n\r\n","import {createTile, Point, Tile, TileData} from './Components';\r\n\r\nexport interface Grid\r\n{\r\n    getWidth(): number;\r\n    getHeight(): number;\r\n    inBounds(point: Point): boolean;\r\n    get(point: Point): Tile;\r\n    isSolid(point: Point): boolean;\r\n    mutate(point: Point, data: TileData): void;\r\n    mutateTile(tile: Tile): void;\r\n    mutateDefault(point: Point, solid: boolean): void;\r\n    output(console: Console): void;\r\n    getJson(): string;\r\n    walkable(point: Point): boolean;\r\n    isEmpty(point: Point): boolean;\r\n    clone(): Grid;\r\n}\r\n\r\n/**\r\n * A square grid system that stores nodes in a matrix\r\n * Uses an x,y system where x corresponds to column of the matrix,\r\n * and y corresponds to the row of the matrix\r\n * TileData.ts should be treated like graph nodes\r\n */\r\nclass RectGrid implements Grid\r\n{\r\n    private readonly tiles: Tile[][];\r\n    private readonly width: number;\r\n    private readonly height: number;\r\n\r\n    /**\r\n     * Constructs a grid either with empty or predefined tiles\r\n     * @param width of the grid\r\n     * @param height of grid\r\n     * will perform a defensive copy to the grid\r\n     */\r\n    constructor(width: number, height: number) {\r\n        this.width = width;\r\n        this.height = height;\r\n        this.tiles = createEmptyGrid(width, height);\r\n    }\r\n\r\n    getWidth() {\r\n        return this.width;\r\n    }\r\n\r\n    getHeight() {\r\n        return this.height;\r\n    }\r\n\r\n    /**\r\n     * Checks if a given point is in bounds\r\n     * Other functions assume arguments are in bounds, this should be used\r\n     * if there is reasonable doubt about whether a point is in bounds\r\n     * @param point, to check\r\n     */\r\n    inBounds(point: Point) {\r\n        return point.x >= 0 && point.x < this.width && point.y >= 0 && point.y < this.height;\r\n    }\r\n\r\n    /**\r\n     * Retrieves a defensive tile for a position\r\n     * Defensive copy prevents this object from being mutated without calling\r\n     * a mutate function\r\n     * @param point, point to get\r\n     */\r\n    get(point: Point): Tile {\r\n        return {\r\n            point: this.tiles[point.y][point.x].point,\r\n            data: this.tiles[point.y][point.x].data\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Mutates a position's tile to solid or non solid\r\n     * @param point, point to mutate\r\n     * @param data to mutate to\r\n     */\r\n    mutate(point: Point, data: TileData) {\r\n        this.tiles[point.y][point.x].data = data;\r\n    }\r\n\r\n    /**\r\n     * Mutates a a tile by point\r\n     * @param tile to mutate\r\n     */\r\n    mutateTile(tile: Tile) {\r\n        this.tiles[tile.point.y][tile.point.x].data = tile.data;\r\n    }\r\n\r\n    /**\r\n     * Mutate tile at point\r\n     * @param point to mutate at\r\n     * @param solid to determine what default tile to create\r\n     */\r\n    mutateDefault = (point: Point, solid: boolean) => {\r\n        this.mutate(\r\n            point, createTile(solid)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Outputs the grid to a console\r\n     * @param console\r\n     */\r\n    output(console: Console) {\r\n        for(let y = 0; y < this.height; y++) {\r\n            let str = '';\r\n            for(let x = 0; x < this.width; x++) {\r\n                str += this.tiles[y][x].data.isSolid + ', ';\r\n            }\r\n            console.log(str);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns json of tiles\r\n     */\r\n    getJson() {\r\n        return JSON.stringify(this.tiles);\r\n    }\r\n\r\n    /**\r\n     * Determines if a tile can be walked on\r\n     * @param point\r\n     */\r\n    walkable(point: Point) {\r\n        return !this.tiles[point.y][point.x].data.isSolid;\r\n    }\r\n\r\n    /**\r\n     * Determines if a tile isSolid\r\n     * @param point\r\n     */\r\n    isSolid(point: Point) {\r\n        return this.tiles[point.y][point.x].data.isSolid;\r\n    }\r\n\r\n    /**\r\n     * Determines if a tile is \"empty\"\r\n     *  Meaning it isn't solid and it has a pathCost of 1\r\n     * @param point\r\n     */\r\n    isEmpty(point: Point): boolean {\r\n        const data = this.tiles[point.y][point.x].data;\r\n        return data.pathCost === 1 && !data.isSolid\r\n    }\r\n\r\n    clone(): Grid {\r\n        const grid = new RectGrid(this.width, this.height);\r\n        for(let y = 0; y < grid.height; y++) {\r\n            for(let x = 0; x < grid.width; x++) {\r\n                const point = {\r\n                    x: x, y: y\r\n                }\r\n                grid.mutateTile(this.get(point));\r\n            }\r\n        }\r\n        return grid;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a 2d matrix of empty nodes\r\n */\r\nfunction createEmptyGrid(width: number, height: number) {\r\n    const nodes: Tile[][] = [];\r\n    for(let y = 0; y < height; y++) {\r\n        const row: Tile[] = [];\r\n        for(let x = 0; x < width; x++) {\r\n            row.push({\r\n                point: {\r\n                    x: x, y: y\r\n                },\r\n                data: createTile(false)\r\n            });\r\n        }\r\n        nodes.push(row);\r\n    }\r\n    return nodes;\r\n}\r\n\r\nexport default RectGrid;","import React from 'react';\r\nimport './Grid.css';\r\nimport {Point} from '../../pathfinding/core/Components';\r\n\r\ninterface TileProps {\r\n    tileWidth: number,\r\n    point: Point,\r\n    color: string,\r\n}\r\n\r\nclass TileFg extends React.Component<TileProps>\r\n{\r\n    shouldComponentUpdate(nextProps: Readonly<TileProps>) {\r\n        const prevPoint = this.props.point;\r\n        const nextPoint = nextProps.point;\r\n        return prevPoint.y !== nextPoint.y ||\r\n            prevPoint.x !== nextPoint.x;\r\n    }\r\n\r\n    render() {\r\n        const size = this.props.tileWidth\r\n        const top = this.props.point.y * this.props.tileWidth;\r\n        const left = this.props.point.x * this.props.tileWidth;\r\n        return (\r\n            <div style={{\r\n                position: 'absolute',\r\n                width: size,\r\n                height: size,\r\n                top: top,\r\n                left: left,\r\n                backgroundColor: this.props.color,\r\n                display: 'block',\r\n                borderColor: this.props.color\r\n            }} className={'svg-tile tile-fg'}/>\r\n        );\r\n    }\r\n}\r\n\r\nexport default TileFg;","import {Point} from '../../pathfinding/core/Components';\r\nimport React from 'react';\r\n\r\ninterface SolidProps {\r\n    tileSize: number,\r\n    point: Point,\r\n    doTileAnimation: boolean\r\n}\r\n\r\nclass SolidFg extends React.Component<SolidProps>\r\n{\r\n    private readonly doTileAnimation: boolean;\r\n\r\n    constructor(props: SolidProps) {\r\n        super(props)\r\n        this.doTileAnimation = this.props.doTileAnimation;\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div\r\n                style={{\r\n                    position: 'absolute',\r\n                    left: this.props.point.x * this.props.tileSize,\r\n                    top: this.props.point.y * this.props.tileSize,\r\n                    width: this.props.tileSize,\r\n                    height: this.props.tileSize\r\n                }}\r\n                className={this.doTileAnimation ? 'solid-animation' : 'solid'}\r\n            />\r\n        );\r\n    }\r\n}\r\n\r\nexport default SolidFg;","export default __webpack_public_path__ + \"static/media/weight.cae5804e.svg\";","import {Point} from '../../pathfinding/core/Components';\r\nimport React from 'react';\r\nimport Weight from '../web-content/weight.svg';\r\n\r\ninterface WeightProps {\r\n    tileSize: number,\r\n    point: Point,\r\n    doTileAnimation: boolean,\r\n    weightOpacity: number\r\n}\r\n\r\nclass WeightFg extends React.Component<WeightProps>\r\n{\r\n    private readonly doTileAnimation: boolean;\r\n\r\n    constructor(props: WeightProps) {\r\n        super(props)\r\n        this.doTileAnimation = this.props.doTileAnimation;\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div style={{\r\n                left: this.props.point.x * this.props.tileSize,\r\n                top: this.props.point.y * this.props.tileSize,\r\n                width: this.props.tileSize,\r\n                height: this.props.tileSize,\r\n                backgroundImage: `url(${Weight})`,\r\n                opacity: this.props.weightOpacity,\r\n                position: 'absolute'\r\n            }}\r\n                 className={this.doTileAnimation ? 'weight-animation' : 'weight'}\r\n            />\r\n        );\r\n    }\r\n}\r\n\r\nexport default WeightFg;","import React, {RefObject} from 'react';\r\nimport './Grid.css';\r\nimport {createTile, Point, Tile, TileData} from '../../pathfinding/core/Components';\r\nimport RectGrid, {Grid} from '../../pathfinding/core/Grid';\r\nimport TileFg from './TileFg';\r\nimport SolidFg from './SolidFg';\r\nimport WeightFg from './WeightFg';\r\n\r\ninterface IProps {\r\n    tileSize: number,\r\n    tilesX: number,\r\n    tilesY: number,\r\n    onTilesDragged: () => void,\r\n    topMargin: number,\r\n    weightOpacity: number\r\n}\r\n\r\ninterface IState {\r\n    grid: Grid,\r\n    initial: Point,\r\n    goal: Point,\r\n    path: Tile[]\r\n}\r\n\r\nconst INITIAL_COLOR = 'rgb(131, 217, 52)';\r\nconst GOAL_COLOR = 'rgb(203, 75, 14)';\r\nconst ARROW_PATH_COLOR = 'rgb(73, 79, 250)';\r\n\r\nconst BASE_WIDTH = 27;\r\n\r\nclass GridForeground extends React.Component<IProps,IState>\r\n{\r\n    private svg: RefObject<SVGSVGElement> = React.createRef();\r\n\r\n    private tilePointer: TileData;\r\n\r\n    private drawing: boolean = false;\r\n    private erasing: boolean = false;\r\n    private draggingInitial: boolean = false;\r\n    private draggingGoal: boolean = false;\r\n    private disable: boolean = false;\r\n\r\n    private doTileAnimation: boolean = true;\r\n\r\n    private readonly width: number;\r\n    private readonly height: number;\r\n\r\n    /**\r\n     * Constructs a GridForeground with immutable height and width\r\n     * @param props\r\n     */\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.width = this.props.tilesX;\r\n        this.height = this.props.tilesY;\r\n        const end = this.calcEndPointInView();\r\n        this.tilePointer = createTile(true);\r\n        this.state = {\r\n            grid: new RectGrid(this.width, this.height),\r\n            path: [],\r\n            initial: {\r\n                x: ((end.x)/3) >> 0,\r\n                y: ((end.y)/3) >> 0\r\n            },\r\n            goal: {\r\n                x: ((2*(end.x)/3) >> 0) - 1,\r\n                y: ((2*(end.y)/3) >> 0) - 1\r\n            }\r\n        }\r\n    }\r\n\r\n    changeTile(data: TileData) {\r\n        this.tilePointer = data;\r\n    }\r\n\r\n    calcEndPointInView() {\r\n        const xEnd = Math.round(window.innerWidth / this.props.tileSize);\r\n        const yEnd = Math.round((window.innerHeight - this.props.topMargin - 30) / this.props.tileSize);\r\n        return {\r\n            x: xEnd, y: yEnd\r\n        }\r\n    }\r\n\r\n    toggleDisable() {\r\n        this.disable = !this.disable;\r\n    }\r\n\r\n    getBoundingRect() {\r\n        return this.svg.current!.getBoundingClientRect();\r\n    }\r\n\r\n    mouseDown(e: MouseEvent) {\r\n        e.preventDefault();\r\n        const bounds = this.getBoundingRect();\r\n        this.onPress(e.clientX - bounds.left, e.clientY - bounds.top, e.button);\r\n    }\r\n\r\n    mouseUp(e: MouseEvent) {\r\n        e.preventDefault();\r\n        if(isControlKey(e.button)) {\r\n            this.draggingGoal = false;\r\n            this.draggingInitial = false;\r\n            this.drawing = false;\r\n            this.erasing = false;\r\n        }\r\n    }\r\n\r\n    mouseMove(e: MouseEvent) {\r\n        const bounds = this.getBoundingRect();\r\n        this.onDrag(e.clientX - bounds.left, e.clientY - bounds.top);\r\n    }\r\n\r\n    touchStart(e: TouchEvent) {\r\n        const touch = e.touches[0] || e.changedTouches[0];\r\n        const bounds = this.getBoundingRect();\r\n        this.onPress(touch.clientX - bounds.left, touch.clientY - bounds.top, 0);\r\n    }\r\n\r\n    touchMove(e: TouchEvent) {\r\n        const touch = e.touches[0] || e.changedTouches[0];\r\n        const bounds = this.getBoundingRect();\r\n        this.onDrag(touch.clientX - bounds.left, touch.clientY - bounds.top);\r\n    }\r\n\r\n    onEndingEvent(e: Event) {\r\n        e.preventDefault();\r\n        this.draggingGoal = false;\r\n        this.draggingInitial = false;\r\n        this.drawing = false;\r\n        this.erasing = false;\r\n    }\r\n\r\n    /**\r\n     * Responds to the event thrown at screen coordinates on press\r\n     * @param xCoordinate\r\n     * @param yCoordinate\r\n     * @param button\r\n     */\r\n    onPress(xCoordinate: number, yCoordinate: number, button: number) {\r\n        const point = this.calculatePoint(xCoordinate,yCoordinate);\r\n        if(isControlKey(button)) {\r\n            if(pointsEqual(point, this.state.initial)) {\r\n                this.draggingInitial = true;\r\n            } else if(pointsEqual(point, this.state.goal)) {\r\n                this.draggingGoal = true;\r\n            } else if(!this.disable) {\r\n                if(this.state.grid.isEmpty(point)) {\r\n                    this.drawing = true;\r\n                    this.drawTile(point);\r\n                } else {\r\n                    this.erasing = true;\r\n                    this.eraseTile(point);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Responds to the event thrown at screen coordinates on drag/move\r\n     * @param xCoordinate\r\n     * @param yCoordinate\r\n     */\r\n    onDrag(xCoordinate: number, yCoordinate: number) {\r\n        const point = this.calculatePoint(xCoordinate,yCoordinate);\r\n        if(this.draggingInitial) {\r\n            this.moveInitial(point);\r\n        } else if(this.draggingGoal) {\r\n            this.moveGoal(point);\r\n        } else if(!pointsEqual(point, this.state.initial)\r\n            && !pointsEqual(point, this.state.goal) && !this.disable)\r\n        {\r\n            if(this.drawing) {\r\n                this.drawTile(point);\r\n            } else if(this.erasing) {\r\n                this.eraseTile(point);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draw an entire new grid on the foreground with disabled animations\r\n     * @param grid\r\n     */\r\n    drawGrid(grid: Grid) {\r\n        this.doTileAnimation = false;\r\n        this.setState({\r\n            grid: grid\r\n        }, () => this.doTileAnimation = true)\r\n    }\r\n\r\n    /**\r\n     * Draw tile at point\r\n     * @param point\r\n     */\r\n    drawTile(point: Point) {\r\n        const grid = this.state.grid.clone();\r\n        if(grid.inBounds(point)) {\r\n            grid.mutateTile({\r\n                point: point,\r\n                data: this.tilePointer\r\n            });\r\n        }\r\n        this.setState({\r\n            grid: grid\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Checks if a node is visualized, then changes the tile to empty if it isn't\r\n     * @param point\r\n     */\r\n    eraseTile(point: Point) {\r\n        const grid = this.state.grid.clone();\r\n        if(grid.inBounds(point)) {\r\n            grid.mutateDefault(point, false);\r\n        }\r\n        this.setState({\r\n            grid: grid\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Clear grid in state\r\n     */\r\n    clearTiles() {\r\n        const grid = this.state.grid.clone();\r\n        for(let y = 0; y < this.height; y++) {\r\n            for(let x = 0; x < this.width; x++) {\r\n                const point = {\r\n                    x: x, y: y\r\n                }\r\n                grid.mutateDefault(point, false);\r\n            }\r\n        }\r\n        this.setState({\r\n            grid: grid\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Moves initial to a new point\r\n     * @param point\r\n     */\r\n    moveInitial(point: Point) {\r\n        if(this.canMoveEndPoint(point)) {\r\n            this.setState({\r\n                initial: point\r\n            }, () => this.props.onTilesDragged());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Moves goal to a new point\r\n     * @param point\r\n     */\r\n    moveGoal(point: Point) {\r\n        if(this.canMoveEndPoint(point)) {\r\n            this.setState({\r\n                goal: point\r\n            }, () => this.props.onTilesDragged());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if we can move any of the end points (goal or initial) to that point\r\n     * @param point\r\n     */\r\n    canMoveEndPoint(point: Point) {\r\n        return this.state.grid.inBounds(point)\r\n            && !this.state.grid.isSolid(point)\r\n            && !pointsEqual(this.state.initial, point)\r\n            && !pointsEqual(this.state.goal, point)\r\n            && !this.disable;\r\n    }\r\n\r\n    /**\r\n     * Draw a path onto the grid\r\n     * @param path\r\n     */\r\n    drawPath(path: Tile[]) {\r\n        this.setState({\r\n            path: path.slice()\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Erase path from the grid\r\n     */\r\n    erasePath() {\r\n        this.setState({\r\n            path: []\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Converts real screen x,y coordinates into\r\n     * a 2d point position on the grid\r\n     * @param xCoordinate\r\n     * @param yCoordinate\r\n     */\r\n    calculatePoint(xCoordinate: number, yCoordinate: number) {\r\n        return {\r\n            x: Math.floor(xCoordinate/this.props.tileSize),\r\n            y: Math.floor(yCoordinate/this.props.tileSize)\r\n        }\r\n    }\r\n\r\n    resetPoints() {\r\n        const end = this.calcEndPointInView();\r\n        this.setState({\r\n            initial: {\r\n                x: ((end.x)/3) >> 0,\r\n                y: ((end.y)/3) >> 0\r\n            },\r\n            goal: {\r\n                x: ((2*(end.x)/3) >> 0) - 1,\r\n                y: ((2*(end.y)/3) >> 0) - 1\r\n            }\r\n        });\r\n    }\r\n\r\n    render() {\r\n        // console.timeEnd('time');\r\n        // console.time('time');\r\n        return (\r\n            <div>\r\n                <div className='endpoint-tiles-table'>\r\n                    {this.renderEndTile(this.state.initial, INITIAL_COLOR,'initial')}\r\n                    {this.renderEndTile(this.state.goal, GOAL_COLOR,'goal')}\r\n                </div>\r\n                <svg ref={this.svg} xmlns='http://www.w3.org/2000/svg' className='arrow-grid'>\r\n                    <defs>\r\n                        <marker id='arrowhead-path' markerWidth='3' markerHeight='3'\r\n                                refX='0' refY='1.5' orient='auto'\r\n                                fill={ARROW_PATH_COLOR}\r\n                        >\r\n                            <polygon points='0 0, 3 1.5, 0 3'/>\r\n                        </marker>\r\n                    </defs>\r\n                    {this.renderPath()}\r\n                </svg>\r\n                <div className='tiles-table'\r\n                     onContextMenu={e => e.preventDefault()}\r\n                     onMouseDown={e => this.mouseDown(e.nativeEvent)}\r\n                     onMouseUp={e => this.mouseUp(e.nativeEvent)}\r\n                     onMouseMove={e => this.mouseMove(e.nativeEvent)}\r\n                     onMouseLeave={e => this.onEndingEvent(e.nativeEvent)}\r\n                     onTouchStart={e => this.touchStart(e.nativeEvent)}\r\n                     onTouchMoveCapture={e => this.touchMove(e.nativeEvent)}\r\n                     onTouchEnd={e => this.onEndingEvent(e.nativeEvent)}\r\n                     onTouchCancel={e => this.onEndingEvent(e.nativeEvent)}\r\n                >\r\n                    {this.renderTilesTable()}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    renderPath() {\r\n        const lines: JSX.Element[] = [];\r\n        for(let i = 0; i < this.state.path.length-1; i++) {\r\n            const first = this.state.path[i].point;\r\n            const second = this.state.path[i+1].point;\r\n            lines.push(this.renderPathArrow(i, first, second));\r\n        }\r\n        return lines;\r\n    }\r\n\r\n    renderPathArrow(index: number, first: Point, second: Point) {\r\n        const width = this.props.tileSize;\r\n        const offset = width/2;\r\n        const firstX = first.x * width;\r\n        const firstY = first.y * width;\r\n        const secondX = second.x * width;\r\n        const secondY = second.y * width;\r\n        const offsetX = (secondX - firstX)/4;\r\n        const offsetY = (secondY - firstY)/4;\r\n        return (\r\n            <line key={'path ' + index}\r\n                  x1={firstX + offset + offsetX}\r\n                  y1={firstY + offset + offsetY}\r\n                  x2={secondX + offset - offsetX}\r\n                  y2={secondY + offset - offsetY}\r\n                  stroke={ARROW_PATH_COLOR}\r\n                  strokeWidth={2 * this.props.tileSize/BASE_WIDTH}\r\n                  className='line'\r\n                  markerEnd='url(#arrowhead-path)' />\r\n        );\r\n    }\r\n\r\n    renderTilesTable() {\r\n        const tiles: JSX.Element[] = [];\r\n        for(let y = 0; y < this.height; y++) {\r\n            for(let x = 0; x < this.width; x++) {\r\n                const point = {\r\n                    x: x, y: y\r\n                }\r\n                const cost = this.state.grid.get(point).data.pathCost;\r\n                if(this.state.grid.isSolid(point)) {\r\n                    //render a solid tile div\r\n                    tiles.push(\r\n                        <SolidFg key={x + ',' + y}\r\n                                  point={point}\r\n                                  tileSize={this.props.tileSize}\r\n                                  doTileAnimation={this.doTileAnimation}\r\n                        />\r\n                    );\r\n                } else if(cost > 1) {\r\n                    //render a weight svg\r\n                    tiles.push(\r\n                        <WeightFg key={x + ',' + y}\r\n                                  point={point}\r\n                                  tileSize={this.props.tileSize}\r\n                                  doTileAnimation={this.doTileAnimation}\r\n                                  weightOpacity={this.props.weightOpacity}\r\n                        />\r\n                    );\r\n                    //render a div containing the cost as text\r\n                    tiles.push(\r\n                        this.renderWeightText(point, cost, x + ',' + y + ' text')\r\n                    )\r\n                }\r\n            }\r\n        }\r\n        return tiles;\r\n    }\r\n\r\n    renderWeightText(point: Point, cost: number, key: string) {\r\n        return (\r\n            <div key={key}\r\n                 style={{\r\n                     left: point.x * this.props.tileSize,\r\n                     top: point.y * this.props.tileSize,\r\n                     width: this.props.tileSize,\r\n                     height: this.props.tileSize,\r\n                     position: 'absolute',\r\n                     color: 'white',\r\n                     fontSize: 13,\r\n                     paddingTop: this.props.tileSize / 3.80,\r\n                     textAlign: 'center',\r\n                     cursor: 'default',\r\n                     opacity: this.props.weightOpacity + 0.4\r\n                 }}\r\n            >\r\n                {cost}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    renderEndTile(point: Point, color: string, key: string) {\r\n        return <TileFg key={key} point={point}\r\n                       tileWidth={this.props.tileSize}\r\n                       color={color}/>\r\n    }\r\n}\r\n\r\nfunction pointsEqual(point1: Point, point2: Point) {\r\n    return point1.x === point2.x && point1.y === point2.y;\r\n}\r\n\r\nfunction isControlKey(button: number) {\r\n    //right or left mouse\r\n    return button === 0 || button === 2;\r\n}\r\n\r\nexport default GridForeground;","import React, {RefObject} from 'react';\r\nimport './Grid.css';\r\n\r\ninterface IProps {\r\n    algorithm: string,\r\n    length: number,\r\n    cost: number,\r\n    time: number,\r\n    nodes: number\r\n}\r\n\r\nclass StatsPanel extends React.Component<IProps>\r\n{\r\n    private readonly textLog: RefObject<HTMLTextAreaElement> = React.createRef();\r\n\r\n    componentDidUpdate() {\r\n        this.textLog.current!.scrollTop = this.textLog.current!.scrollHeight;\r\n    }\r\n\r\n    getHeight() {\r\n        //top border: 1\r\n        return this.textLog.current!.clientHeight + 1;\r\n    }\r\n\r\n    render() {\r\n        const time = precise(this.props.time);\r\n        const text = this.props.algorithm === '' ? '' :\r\n            this.props.algorithm +\r\n            ' visited ' +\r\n            this.props.nodes +\r\n            ' nodes in ' +\r\n            time +\r\n            ' ms. Path length = ' +\r\n            this.props.length +\r\n            '. Path cost = ' +\r\n            this.props.cost +\r\n            '. ';\r\n        return(\r\n            <textarea tabIndex={-1} ref={this.textLog} readOnly={true}\r\n                      className='stats-text-area no-select'\r\n                      value={text} unselectable={'on'} onDrop={() => false}\r\n            />\r\n        );\r\n    }\r\n}\r\n\r\nfunction precise(x: number) {\r\n    return x.toFixed(2);\r\n}\r\n\r\nexport default StatsPanel;","import {Point, Tile} from './Components';\r\nimport Navigator, {UNIT} from './Navigator';\r\n\r\n/**\r\n * Concretion of a Plus Navigator for a grid\r\n * Allows movement akin to a 'plus' symbol\r\n */\r\nclass PlusNavigator extends Navigator\r\n{\r\n    /**\r\n     * Adds the neighbors of a point to the left, right, top and down\r\n     * @param point\r\n     */\r\n    neighbors(point: Point): Tile[] {\r\n        const tiles: Tile[] = [];\r\n        if(point.x + UNIT < this.grid.getWidth()) {\r\n            const tile = this.grid.get({\r\n                x: point.x + UNIT,\r\n                y: point.y\r\n            })\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        if(point.y + UNIT < this.grid.getHeight()) {\r\n            const tile = this.grid.get({\r\n                x: point.x,\r\n                y: point.y + UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        if(point.x - UNIT >= 0) {\r\n            const tile = this.grid.get({\r\n                x: point.x - UNIT,\r\n                y: point.y\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        if(point.y - UNIT >= 0) {\r\n            const tile = this.grid.get({\r\n                x: point.x,\r\n                y: point.y - UNIT\r\n            });\r\n            if(!tile.data.isSolid) {\r\n                tiles.push(tile);\r\n            }\r\n        }\r\n        return tiles;\r\n    }\r\n\r\n    /**\r\n     * Step cost function that works by getting the pathCost stored in the grid\r\n     * from one point a to b\r\n     * @param a\r\n     * @param b to point to travel to\r\n     */\r\n    cost(a: Point, b: Point) {\r\n        return this.grid.get(b).data.pathCost;\r\n    }\r\n\r\n    getType() {\r\n        return 'plus';\r\n    }\r\n}\r\n\r\nexport default PlusNavigator;","import {Grid} from './Grid';\r\nimport {Point, Tile} from './Components';\r\n\r\nexport const UNIT = 1; //number of tiles we can move at once\r\n\r\n/**\r\n * Describes an abstract navigator for a grid\r\n * Provides graph-like traversal for the grid\r\n * Determines where we can travel to from a certain point,\r\n * whether we have reached a destination, and the cost to\r\n * travel to a certain point\r\n */\r\nabstract class Navigator\r\n{\r\n    protected readonly grid: Grid;\r\n\r\n    constructor(grid: Grid) {\r\n        this.grid = grid;\r\n    }\r\n\r\n    getGrid() {\r\n        return this.grid;\r\n    }\r\n\r\n    /**\r\n     * Goal check function: Checks if two points are equal\r\n     * @param a\r\n     * @param b\r\n     */\r\n    equals(a: Point, b: Point) {\r\n        return a.x === b.x && a.y === b.y;\r\n    }\r\n\r\n    /**\r\n     * Step cost function from a to b\r\n     * @param a\r\n     * @param b to point to travel to\r\n     */\r\n    abstract cost(a: Point, b: Point): number;\r\n\r\n    /**\r\n     * Neighbors function: Gets the available neighbors for a point in a grid we can make\r\n     * in a given move\r\n     * @param point\r\n     */\r\n    abstract neighbors(point: Point): Tile[];\r\n\r\n    abstract getType(): string;\r\n}\r\n\r\nexport default Navigator;","import {Point} from '../core/Components';\r\n\r\nexport type HeuristicFunc = (a: Point, b: Point) => number;\r\n\r\nexport function manhattan(a: Point, b: Point): number {\r\n    const dx = Math.abs(a.x - b.x) ;\r\n    const dy = Math.abs(a.y - b.y);\r\n    return dx + dy;\r\n}\r\n\r\nexport function euclidean(a: Point, b: Point): number {\r\n    const dx = Math.abs(a.x - b.x);\r\n    const dy = Math.abs(a.y - b.y);\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n}\r\n\r\nexport function octile(a: Point, b: Point): number {\r\n    const dx = Math.abs(a.x - b.x);\r\n    const dy = Math.abs(a.y - b.y);\r\n    return Math.SQRT2 * Math.min(dx, dy) + Math.abs(dx - dy);\r\n}\r\n\r\nexport function chebyshev(a: Point, b: Point): number {\r\n    const dx = Math.abs(a.x - b.x);\r\n    const dy = Math.abs(a.y - b.y);\r\n    return Math.max(dx, dy);\r\n}\r\n\r\nexport function nullHeuristic(): number {\r\n    return 0;\r\n}","import {Point} from '../core/Components';\r\n\r\n/**\r\n * A simple data structure that keeps track of whether keys have been added to it\r\n */\r\nexport class HashSet\r\n{\r\n    private map: {[key: string]: boolean | undefined} = {};\r\n\r\n    add(key: string) {\r\n        this.map[key] = true;\r\n    }\r\n\r\n    remove(key: string) {\r\n        this.map[key] = undefined;\r\n    }\r\n\r\n    has(key: string) {\r\n        return this.map[key] !== undefined;\r\n    }\r\n\r\n    clear() {\r\n        this.map = {};\r\n    }\r\n}\r\n\r\n/**\r\n * A simple data structure that stores a type at a key\r\n */\r\nexport class HashTable<Value>\r\n{\r\n    private map: {[key: string]: Value | undefined} = {};\r\n\r\n    add(key: string, data: Value) {\r\n        this.map[key] = data;\r\n    }\r\n\r\n    remove(key: string) {\r\n        this.map[key] = undefined;\r\n    }\r\n\r\n    get(key: string) {\r\n        return this.map[key];\r\n    }\r\n\r\n    has(key: string) {\r\n        return this.map[key] !== undefined;\r\n    }\r\n\r\n    clear() {\r\n        this.map = {};\r\n    }\r\n}\r\n\r\n/**\r\n * Serialize point into a unique string\r\n * @param point\r\n */\r\nexport function stringify(point: Point) {\r\n    return 'x' + point.x + 'y' + point.y;\r\n}","/**\r\n * A compare function to determine if a is 'better' (deserves a higher position) than b\r\n */\r\nexport type Comparator<E> = (a: E, b: E) => boolean\r\n\r\n/**\r\n * Minimalist Implementation of the heap data structure as an array\r\n */\r\nclass Heap<E>\r\n{\r\n    private elements: E[] = [];\r\n    readonly compare: Comparator<E>;\r\n\r\n    constructor(compare: Comparator<E>) {\r\n        this.compare = compare;\r\n    }\r\n\r\n    /**\r\n     * Returns the size of the heap\r\n     */\r\n    getSize() {\r\n        return this.elements.length;\r\n    }\r\n\r\n    /**\r\n     * Checks if heap is empty\r\n     */\r\n    isEmpty() {\r\n        return this.elements.length === 0;\r\n    }\r\n\r\n    /**\r\n     * Add a new element to the heap\r\n     * @param e\r\n     */\r\n    push(e: E) {\r\n        this.elements.push(e);\r\n        this.siftUp(this.elements.length-1); //last element\r\n    }\r\n\r\n    /**\r\n     * Returns the top of the heap without removing it\r\n     * Fails if heap is empty\r\n     */\r\n    peek() {\r\n        return this.elements[0];\r\n    }\r\n\r\n    /**\r\n     * Returns the top of the heap and removes it\r\n     * Fails if heap is empty\r\n     */\r\n    pop() {\r\n        const val = this.peek();\r\n        this.move(this.elements.length - 1, 0);\r\n        this.elements.pop();\r\n        this.siftDown(0);\r\n        return val;\r\n    }\r\n\r\n    /**\r\n     * Clear the heap\r\n     */\r\n    clear() {\r\n        this.elements = [];\r\n    }\r\n\r\n    /**\r\n     * Sifts a new element that is out of order up to the right position\r\n     * @param pos of new element\r\n     */\r\n    private siftUp(pos: number) {\r\n        let parent = ((pos - 1) / 2) >> 0; //integer division\r\n        while(parent >= 0) {\r\n            //if the current position is better than parent\r\n            if(this.compare(this.elements[pos], this.elements[parent])) {\r\n                //then current position with parent and move to next\r\n                this.swap(pos, parent);\r\n                pos = parent;\r\n                parent = ((pos - 1) / 2) >> 0;\r\n            } else {\r\n                //otherwise stop\r\n                parent = -1;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sifts a new element that is out of order down to the right position\r\n     * @param pos of new element\r\n     */\r\n    private siftDown(pos: number) {\r\n        const left = 2 * pos + 1;\r\n        const right = 2 * pos + 2;\r\n        //stop if the children are out of bounds\r\n        if(left >= this.elements.length) {\r\n            return;\r\n        }\r\n        //find the better child\r\n        const child = (right >= this.elements.length || this.compare(this.elements[left], this.elements[right]))\r\n            ? left : right;\r\n        //continues to sift down if the child is better than the current position\r\n        if(this.compare(this.elements[child], this.elements[pos])) {\r\n            this.swap(child, pos);\r\n            this.siftDown(child);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Internal move function\r\n     * @param from\r\n     * @param to\r\n     */\r\n    private move(from: number, to: number) {\r\n        this.elements[to] = this.elements[from];\r\n    }\r\n\r\n    /**\r\n     * Internal swap function\r\n     * @param a\r\n     * @param b\r\n     */\r\n    private swap(a: number, b: number) {\r\n        let val = this.elements[a];\r\n        this.elements[a] = this.elements[b];\r\n        this.elements[b] = val;\r\n    }\r\n}\r\n\r\nexport default Heap;","import {Point, Tile} from '../core/Components';\r\nimport Navigator from '../core/Navigator';\r\nimport {Node} from './Node';\r\n\r\n/**\r\n * Pathfinder performs algorithms operations on the grid\r\n * Uses the navigator rank and expand nodes\r\n */\r\nabstract class Pathfinder\r\n{\r\n    protected recentSearch: Node[] = [];\r\n    protected navigator: Navigator;\r\n\r\n    constructor(navigator: Navigator) {\r\n        this.navigator = navigator;\r\n    }\r\n\r\n    setNavigator(navigator: Navigator) {\r\n        this.navigator = navigator;\r\n    }\r\n\r\n    getNavigator() {\r\n        return this.navigator;\r\n    }\r\n\r\n    getRecentNodes() {\r\n        return this.recentSearch.length;\r\n    }\r\n\r\n    clearRecentSearch() {\r\n        this.recentSearch = [];\r\n    }\r\n\r\n    getRecentGenerations() {\r\n        return this.recentSearch.slice();\r\n    }\r\n\r\n    protected addRecent(node: Node) {\r\n        this.recentSearch.push(node);\r\n    }\r\n\r\n    abstract getAlgorithmName(): string;\r\n\r\n    /**\r\n     * Finds the best path between initial and goal on the grid\r\n     * and returns it in an array\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    abstract findPath(initial: Point, goal: Point): Tile[];\r\n}\r\n\r\n/**\r\n * Reconstructs the path from a tree, given the bottomLeaf, and\r\n * returns the shortest path in an array\r\n * @param bottomLeaf bottom of the tree to start from\r\n */\r\nexport function reconstructPath(bottomLeaf: Node): Tile[] {\r\n    return reconstructPathReversed(bottomLeaf).reverse();\r\n}\r\n\r\n/**\r\n * Reconstructs the path from a tree, given the bottomLeaf, and\r\n * returns the shortest path in an array\r\n * @param bottomLeaf bottom of the tree to start from\r\n */\r\nexport function reconstructPathReversed(bottomLeaf: Node): Tile[] {\r\n    const path: Tile[] = [];\r\n    while(bottomLeaf.parent !== null) {\r\n        path.push(bottomLeaf.tile);\r\n        bottomLeaf = bottomLeaf.parent;\r\n    }\r\n    return path;\r\n}\r\n\r\nexport default Pathfinder;","import {Tile} from '../core/Components';\r\n\r\n/**\r\n * Represents a search Tree Node\r\n */\r\nexport class Node\r\n{\r\n    parent: Node | null = null; //parent node\r\n    readonly children: Node[] = [];\r\n    readonly tile: Tile; //stores a graph node\r\n\r\n    constructor(tile: Tile) {\r\n        this.tile = tile;\r\n    }\r\n\r\n    addChild(child: Node) {\r\n        child.parent = this;\r\n        this.children.push(child);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents an heuristic weighted aStar search tree node\r\n */\r\nexport class AStarNode extends Node\r\n{\r\n    readonly g: number; //path cost\r\n    readonly fScore: number; //heuristic\r\n\r\n    constructor(tile: Tile, g: number, fScore: number) {\r\n        super(tile);\r\n        this.g = g;\r\n        this.fScore = fScore;\r\n    }\r\n\r\n    f() {\r\n        return this.fScore;\r\n    }\r\n}\r\n","import {HashSet, HashTable, stringify} from '../structures/Hash';\r\nimport Heap from '../structures/Heap';\r\nimport Pathfinder, {reconstructPath} from './Pathfinder';\r\nimport {Point, Tile} from '../core/Components';\r\nimport {AStarNode} from './Node';\r\nimport Navigator from '../core/Navigator';\r\nimport {euclidean, HeuristicFunc} from './Heuristics';\r\n\r\nclass AStarPathfinder extends Pathfinder\r\n{\r\n    private readonly heuristicFunc: HeuristicFunc = (a: Point, b: Point) => euclidean(a,b);\r\n    private readonly p: number; //tie breaker\r\n\r\n    constructor(navigator: Navigator, func?: HeuristicFunc) {\r\n        super(navigator);\r\n        const grid = this.getNavigator().getGrid();\r\n        //minimum cost of taking one step / expected maximum path length\r\n        this.p = 1/(grid.getWidth() * grid.getHeight());\r\n        if(func !== undefined) {\r\n            this.heuristicFunc = func;\r\n        }\r\n    }\r\n\r\n    getAlgorithmName(): string {\r\n        return 'A*';\r\n    }\r\n\r\n    /**\r\n     * Performs aStar algorithm on the grid given an initial and goal point\r\n     * Always returns the shortest path, and performs well on larger grids\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point): Tile[] {\r\n        this.clearRecentSearch();\r\n        const grid = this.navigator.getGrid();\r\n        const openFrontier = new Heap<AStarNode>(\r\n            (a, b) => a.f() < b.f()\r\n        );\r\n        const closedSet = new HashSet();\r\n        const openSet = new HashTable<number>();\r\n        const root = new AStarNode(\r\n            grid.get(initial), 0, 0\r\n        );\r\n        openFrontier.push(root);\r\n        openSet.add(stringify(initial), root.g);\r\n        while (!openFrontier.isEmpty()) {\r\n            const currentNode = openFrontier.pop();\r\n            const currentPoint = currentNode.tile.point;\r\n            const currentKey = stringify(currentPoint);\r\n            openSet.remove(currentKey);\r\n            closedSet.add(currentKey);\r\n            this.addRecent(currentNode);\r\n            if (this.navigator.equals(currentPoint, goal)) {\r\n                return reconstructPath(currentNode);\r\n            }\r\n            for (const neighbor of this.navigator.neighbors(currentPoint)) {\r\n                const neighborPoint = neighbor.point;\r\n                const neighborKey = stringify(neighborPoint);\r\n                if(closedSet.has(neighborKey)) {\r\n                    continue;\r\n                }\r\n                const g = currentNode.g + this.stepCost(currentPoint, neighborPoint);\r\n                const f = g + this.heuristic(neighborPoint, goal);\r\n                if (!openSet.has(neighborKey) || g < openSet.get(neighborKey)!) {\r\n                    const neighborNode = new AStarNode(\r\n                        neighbor, g, f\r\n                    );\r\n                    currentNode.addChild(neighborNode);\r\n                    openFrontier.push(neighborNode);\r\n                    openSet.add(neighborKey, neighborNode.g);\r\n                }\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Heuristic function used to estimate distance between points a and b\r\n     * Includes tie breaker to prevent exploring lots of identical paths\r\n     * @param a\r\n     * @param b\r\n     */\r\n    heuristic(a: Point, b: Point) {\r\n        return this.heuristicFunc(a, b) * (1 + this.p);\r\n    }\r\n\r\n    /**\r\n     * The step-cost function to be used, calculating the cost from\r\n     * currentPoint to neighborPoint. Uses the stepCost function provided by the\r\n     * navigator by default but can be overridden\r\n     * @param currentPoint\r\n     * @param neighborPoint\r\n     */\r\n    stepCost(currentPoint: Point, neighborPoint: Point) {\r\n        return this.navigator.cost(currentPoint, neighborPoint);\r\n    }\r\n}\r\n\r\nexport default AStarPathfinder;","import Pathfinder, {reconstructPath} from './Pathfinder';\r\nimport {Point, Tile} from '../core/Components';\r\nimport {HashSet, stringify} from '../structures/Hash';\r\nimport {Node} from './Node';\r\n\r\nclass BFSPathfinder extends Pathfinder\r\n{\r\n    getAlgorithmName(): string {\r\n        return 'Breadth First Search';\r\n    }\r\n\r\n    /**\r\n     * Implementation of BFS to find the shortest path from initial to point\r\n     * Doesn't always return the shortest path, and performs poorly on larger grids\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point): Tile[] {\r\n        this.clearRecentSearch();\r\n        const grid = this.navigator.getGrid();\r\n        const frontier: Node[] = []; //fifo, stores nodes on the frontier\r\n        const visited = new HashSet();\r\n        const root = new Node(grid.get(initial));\r\n        frontier.push(root); //enqueue\r\n        visited.add(stringify(initial));\r\n        while(frontier.length !== 0) { //not empty\r\n            const currentNode = frontier.shift()!; //dequeue\r\n            const currentPoint = currentNode.tile.point;\r\n            this.addRecent(currentNode);\r\n            if(this.navigator.equals(currentPoint, goal)) {\r\n                return reconstructPath(currentNode);\r\n            }\r\n            for(const neighbor of this.navigator.neighbors(currentPoint)) {\r\n                const neighborKey = stringify(neighbor.point);\r\n                if(!visited.has(neighborKey)) {\r\n                    const neighborNode = new Node(neighbor);\r\n                    currentNode.addChild(neighborNode);\r\n                    frontier.push(neighborNode); //enqueue\r\n                    visited.add(neighborKey);\r\n                }\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n}\r\n\r\nexport default BFSPathfinder;","/**\r\n * Stack node\r\n */\r\nclass Node<E>\r\n{\r\n    next: Node<E> | null = null;\r\n    data: E;\r\n\r\n    constructor(data: E) {\r\n        this.data = data;\r\n    }\r\n}\r\n\r\n/**\r\n * Minimalist Implementation of the stack data structure\r\n */\r\nclass Stack<E>\r\n{\r\n    private top: Node<E> | null = null;\r\n    private size: number = 0;\r\n\r\n    peek() {\r\n        return this.top != null ? this.top.data : undefined;\r\n    }\r\n\r\n    push(e: E) {\r\n        const node = new Node(e);\r\n        node.next = this.top;\r\n        this.top = node;\r\n        this.size++;\r\n    }\r\n\r\n    pop() {\r\n        const top = this.peek();\r\n        if(this.top != null) {\r\n            this.top = this.top.next;\r\n            this.size--;\r\n        }\r\n        return top;\r\n    }\r\n\r\n    isEmpty() {\r\n        return this.size === 0;\r\n    }\r\n\r\n    getSize() {\r\n        return this.size;\r\n    }\r\n}\r\n\r\nexport default Stack;","import Pathfinder, {reconstructPath} from './Pathfinder';\r\nimport {Point, Tile} from '../core/Components';\r\nimport {HashSet, stringify} from '../structures/Hash';\r\nimport {Node} from './Node';\r\nimport Stack from '../structures/Stack';\r\n\r\nclass DFSPathfinder extends Pathfinder\r\n{\r\n    getAlgorithmName(): string {\r\n        return 'Depth First Search';\r\n    }\r\n\r\n    /**\r\n     * Calls DFS between a start and goal point, will typically not find the 'Best' path,\r\n     * and will instead find the best path capable for the algorithm\r\n     * As this algorithm is non optimal it should only be used for educational purposes\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point): Tile[] {\r\n        this.clearRecentSearch();\r\n        const grid = this.navigator.getGrid();\r\n        const root = new Node(grid.get(initial));\r\n        const frontier = new Stack<Node>();\r\n        frontier.push(root);\r\n        const visited = new HashSet();\r\n        while(!frontier.isEmpty()) {\r\n            const currentNode = frontier.pop()!;\r\n            const currentPoint = currentNode.tile.point;\r\n            visited.add(stringify(currentPoint));\r\n            this.addRecent(currentNode);\r\n            if(this.navigator.equals(currentPoint, goal)) {\r\n                return reconstructPath(currentNode);\r\n            }\r\n            const neighbors = this.navigator.neighbors(currentPoint).reverse();\r\n            for(const neighbor of neighbors){\r\n                const neighborKey = stringify(neighbor.point);\r\n                if(!visited.has(neighborKey)) {\r\n                    const neighborNode = new Node(neighbor);\r\n                    currentNode.addChild(neighborNode);\r\n                    frontier.push(neighborNode);\r\n                }\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n}\r\n\r\nexport default DFSPathfinder;\r\n","import {HashSet, HashTable, stringify} from '../structures/Hash';\r\nimport Heap from '../structures/Heap';\r\nimport Pathfinder, {reconstructPath, reconstructPathReversed} from './Pathfinder';\r\nimport {Point, Tile} from '../core/Components';\r\nimport {AStarNode} from './Node';\r\nimport Navigator from '../core/Navigator';\r\nimport {euclidean, HeuristicFunc} from './Heuristics';\r\n\r\ninterface ControlStructures {\r\n    openSet: HashTable<AStarNode>,\r\n    closedSet: HashSet,\r\n    openFrontier: Heap<AStarNode>\r\n}\r\n\r\nclass BiAStarPathfinder extends Pathfinder\r\n{\r\n    private readonly heuristic: HeuristicFunc = (a: Point, b: Point) => euclidean(a,b);\r\n\r\n    constructor(navigator: Navigator, func?: HeuristicFunc) {\r\n        super(navigator);\r\n        if(func !== undefined) {\r\n            this.heuristic = func;\r\n        }\r\n    }\r\n\r\n    getAlgorithmName(): string {\r\n        return 'Bidirectional A*';\r\n    }\r\n\r\n    /**\r\n     * Performs aStar algorithm on the grid given an initial and goal point\r\n     * Doesn't always returns the shortest path, but performs well on larger grids\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point): Tile[] {\r\n        this.clearRecentSearch();\r\n        const grid = this.navigator.getGrid();\r\n        const closedSet = new HashSet();\r\n        const startOpenFrontier = new Heap<AStarNode>(\r\n            (a, b) => a.f() < b.f()\r\n        );\r\n        const startOpenSet = new HashTable<AStarNode>();\r\n        const endOpenFrontier = new Heap<AStarNode>(\r\n            (a, b) => a.f() < b.f()\r\n        );\r\n        const endOpenSet = new HashTable<AStarNode>();\r\n        const initialRoot = new AStarNode(\r\n            grid.get(initial), 0, 0\r\n        );\r\n        startOpenFrontier.push(initialRoot);\r\n        startOpenSet.add(stringify(initial), initialRoot);\r\n        const goalRoot = new AStarNode(\r\n            grid.get(goal), 0, 0\r\n        );\r\n        endOpenFrontier.push(goalRoot);\r\n        endOpenSet.add(stringify(goal), goalRoot);\r\n        while (!startOpenFrontier.isEmpty() && !endOpenFrontier.isEmpty()) {\r\n            //expand startOpenFrontier\r\n            const startCurrentNode = startOpenFrontier.pop();\r\n            const startCurrentPoint = startCurrentNode.tile.point;\r\n            const startCurrentPointKey = stringify(startCurrentPoint);\r\n            startOpenSet.remove(startCurrentPointKey);\r\n            closedSet.add(startCurrentPointKey);\r\n            this.addRecent(startCurrentNode);\r\n            if(endOpenSet.has(startCurrentPointKey)) {\r\n                if(startCurrentNode.parent != null) {\r\n                    return reconstructPath(\r\n                        startCurrentNode.parent\r\n                    ).concat(reconstructPathReversed(\r\n                        endOpenSet.get(startCurrentPointKey)!\r\n                    )).concat(\r\n                        grid.get(goal)\r\n                    );\r\n                } else {\r\n                    return [grid.get(goal)];\r\n                }\r\n            }\r\n            this.doAStarExpansion({\r\n                openFrontier: startOpenFrontier,\r\n                openSet: startOpenSet,\r\n                closedSet: closedSet\r\n            }, startCurrentNode, goal);\r\n            //expand endOpenFrontier\r\n            const endCurrentNode = endOpenFrontier.pop();\r\n            const endCurrentPoint = endCurrentNode.tile.point;\r\n            const endCurrentPointKey = stringify(endCurrentPoint);\r\n            endOpenSet.remove(endCurrentPointKey);\r\n            closedSet.add(endCurrentPointKey);\r\n            this.addRecent(endCurrentNode);\r\n            if(startOpenSet.has(endCurrentPointKey)) {\r\n                if(endCurrentNode.parent != null) {\r\n                    return reconstructPath(\r\n                        startOpenSet.get(endCurrentPointKey)!\r\n                    ).concat(reconstructPathReversed(\r\n                        endCurrentNode.parent!\r\n                    )).concat(\r\n                        grid.get(goal)\r\n                    );\r\n                } else {\r\n                    return [grid.get(goal)];\r\n                }\r\n            }\r\n            this.doAStarExpansion({\r\n                openFrontier: endOpenFrontier,\r\n                openSet: endOpenSet,\r\n                closedSet: closedSet\r\n            }, endCurrentNode, initial);\r\n        }\r\n        return [];\r\n    }\r\n\r\n    private doAStarExpansion(structures: ControlStructures, currentNode: AStarNode, endPoint: Point) {\r\n        const currentPoint = currentNode.tile.point;\r\n        for (const neighbor of this.navigator.neighbors(currentPoint)) {\r\n            const neighborPoint = neighbor.point;\r\n            const neighborKey = stringify(neighborPoint);\r\n            if(structures.closedSet.has(neighborKey)) {\r\n                continue;\r\n            }\r\n            const g = currentNode.g + this.stepCost(currentPoint, neighborPoint);\r\n            const f = g + this.heuristic(neighborPoint, endPoint);\r\n            if (!structures.openSet.has(neighborKey) || g < structures.openSet.get(neighborKey)!.g) {\r\n                const neighborNode = new AStarNode(\r\n                    neighbor, g, f\r\n                );\r\n                currentNode.addChild(neighborNode);\r\n                structures.openFrontier.push(neighborNode);\r\n                structures.openSet.add(neighborKey, neighborNode);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The step-cost function to be used, calculating the cost from\r\n     * currentPoint to neighborPoint. Uses the stepCost function provided by the\r\n     * navigator by default but can be overridden\r\n     * @param currentPoint\r\n     * @param neighborPoint\r\n     */\r\n    stepCost(currentPoint: Point, neighborPoint: Point) {\r\n        return this.navigator.cost(currentPoint, neighborPoint);\r\n    }\r\n}\r\n\r\nexport default BiAStarPathfinder;","import Pathfinder, {reconstructPath, reconstructPathReversed} from './Pathfinder';\r\nimport {Point, Tile} from '../core/Components';\r\nimport {HashTable, stringify} from '../structures/Hash';\r\nimport {Node} from './Node';\r\n\r\ninterface ControlStructures {\r\n    frontier: Node[],\r\n    visited: HashTable<Node>\r\n}\r\n\r\nclass BiBFSPathfinder extends Pathfinder\r\n{\r\n    getAlgorithmName(): string {\r\n        return 'Bidirectional Breadth First Search';\r\n    }\r\n\r\n    /**\r\n     * Implementation of BFS to find the shortest path from initial to point\r\n     * Doesn't always return the shortest path, and performs poorly on larger grids\r\n     * @param initial\r\n     * @param goal\r\n     */\r\n    findPath(initial: Point, goal: Point): Tile[] {\r\n        this.clearRecentSearch();\r\n        const grid = this.navigator.getGrid();\r\n        const startVisited = new HashTable<Node>();\r\n        const endVisited = new HashTable<Node>();\r\n        const startFrontier: Node[] = [];\r\n        const endFrontier: Node[] = [];\r\n        const initialRoot = new Node(grid.get(initial));\r\n        startFrontier.push(initialRoot);\r\n        startVisited.add(stringify(initial), initialRoot);\r\n        const goalRoot = new Node(grid.get(goal));\r\n        endFrontier.push(goalRoot);\r\n        endVisited.add(stringify(goal), goalRoot);\r\n        while(startFrontier.length !== 0 && endFrontier.length !== 0) {\r\n            //expand startQueue\r\n            const startCurrentNode = startFrontier.shift()!;\r\n            const startCurrentPoint = startCurrentNode.tile.point;\r\n            const startCurrentPointKey = stringify(startCurrentPoint);\r\n            this.addRecent(startCurrentNode);\r\n            if(endVisited.has(startCurrentPointKey)) {\r\n                if(startCurrentNode.parent != null) {\r\n                    return reconstructPath(\r\n                        startCurrentNode.parent\r\n                    ).concat(reconstructPathReversed(\r\n                        endVisited.get(startCurrentPointKey)!\r\n                    )).concat(\r\n                        grid.get(goal)\r\n                    );\r\n                } else {\r\n                    return [grid.get(goal)];\r\n                }\r\n            }\r\n            this.doBFSExpansion({\r\n                frontier: startFrontier,\r\n                visited: startVisited\r\n            }, startCurrentNode);\r\n            //expand endQueue\r\n            const endCurrentNode = endFrontier.shift()!;\r\n            const endCurrentPoint = endCurrentNode.tile.point;\r\n            const endCurrentPointKey = stringify(endCurrentPoint);\r\n            this.addRecent(endCurrentNode);\r\n            if(startVisited.has(endCurrentPointKey)) {\r\n                if(endCurrentNode.parent != null) {\r\n                    return reconstructPath(\r\n                        startVisited.get(endCurrentPointKey)!\r\n                    ).concat(reconstructPathReversed(\r\n                        endCurrentNode.parent\r\n                    )).concat(\r\n                        grid.get(goal)\r\n                    );\r\n                } else {\r\n                    return [grid.get(goal)];\r\n                }\r\n            }\r\n            this.doBFSExpansion({\r\n                frontier: endFrontier,\r\n                visited: endVisited\r\n            }, endCurrentNode);\r\n        }\r\n        return [];\r\n    }\r\n\r\n    private doBFSExpansion(structures: ControlStructures, currentNode: Node) {\r\n        const currentPoint = currentNode.tile.point;\r\n        for(const neighbor of this.navigator.neighbors(currentPoint)) {\r\n            const neighborKey = stringify(neighbor.point);\r\n            if(!structures.visited.has(neighborKey)) {\r\n                const neighborNode = new Node(neighbor);\r\n                currentNode.addChild(neighborNode);\r\n                structures.frontier.push(neighborNode);\r\n                structures.visited.add(neighborKey, neighborNode);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport default BiBFSPathfinder;","import Navigator from '../core/Navigator';\r\nimport PlusNavigator from '../core/PlusNavigator';\r\nimport {Point} from '../core/Components';\r\nimport {Grid} from '../core/Grid';\r\nimport {chebyshev, euclidean, HeuristicFunc, manhattan, nullHeuristic, octile} from './Heuristics';\r\nimport Pathfinder from './Pathfinder';\r\nimport AStarPathfinder from './AStar';\r\nimport BFSPathfinder from './BFS';\r\nimport DFSPathfinder from './DFS';\r\nimport BiAStarPathfinder from './BidirectionalAStar';\r\nimport BiBFSPathfinder from \"./BidirectionalBFS\";\r\n\r\nconst CREATE_NAVIGATOR: {[key: string]: ((grid: Grid) => Navigator)} = {\r\n    'plus': (grid: Grid) => new PlusNavigator(grid),\r\n}\r\n\r\nconst CREATE_HEURISTIC: {[key: string]: (() => HeuristicFunc)} = {\r\n    'manhattan': () => manhattan,\r\n    'euclidean': () => euclidean,\r\n    'chebyshev': () => chebyshev,\r\n    'octile': () => octile,\r\n    'null': () => nullHeuristic\r\n}\r\n\r\nconst CREATE_PATHFINDER: {[key: string]: ((navigator: Navigator, heuristic: HeuristicFunc) => Pathfinder)} = {\r\n    'dijkstra': (navigator) => {\r\n        return new (class DijkstraPathfinder extends AStarPathfinder {\r\n            getAlgorithmName(): string {\r\n                return 'Dijkstra';\r\n            }\r\n        })(navigator, nullHeuristic);\r\n    },\r\n    'best-first': (navigator, heuristic) => {\r\n        return new (class BestFirstPathfinder extends AStarPathfinder {\r\n            stepCost(currentPoint: Point, neighborPoint: Point) {\r\n                return 0;\r\n            }\r\n            getAlgorithmName(): string {\r\n                return 'Best-First Search';\r\n            }\r\n        })(navigator, heuristic);\r\n    },\r\n    'a*': (navigator, heuristic) => {\r\n        return new AStarPathfinder(navigator, heuristic);\r\n    },\r\n    'bfs': (navigator) => {\r\n        return new BFSPathfinder(navigator);\r\n    },\r\n    'dfs': (navigator) => {\r\n        return new DFSPathfinder(navigator);\r\n    },\r\n    'bi-a*': (navigator, heuristic) => {\r\n        return new BiAStarPathfinder(navigator, heuristic);\r\n    },\r\n    'bi-dijkstra': (navigator) => {\r\n        return new (class BiDijkstraPathfinder extends BiAStarPathfinder {\r\n            getAlgorithmName(): string {\r\n                return 'Bidirectional Dijkstra';\r\n            }\r\n        })(navigator, nullHeuristic);\r\n    },\r\n    'bi-bfs': (navigator) => {\r\n        return new BiBFSPathfinder(navigator);\r\n    }\r\n}\r\n\r\nclass PathfinderBuilder\r\n{\r\n    private navigator: string = 'plus';\r\n    private algorithm: string = 'a*';\r\n    private heuristic: string = 'null';\r\n    private readonly grid: Readonly<Grid>;\r\n\r\n    constructor(grid: Readonly<Grid>) {\r\n        this.grid = grid;\r\n    }\r\n\r\n    setNavigator(navigator: string) {\r\n        navigator = navigator.toLowerCase();\r\n        if(CREATE_NAVIGATOR[navigator] == null) {\r\n            throw new Error('No such navigator pattern exists')\r\n        } else {\r\n            this.navigator = navigator;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    setAlgorithm(algorithm: string) {\r\n        algorithm = algorithm.toLowerCase();\r\n        if(CREATE_PATHFINDER[algorithm] == null) {\r\n            throw new Error('No such pathfinding algorithm exists')\r\n        } else {\r\n            this.algorithm = algorithm;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    setHeuristic(heuristic: string) {\r\n        heuristic = heuristic.toLowerCase();\r\n        if(CREATE_HEURISTIC[heuristic] == null) {\r\n            throw new Error('No such heuristic function exists')\r\n        } else {\r\n            this.heuristic = heuristic;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Builds a pathfinder with a navigator with the set algorithm, heuristic, and navigator\r\n     */\r\n    build() {\r\n        const createHeuristic = CREATE_HEURISTIC[this.heuristic];\r\n        const createNavigator = CREATE_NAVIGATOR[this.navigator];\r\n        const createPathfinder = CREATE_PATHFINDER[this.algorithm];\r\n        return createPathfinder(createNavigator(this.grid), createHeuristic());\r\n    }\r\n\r\n    static usesHeuristic(algorithm: string) {\r\n        return algorithm === 'a*' || algorithm === 'bi-a*' ||\r\n            algorithm === 'best-first';\r\n    }\r\n\r\n    static hasBidirectional(algorithm: string) {\r\n        return CREATE_PATHFINDER['bi-' + algorithm] != null;\r\n    }\r\n\r\n    static makeBidirectional(algorithm: string) {\r\n        return 'bi-' + algorithm;\r\n    }\r\n}\r\n\r\nexport default PathfinderBuilder;\r\n\r\n","class VirtualTimer\r\n{\r\n    private timeout: NodeJS.Timeout;\r\n    private readonly callback: () => void\r\n    private timeStarted: number;\r\n    private timeRemaining: number;\r\n    private finished: boolean;\r\n\r\n    constructor(callback: () => void, countDown: number) {\r\n        this.callback = callback;\r\n        this.finished = false;\r\n        this.timeStarted = Date.now();\r\n        this.timeRemaining = countDown;\r\n        this.timeout = setTimeout(() => {\r\n            callback();\r\n            this.finished = true;\r\n        }, this.timeRemaining);\r\n    }\r\n\r\n    clear() {\r\n        clearTimeout(this.timeout);\r\n        this.finished = true;\r\n    }\r\n\r\n    pause() {\r\n        if(!this.finished) {\r\n            clearTimeout(this.timeout);\r\n            this.timeRemaining -= Date.now() - this.timeStarted;\r\n        }\r\n    }\r\n\r\n    resume() {\r\n        if(!this.finished) {\r\n            this.timeStarted = Date.now();\r\n            this.timeout = setTimeout(() => {\r\n                this.callback();\r\n                this.finished = true;\r\n            }, this.timeRemaining);\r\n        }\r\n    }\r\n\r\n    isFinished() {\r\n        return this.finished;\r\n    }\r\n\r\n    getNativeTimeout() {\r\n        return this.timeout;\r\n    }\r\n}\r\n\r\nexport default VirtualTimer;","import {createTile, Point, Tile, TileData} from '../core/Components';\r\nimport {Grid} from '../core/Grid';\r\nimport {HashSet, stringify} from '../structures/Hash';\r\n\r\nabstract class TerrainGenerator\r\n{\r\n    protected readonly width: number;\r\n    protected readonly height: number;\r\n    protected readonly ignore: HashSet;\r\n    protected readonly data: TileData;\r\n\r\n    protected constructor(width: number, height: number, data?: TileData, ignore?: Point[]) {\r\n        this.width = width;\r\n        this.height = height;\r\n        this.ignore = new HashSet();\r\n        if(data !== undefined) {\r\n            this.data = data;\r\n        } else {\r\n            this.data = createTile(true);\r\n        }\r\n        if(ignore !== undefined) {\r\n            for(const i of ignore) {\r\n                this.ignore.add(stringify(i));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draws a tile to the grid\r\n     * @param grid\r\n     * @param tile\r\n     */\r\n    protected draw(grid: Grid, tile: Tile) {\r\n        if(!this.shouldIgnore(tile.point)) {\r\n            grid.mutateTile(tile);\r\n        }\r\n    }\r\n\r\n    protected getTerrain() {\r\n        return this.data;\r\n    }\r\n\r\n    protected getSolid() {\r\n        return {\r\n            pathCost: 1,\r\n            isSolid: true\r\n        }\r\n    }\r\n\r\n    protected shouldIgnore(point: Point) {\r\n        return this.ignore.has(stringify(point));\r\n    }\r\n\r\n    abstract generateTerrain(topLeft?: Point, bottomRight?: Point): Grid;\r\n}\r\n\r\nexport default TerrainGenerator;","import TerrainGenerator from './TerrainGenerator';\r\nimport {Point, TileData} from '../core/Components';\r\nimport RectGrid, {Grid} from '../core/Grid';\r\n\r\nclass TerrainRandomGenerator extends TerrainGenerator\r\n{\r\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\r\n    constructor(width: number, height: number, tileData?: TileData, ignore?: Point[]) {\r\n        super(width, height, tileData, ignore);\r\n    }\r\n\r\n    /**\r\n     * Performs a random terrain generation algorithm where each tile has a 1/4\r\n     * chance of being solid\r\n     * @param topLeft optional parameter to specify what point the terrain should start from\r\n     *  This should not be further up/left than (1,1)\r\n     * @param bottomRight optional parameter to specify how far down and right the terrain will go\r\n     *  This should not be further right/down than (width-2,height-2)\r\n     */\r\n    generateTerrain(topLeft?: Point, bottomRight?: Point): Grid {\r\n        const grid = new RectGrid(this.width, this.height);\r\n        if(topLeft === undefined) {\r\n            topLeft = {\r\n                x: 1, y: 1\r\n            }\r\n        }\r\n        if(bottomRight === undefined) {\r\n            bottomRight = {\r\n                x: grid.getWidth()-2,\r\n                y: grid.getHeight()-2\r\n            }\r\n        }\r\n        for(let x = topLeft.x - 1; x <= bottomRight.x + 1; x++) {\r\n            for(let y = topLeft.y - 1; y <= bottomRight.y + 1; y++) {\r\n                if(getRand(0, 3) === 0) {\r\n                    this.draw(grid,{\r\n                        point: {\r\n                            x: x, y: y\r\n                        },\r\n                        data: this.getTerrain()\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        return grid;\r\n    }\r\n}\r\n\r\n/**\r\n * Generate a random number between min and max, inclusive for min and max\r\n * @param min\r\n * @param max\r\n */\r\nfunction getRand(min: number, max: number) {\r\n    return Math.floor(Math.random() * (max+1-min) + min);\r\n}\r\n\r\nexport default TerrainRandomGenerator;","import RectGrid, {Grid} from '../core/Grid';\r\nimport {Point, Tile, createTile, TileData} from '../core/Components';\r\nimport TerrainGenerator from './TerrainGenerator';\r\n\r\nconst LIMIT = 2;\r\n\r\nexport const NO_SKEW = 0;\r\nexport const VERTICAL_SKEW = 1;\r\nexport const HORIZONTAL_SKEW = 2;\r\n\r\ninterface Chamber {\r\n    topLeft: Point; //min\r\n    bottomRight: Point; //max\r\n}\r\n\r\nclass TerrainMazeGenerator extends TerrainGenerator\r\n{\r\n    private readonly divideWidth: (width: number, height: number) => boolean;\r\n\r\n    constructor(width: number, height: number, tileData?: TileData, ignore?: Point[], slant?: number) {\r\n        super(width, height, tileData, ignore);\r\n        if(slant === undefined || slant === NO_SKEW) {\r\n            this.divideWidth = divideWidthNoSkew;\r\n        } else if(slant === VERTICAL_SKEW) {\r\n            this.divideWidth = divideWidthVSkew;\r\n        } else if(slant === HORIZONTAL_SKEW) {\r\n            this.divideWidth = divideWidthHSkew;\r\n        } else {\r\n            throw new Error(\"Invalid recursive maze division skew type\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Performs the recursive division maze generation algorithm on a new empty grid\r\n     * by bisecting parts until the maze can no longer be bisected\r\n     * Params must be within bounds and create a chamber\r\n     * @param topLeft optional parameter to specify what point the maze should start from\r\n     *  This should not be further up/left than (1,1)\r\n     * @param bottomRight optional parameter to specify how far down and right the maze will go\r\n     *  This should not be further right/down than (width-2,height-2)\r\n     */\r\n    generateTerrain(topLeft?: Point, bottomRight?: Point) {\r\n        const grid = new RectGrid(this.width, this.height);\r\n        if(topLeft === undefined) {\r\n            topLeft = {\r\n                x: 1, y: 1\r\n            }\r\n        }\r\n        if(bottomRight === undefined) {\r\n            bottomRight = {\r\n                x: grid.getWidth()-2,\r\n                y: grid.getHeight()-2\r\n            }\r\n        }\r\n        for(let x = topLeft.x - 1; x <= bottomRight.x + 1; x++) {\r\n            this.draw(grid,{\r\n                point: {\r\n                    x: x, y: topLeft.y - 1\r\n                },\r\n                data: this.getSolid()\r\n            });\r\n            this.draw(grid,{\r\n                point: {\r\n                    x: x, y: bottomRight.y + 1\r\n                },\r\n                data: this.getSolid()\r\n            });\r\n        }\r\n        for(let y = topLeft.y - 1; y <= bottomRight.y + 1; y++) {\r\n            this.draw(grid,{\r\n                point: {\r\n                    x: topLeft.x - 1, y: y\r\n                },\r\n                data: this.getSolid()\r\n            });\r\n            this.draw(grid,{\r\n                point: {\r\n                    x: bottomRight.x + 1, y: y\r\n                },\r\n                data: this.getSolid()\r\n            });\r\n        }\r\n        this.divide(grid,{\r\n            topLeft: topLeft,\r\n            bottomRight: bottomRight,\r\n        });\r\n        return grid;\r\n    }\r\n\r\n    /**\r\n     * Draws a list of tiles to the grid\r\n     * @param grid\r\n     * @param tiles\r\n     */\r\n    private drawArr(grid: Grid, tiles: Tile[]) {\r\n        for(const tile of tiles) {\r\n            this.draw(grid, tile);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a line between a region, with an open hole, in a chamber,\r\n     * and call bisection algorithm on it, and call division algorithms on\r\n     * its split chambers until no chambers can be bisected\r\n     * @param grid\r\n     * @param chamber\r\n     */\r\n    divide(grid: Grid, chamber: Chamber) {\r\n        const width = widthOf(chamber);\r\n        const height = heightOf(chamber);\r\n        const min = chamber.topLeft;\r\n        const max = chamber.bottomRight;\r\n        if(this.divideWidth(width,height)) {\r\n            if(width > LIMIT) {\r\n                //calculate axis\r\n                const randX = getMidPoint(\r\n                    min.x, max.x\r\n                );\r\n                //create axis wall\r\n                const toDraw: Tile[] = [];\r\n                for(let y = min.y; y <= max.y; y++) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: randX, y: y\r\n                        },\r\n                        data: this.getTerrain()\r\n                    });\r\n                }\r\n                //create holes in axis wall\r\n                let edgeBlocked = false;\r\n                if(canDrawHole(grid.get({\r\n                    x: randX, y: min.y-1\r\n                }))) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: randX, y: min.y\r\n                        },\r\n                        data: createTile(false)\r\n                    });\r\n                    edgeBlocked = true;\r\n                }\r\n                if(canDrawHole(grid.get({\r\n                    x: randX, y: max.y+1\r\n                }))) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: randX, y: max.y\r\n                        },\r\n                        data: createTile(false)\r\n                    });\r\n                    edgeBlocked = true;\r\n                }\r\n                if(!edgeBlocked) {\r\n                    const randY = getRand(\r\n                        min.y, max.y,\r\n                    );\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: randX, y: randY\r\n                        },\r\n                        data: createTile(false)\r\n                    });\r\n                }\r\n                this.drawArr(grid, toDraw);\r\n                //create children chambers and recurse\r\n                const leftChamber = {\r\n                    topLeft: chamber.topLeft,\r\n                    bottomRight: {\r\n                        x: randX-1,\r\n                        y: chamber.bottomRight.y\r\n                    },\r\n                };\r\n                const rightChamber = {\r\n                    topLeft: {\r\n                        x: randX+1,\r\n                        y: chamber.topLeft.y\r\n                    },\r\n                    bottomRight: chamber.bottomRight,\r\n                };\r\n                this.divide(grid, leftChamber);\r\n                this.divide(grid, rightChamber);\r\n            }\r\n        } else {\r\n            if(height > LIMIT) {\r\n                //calculate axis\r\n                const randY = getMidPoint(\r\n                    min.y, max.y\r\n                );\r\n                //draw axis wall\r\n                const toDraw: Tile[] = [];\r\n                for(let x = min.x; x <= max.x; x++) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: x, y: randY\r\n                        },\r\n                        data: this.getTerrain()\r\n                    });\r\n                }\r\n                //create holes in axis wall\r\n                let edgeBlocked = false;\r\n                if(canDrawHole(grid.get({\r\n                    x: min.x-1, y: randY\r\n                }))) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: min.x, y: randY\r\n                        },\r\n                        data: createTile(false)\r\n                    });\r\n                    edgeBlocked = true;\r\n                }\r\n                if(canDrawHole(grid.get({\r\n                    x: max.x+1, y: randY\r\n                }))) {\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: max.x, y: randY\r\n                        },\r\n                        data: createTile(false)\r\n                    });\r\n                    edgeBlocked = true;\r\n                }\r\n                if(!edgeBlocked) {\r\n                    const randX = getRand(\r\n                        min.x, max.x,\r\n                    );\r\n                    toDraw.push({\r\n                        point: {\r\n                            x: randX, y: randY\r\n                        },\r\n                        data: createTile(false)\r\n                    });\r\n                }\r\n                this.drawArr(grid, toDraw);\r\n                //create children chambers and recurse\r\n                const topChamber = {\r\n                    topLeft: chamber.topLeft,\r\n                    bottomRight: {\r\n                        x: chamber.bottomRight.x,\r\n                        y: randY-1\r\n                    },\r\n                };\r\n                const bottomChamber = {\r\n                    topLeft: {\r\n                        x: chamber.topLeft.x,\r\n                        y: randY+1\r\n                    },\r\n                    bottomRight: chamber.bottomRight,\r\n                };\r\n                this.divide(grid, topChamber);\r\n                this.divide(grid, bottomChamber);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction divideWidthNoSkew(width: number, height: number) {\r\n    return width >= height;\r\n}\r\n\r\nfunction divideWidthHSkew(width: number, height: number) {\r\n    return width >= height * 2;\r\n}\r\n\r\nfunction divideWidthVSkew(width: number, height: number) {\r\n    return width * 2 >= height;\r\n}\r\n\r\nfunction widthOf(chamber: Chamber) {\r\n    return chamber.bottomRight.x - chamber.topLeft.x + 1;\r\n}\r\n\r\nfunction heightOf(chamber: Chamber) {\r\n    return chamber.bottomRight.y - chamber.topLeft.y + 1;\r\n}\r\n\r\nfunction canDrawHole(tile: Tile) {\r\n    return tile.data.pathCost === 1 && !tile.data.isSolid;\r\n}\r\n\r\n/**\r\n * Returns the 'midpoint' to be used\r\n * @param min\r\n * @param max\r\n */\r\nfunction getMidPoint(min: number, max: number) {\r\n    const range = max - min;\r\n    if(range >= 20) {\r\n        return ((min+max)/2) >> 0;\r\n    } else if(range > 5) {\r\n        const mid = ((min+max)/2) >> 0;\r\n        const points = [mid, mid+1];\r\n        return points[getRand(0,points.length-1)];\r\n    } else {\r\n        return getRand(min+1,max-1);\r\n    }\r\n}\r\n\r\n/**\r\n * Generate a random number between min and max, inclusive for min and max\r\n * @param min\r\n * @param max\r\n */\r\nfunction getRand(min: number, max: number) {\r\n    return Math.floor(Math.random() * (max+1-min) + min);\r\n}\r\n\r\nexport default TerrainMazeGenerator;","import TerrainRandomGenerator from './TerrainRandomGenerator';\r\nimport TerrainMazeGenerator from './TerrainMazeGenerator';\r\nimport {createTile, Point, TileData} from '../core/Components';\r\n\r\nexport const MAZE = 0;\r\nexport const MAZE_VERTICAL_SKEW = 1;\r\nexport const MAZE_HORIZONTAL_SKEW = 2;\r\nexport const RANDOM_TERRAIN = 3;\r\n\r\nclass TerrainGeneratorBuilder\r\n{\r\n    private width: number = 0;\r\n    private height: number = 0;\r\n    private type: number = MAZE;\r\n    private ignore: Point[] = [];\r\n    private data: TileData = createTile(true);\r\n\r\n    setDimensions(width: number, height: number) {\r\n        this.width = width;\r\n        this.height = height;\r\n        return this;\r\n    }\r\n\r\n    setGeneratorType(type: number) {\r\n        this.type = type;\r\n        return this;\r\n    }\r\n\r\n    setIgnorePoints(ignore: Point[]) {\r\n        this.ignore = ignore.slice();\r\n        return this;\r\n    }\r\n\r\n    setTileData(data: TileData) {\r\n        this.data = data;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Builds a terrain generator with the specified type\r\n     */\r\n    build() {\r\n       if(this.type >= RANDOM_TERRAIN) {\r\n           return new TerrainRandomGenerator(this.width, this.height, this.data, this.ignore);\r\n       } else {\r\n           return new TerrainMazeGenerator(this.width, this.height, this.data, this.ignore, this.type);\r\n       }\r\n    }\r\n}\r\n\r\nexport default TerrainGeneratorBuilder;","import React, {RefObject} from 'react';\r\nimport './Grid.css';\r\nimport GridBackground from './GridBackground';\r\nimport GridForeground from './GridForeground';\r\nimport StatsPanel from './StatsPanel';\r\nimport {Node} from '../../pathfinding/algorithms/Node';\r\nimport PathfindingSettings from '../PathfindingSettings';\r\nimport PathfinderBuilder from '../../pathfinding/algorithms/PathfinderBuilder';\r\nimport Pathfinder from '../../pathfinding/algorithms/Pathfinder';\r\nimport {createTile, Point, Tile, TileData} from '../../pathfinding/core/Components';\r\nimport {euclidean} from '../../pathfinding/algorithms/Heuristics';\r\nimport VirtualTimer from '../utility/VirtualTimer';\r\nimport TerrainGeneratorBuilder, {RANDOM_TERRAIN} from '../../pathfinding/algorithms/TerrainGeneratorBuilder';\r\n\r\ninterface IProps {\r\n    tileWidth: number,\r\n    settings: Readonly<PathfindingSettings>,\r\n    onChangeVisualizing: (visualizing: boolean) => void;\r\n}\r\n\r\ninterface IState {\r\n    time: number,\r\n    length: number,\r\n    cost: number,\r\n    nodes: number,\r\n    algorithm: string,\r\n    weightOpacity: number\r\n}\r\n\r\nclass PathfindingVisualizer extends React.Component<IProps,IState>\r\n{\r\n    //references to expose background and foreground grids to parent\r\n    private background: RefObject<GridBackground> = React.createRef();\r\n    private foreground: RefObject<GridForeground> = React.createRef();\r\n    private stats: RefObject<StatsPanel> = React.createRef();\r\n\r\n    private visualized = false;\r\n    private visualizing = false;\r\n    private visualTimeouts: VirtualTimer[]  = [];\r\n    private generations: Node[] = [];\r\n\r\n    private mazeTile: TileData = createTile(true);\r\n\r\n    private readonly tilesX: number;\r\n    private readonly tilesY: number;\r\n    private readonly tileWidth: number\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        const w = window.screen.availWidth - (window.outerWidth - window.innerWidth);\r\n        const h = window.screen.availHeight - (window.outerHeight - window.innerHeight);\r\n        this.tileWidth = this.props.tileWidth;\r\n        this.tilesX = Math.floor(w / this.tileWidth) + 1;\r\n        this.tilesY = Math.floor((h - 75 - 30) / this.tileWidth) + 1;\r\n        this.state = {\r\n            time: -1,\r\n            length: -1,\r\n            cost: -1,\r\n            nodes: -1,\r\n            algorithm: '',\r\n            weightOpacity: 1\r\n        }\r\n    }\r\n\r\n    shouldComponentUpdate(nextProps: Readonly<IProps>, nextState: Readonly<IState>) {\r\n        const prevState = this.state;\r\n        return prevState.time !== nextState.time ||\r\n            prevState.length !== nextState.length ||\r\n            prevState.cost !== nextState.cost ||\r\n            prevState.nodes !== nextState.nodes ||\r\n            prevState.algorithm !== nextState.algorithm ||\r\n            prevState.weightOpacity !== nextState.weightOpacity;\r\n    }\r\n\r\n    changeTile(data: TileData) {\r\n        this.mazeTile = data; //enables weighted mazes\r\n        this.foreground.current!.changeTile(data);\r\n    }\r\n\r\n    canShowArrows() {\r\n        const settings = this.props.settings;\r\n        return settings.showArrows && settings.algorithm !== 'dfs';\r\n    }\r\n\r\n    canShowFrontier() {\r\n        const settings = this.props.settings;\r\n        return settings.visualizeAlg;\r\n    }\r\n\r\n    /**\r\n     * Pause the delayed pathfinding algorithm being performed\r\n     */\r\n    pausePathfinding() {\r\n        for(const timeout of this.visualTimeouts) {\r\n            timeout.pause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resume the delayed pathfinding algorithm being performed\r\n     * Will reset the timeouts to the last time the timeout was paused/started\r\n     * if not properly called while the timeout is paused\r\n     */\r\n    resumePathfinding() {\r\n        for(const timeout of this.visualTimeouts) {\r\n            timeout.resume();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Performs the pathfinding algorithm on the grid and visualizes it\r\n     */\r\n    doPathfinding() {\r\n        this.clearPath();\r\n        const settings = this.props.settings;\r\n        const pathfinder = this.getPathfinder(settings);\r\n        const path = this.findPath(pathfinder);\r\n        this.generations = pathfinder.getRecentGenerations();\r\n        if(this.canShowArrows()) {\r\n            this.addArrowGenerations(this.generations);\r\n        }\r\n        if(this.canShowFrontier()) {\r\n            this.visualizeGenerations(this.generations);\r\n        }\r\n        this.drawPath(path);\r\n    }\r\n\r\n    /**\r\n     * Performs the pathfinding algorithm on the grid and visualizes it with delays between successive\r\n     * node generations\r\n     * If the visualizer is currently visualizing, the visualization stops instead\r\n     */\r\n    doDelayedPathfinding() {\r\n        this.clearVisualization();\r\n        this.clearPath();\r\n        const settings = this.props.settings;\r\n        this.visualized = false;\r\n        const foreground = this.foreground.current!;\r\n        foreground.toggleDisable();\r\n        if(!this.visualizing) { //start visualization if not visualizing\r\n            this.visualizing = true;\r\n            this.props.onChangeVisualizing(this.visualizing);\r\n            const pathfinder = this.getPathfinder(settings);\r\n            const path = this.findPath(pathfinder);\r\n            const promises: Promise<VirtualTimer>[] = []; //to call function when timeouts finish\r\n            this.visualTimeouts = [];\r\n            const baseIncrement = settings.delayInc;\r\n            let delay = 0;\r\n            const visualizeAlg = this.canShowFrontier();\r\n            const showArrows = this.canShowArrows();\r\n            if(showArrows || visualizeAlg) {\r\n                let expand: (generation: Node) => void;\r\n                if(visualizeAlg && showArrows) {\r\n                    expand = (generation: Node) => this.visualizeGenerationAndArrows(generation);\r\n                } else if(visualizeAlg) {\r\n                    expand = (generation: Node) => this.visualizeGeneration(generation);\r\n                } else if(showArrows) {\r\n                    expand = (generation: Node) => this.addArrowGeneration(generation);\r\n                } else {\r\n                    expand = () => {};\r\n                }\r\n                this.generations = pathfinder.getRecentGenerations();\r\n                this.generations.forEach((generation) => {\r\n                    const promise = new Promise<VirtualTimer>((resolve) => {\r\n                        //each generation gets a higher timeout\r\n                        const timeout = new VirtualTimer(() => {\r\n                            expand(generation)\r\n                            resolve(timeout);\r\n                        }, delay);\r\n                        this.visualTimeouts.push(timeout);\r\n                    });\r\n                    promises.push(promise);\r\n                    delay += baseIncrement;\r\n                });\r\n            }\r\n            //call functions when timeouts finish\r\n            Promise.all(promises).then(() => {\r\n                this.drawPath(path);\r\n                foreground.toggleDisable();\r\n                this.visualizing = false;\r\n                this.visualized = true;\r\n                this.props.onChangeVisualizing(this.visualizing);\r\n            });\r\n        } else { //stop visualizing if visualizing\r\n            for (const timeout of this.visualTimeouts) {\r\n                timeout.clear();\r\n            }\r\n            this.visualizing = false;\r\n            this.props.onChangeVisualizing(this.visualizing);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the pathfinder for the settings\r\n     * @param settings\r\n     */\r\n    getPathfinder(settings: PathfindingSettings) {\r\n        const algorithmKey = settings.algorithm;\r\n        const algorithm = settings.bidirectional && PathfinderBuilder.hasBidirectional(algorithmKey) ?\r\n            PathfinderBuilder.makeBidirectional(algorithmKey) : algorithmKey;\r\n        return new PathfinderBuilder(this.foreground.current!.state.grid)\r\n            .setAlgorithm(algorithm)\r\n            .setHeuristic(settings.heuristicKey)\r\n            .setNavigator(settings.navigatorKey)\r\n            .build();\r\n    }\r\n\r\n    /**\r\n     * Find path with a given pathfinder, includes benchmarking\r\n     * @param pathfinder\r\n     */\r\n     findPath(pathfinder: Pathfinder) {\r\n        const foreground = this.foreground.current!;\r\n        const t0 = performance.now();\r\n        const path = pathfinder.findPath(foreground.state.initial, foreground.state.goal);\r\n        const t1 = performance.now();\r\n        const t2 = (t1 - t0);\r\n        this.setState({\r\n            time: t2,\r\n            nodes: pathfinder.getRecentNodes(),\r\n            length: calcLength(foreground.state.initial, path),\r\n            cost: calcCost(foreground.state.grid.get(foreground.state.initial), path),\r\n            algorithm: pathfinder.getAlgorithmName()\r\n        });\r\n        return path;\r\n    }\r\n\r\n    /**\r\n     * Draw path on the grid and change length on ui\r\n     * @param path\r\n     */\r\n    drawPath(path: Tile[]) {\r\n        const foreground = this.foreground.current!\r\n        path.unshift(this.foreground.current!.state.grid.get(foreground.state.initial));\r\n        this.foreground.current!.drawPath(path);\r\n    }\r\n\r\n    /**\r\n     * Called when child foreground moves a tile\r\n     */\r\n    onTilesDragged() {\r\n        if(this.visualized) {\r\n            this.clearVisualization();\r\n            this.doPathfinding();\r\n            this.visualized = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create terrain on the grid foreground\r\n     */\r\n    createTerrain(mazeType: number) {\r\n        if(this.visualizing) {\r\n            return;\r\n        }\r\n        this.clearTiles();\r\n        this.clearPath();\r\n        this.clearVisualization();\r\n        const foreground = this.foreground.current!;\r\n        const end = this.calcEndPointInView();\r\n        const newState = (mazeType !== RANDOM_TERRAIN) ? {\r\n            initial: {\r\n                x: 1, y: 1\r\n            },\r\n            goal: {\r\n                x: end.x-2, y: end.y-2\r\n            }\r\n        } : {\r\n            initial: {\r\n                x: 1, y: ((end.y-1) / 2) >> 0\r\n            },\r\n            goal: {\r\n                x: end.x-2, y: ((end.y-1) / 2) >> 0\r\n            }\r\n        };\r\n        foreground.setState(newState,() => {\r\n            const prevGrid = foreground.state.grid;\r\n            const generator = new TerrainGeneratorBuilder()\r\n                .setDimensions(\r\n                    prevGrid.getWidth(),\r\n                    prevGrid.getHeight()\r\n                )\r\n                .setGeneratorType(mazeType)\r\n                .setIgnorePoints([foreground.state.initial, foreground.state.goal])\r\n                .setTileData(this.mazeTile)\r\n                .build();\r\n            const topLeft = {\r\n                x: 1, y: 1\r\n            };\r\n            const bottomRight = {\r\n                x: end.x-2, y: end.y-2\r\n            };\r\n            const grid = generator.generateTerrain(topLeft, bottomRight);\r\n            foreground.drawGrid(grid);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Calculate the end/goal point in view of the screen\r\n     */\r\n    calcEndPointInView() {\r\n        const xEnd = window.innerWidth / this.tileWidth;\r\n        const yEnd = (window.innerHeight - 75 - this.stats.current!.getHeight()) / this.tileWidth;\r\n        const xFloor = Math.floor(xEnd);\r\n        const yFloor = Math.floor(yEnd);\r\n        const xDecimal = xEnd - xFloor;\r\n        const yDecimal = yEnd - yFloor;\r\n        let x = xDecimal > 0.05 ? Math.ceil(xEnd) : xFloor;\r\n        let y = yDecimal > 0.05 ? Math.ceil(yEnd) : yFloor;\r\n        if(x > this.tilesX) {\r\n            x = this.tilesX\r\n        }\r\n        if(y > this.tilesY) {\r\n            y = this.tilesY\r\n        }\r\n        return {\r\n            x: x, y: y\r\n        }\r\n    }\r\n\r\n    resetPoints() {\r\n        if(!this.visualizing) {\r\n            this.foreground.current!.resetPoints();\r\n        }\r\n    }\r\n\r\n    clearPath = () => {\r\n        this.foreground.current!.erasePath();\r\n    }\r\n\r\n    clearTiles() {\r\n        this.foreground.current!.clearTiles();\r\n    }\r\n\r\n    clearTilesChecked() {\r\n        if(!this.visualizing) {\r\n            this.foreground.current!.clearTiles();\r\n        }\r\n    }\r\n\r\n    clearVisualization() {\r\n        this.visualized = false;\r\n        this.background.current!.clear();\r\n    }\r\n\r\n    clearVisualizationChecked() {\r\n        if(!this.visualizing) {\r\n            this.visualized = false;\r\n            this.background.current!.clear();\r\n        }\r\n    }\r\n\r\n    visualizeGenerations(generations: Node[]) {\r\n        this.background.current!.visualizeGenerations(generations);\r\n        this.visualized = true;\r\n    }\r\n\r\n    visualizeGeneration(generation: Node) {\r\n        this.background.current!.visualizeGeneration(generation);\r\n    }\r\n\r\n    addArrowGenerations(generations: Node[]) {\r\n        this.background.current!.addArrowGenerations(generations);\r\n    }\r\n\r\n    addArrowGeneration(generation: Node) {\r\n        this.background.current!.addArrowGeneration(generation);\r\n    }\r\n\r\n    visualizeGenerationAndArrows(generation: Node) {\r\n        this.background.current!.visualizeGenerationAndArrows(generation);\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <StatsPanel ref={this.stats} algorithm={this.state.algorithm}\r\n                            length={this.state.length} cost={this.state.cost}\r\n                            time={this.state.time} nodes={this.state.nodes}\r\n                />\r\n                <div>\r\n                    <GridBackground ref={this.background} tileWidth={this.tileWidth}\r\n                                    tilesX={this.tilesX} tilesY={this.tilesY}\r\n                    />\r\n                    <GridForeground ref={this.foreground} topMargin={75}\r\n                                    onTilesDragged={() => this.onTilesDragged()} tileSize={this.tileWidth}\r\n                                    tilesX={this.tilesX} tilesY={this.tilesY}\r\n                                    weightOpacity={this.state.weightOpacity}\r\n                    />\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nfunction calcLength(initial: Point, path: Tile[]) {\r\n    if(path.length === 0) {\r\n        return 0;\r\n    }\r\n    let len = euclidean(initial, path[0].point);\r\n    for (let i = 0; i < path.length - 1; i++) {\r\n        len += euclidean(path[i].point, path[i + 1].point);\r\n    }\r\n    return +(len).toFixed(3);\r\n}\r\n\r\nfunction calcCost(initial: Tile, path: Tile[]) {\r\n    if(path.length === 0) {\r\n        return 0;\r\n    }\r\n    let len = euclidean(initial.point, path[0].point) * path[0].data.pathCost;\r\n    for (let i = 0; i < path.length - 1; i++) {\r\n        len += euclidean(path[i].point, path[i + 1].point) * path[i + 1].data.pathCost;\r\n    }\r\n    return +(len).toFixed(3);\r\n}\r\n\r\nexport default PathfindingVisualizer;","import React from 'react';\r\n\r\ninterface IProps {\r\n    boxStyle: string,\r\n    defaultChecked: boolean,\r\n    disabled?: boolean,\r\n    onChange: (checked: boolean) => void\r\n}\r\n\r\ninterface IState {\r\n    checked: boolean\r\n}\r\n\r\nclass Checkbox extends React.Component<IProps,IState>\r\n{\r\n    public static defaultProps = {\r\n        disabled: false\r\n    };\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.state = {\r\n            checked: this.props.defaultChecked\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Trigger callback and change checkbox state\r\n     */\r\n    onChange() {\r\n        this.setState(prevState => ({\r\n            checked: !prevState.checked\r\n        }), () => this.props.onChange(this.state.checked));\r\n    }\r\n\r\n    render() {\r\n        return(\r\n            <div>\r\n                <input checked={this.state.checked} type='checkbox' disabled={this.props.disabled}\r\n                       className={this.props.boxStyle}\r\n                       onKeyPress={() => this.onChange()}\r\n                       onChange={() => this.onChange()}\r\n                >\r\n                </input>\r\n                {this.props.children}\r\n            </div>\r\n        );\r\n    };\r\n}\r\n\r\nexport default Checkbox;","import React from 'react';\r\n\r\ninterface IProps {\r\n    min: number,\r\n    max: number,\r\n    default: number,\r\n    step: number,\r\n    sliderStyle: string,\r\n    onChange: (val: number) => void\r\n}\r\n\r\ninterface IState {\r\n    value: number\r\n}\r\n\r\nclass SteppedRangeSlider extends React.Component<IProps, IState>\r\n{\r\n    private mouseUp = true;\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.state = {\r\n            value: this.props.default\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Trigger callback when slider value is changed\r\n     * @param e\r\n     */\r\n    onChange(e: React.FormEvent<HTMLInputElement>) {\r\n        if(!this.mouseUp) { //to prevent firefox from resetting on release\r\n            const val = Number(e.currentTarget.value);\r\n            this.setState({\r\n                value: val\r\n            }, () => this.props.onChange(val));\r\n        }\r\n    }\r\n\r\n    onMouseUp() {\r\n        this.mouseUp = true;\r\n    }\r\n\r\n    onMouseDown() {\r\n        this.mouseUp = false;\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <input type='range' list='step-list'\r\n                   value={this.state.value}\r\n                   min={this.props.min} max={this.props.max}\r\n                   step={this.props.step} className={this.props.sliderStyle}\r\n                   onInput={e => this.onChange(e)}\r\n                   onMouseUp={() => this.onMouseUp()}\r\n                   onMouseDown={() => this.onMouseDown()}\r\n                   onTouchEnd={() => this.onMouseUp()}\r\n                   onTouchStart={() => this.onMouseDown()}\r\n            >\r\n            </input>\r\n        );\r\n    }\r\n}\r\n\r\nexport default SteppedRangeSlider;","import React from 'react';\r\n\r\ninterface IProps {\r\n    boxStyle: string,\r\n    defaultChecked: number,\r\n    disabled: boolean,\r\n    onChange: (() => void)[]\r\n}\r\n\r\ninterface IState {\r\n    checked: boolean[];\r\n}\r\n\r\nclass RadioButtonGroup extends React.Component<IProps, IState>\r\n{\r\n    public static defaultProps = {\r\n        disabled: false\r\n    };\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        const checked: boolean[] = [];\r\n        for(let i = 0; i < this.props.onChange.length; i++) {\r\n            checked.push(i === this.props.defaultChecked);\r\n        }\r\n        this.state = {\r\n            checked: checked\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set all radio buttons to checked aside from the index\r\n     * of the one that was changed\r\n     * Trigger callback\r\n     * @param index\r\n     */\r\n    onChange (index: number) {\r\n        const checked: boolean[] = [];\r\n        for(let i = 0; i < this.props.onChange.length; i++) {\r\n            checked.push(i === index);\r\n        }\r\n        this.setState({\r\n            checked: checked\r\n        }, () => this.props.onChange[index]());\r\n    }\r\n\r\n    render() {\r\n        const children = React.Children.toArray(this.props.children);\r\n        const radioButtons: JSX.Element[] = [];\r\n        for(let i = 0; i < this.props.onChange.length; i++) {\r\n            radioButtons.push(\r\n                <div key={i}>\r\n                    <input checked={this.state.checked[i]} type='radio' disabled={this.props.disabled}\r\n                           className={this.props.boxStyle}\r\n                           onChange={() => this.onChange(i)}\r\n                    >\r\n                    </input>\r\n                    {children[i]}\r\n                </div>\r\n            );\r\n        }\r\n        return radioButtons;\r\n    };\r\n}\r\n\r\nexport default RadioButtonGroup;","import React from 'react';\r\nimport './Navbar.css'\r\nimport Checkbox from '../utility/Checkbox';\r\nimport SteppedRangeSlider from '../utility/SteppedRangeSlider';\r\nimport RadioButtonGroup from '../utility/RadioButtonGroup';\r\n\r\ninterface VisualProps {\r\n    onChangeViz: () => void,\r\n    onChangeShowArrows: () => void,\r\n    onChangeWOpacity: () => void,\r\n    disabled: boolean\r\n}\r\n\r\ninterface SpeedProps {\r\n    onChange: (value: number) => void,\r\n    initialSpeed: number\r\n}\r\n\r\ninterface SpeedState {\r\n    speedText: string\r\n}\r\n\r\ninterface AlgorithmProps {\r\n    onChangeBidirectional: (checked: boolean) => void,\r\n    disabled: boolean\r\n}\r\n\r\ninterface HeuristicProps {\r\n    onClickManhattan: () => void,\r\n    onClickEuclidean: () => void,\r\n    onClickChebyshev: () => void,\r\n    onClickOctile: () => void,\r\n    disabled: boolean\r\n}\r\n\r\nconst SPEED_STEP = 2;\r\nconst SPEED_INITIAL = 4;\r\nconst MAX = 18;\r\n\r\nexport class VisualSettings extends React.Component<VisualProps>\r\n{\r\n    render() {\r\n        return (\r\n            <div>\r\n                <div className='draggable-content-title'>Visualization</div>\r\n                <Checkbox defaultChecked={true} boxStyle='box'\r\n                          onChange={this.props.onChangeViz}>\r\n                    Show Frontier\r\n                </Checkbox>\r\n                <Checkbox defaultChecked={true} boxStyle='box'\r\n                          onChange={this.props.onChangeShowArrows}\r\n                          disabled={this.props.disabled}>\r\n                    Show Tree\r\n                </Checkbox>\r\n                <Checkbox defaultChecked={false} boxStyle='box'\r\n                          onChange={this.props.onChangeWOpacity}>\r\n                    Translucent Weights\r\n                </Checkbox>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class SpeedSettings extends React.Component<SpeedProps, SpeedState>\r\n{\r\n    constructor(props: SpeedProps) {\r\n        super(props);\r\n        this.state = {\r\n            speedText: String(this.props.initialSpeed)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback function to be called when slider is changed\r\n     * Call another callback and change text\r\n     * @param value\r\n     */\r\n    onChangeSpeed(value: number) {\r\n        const speed = SPEED_INITIAL + SPEED_STEP * value;\r\n        this.setState({\r\n            speedText: String(speed)\r\n        })\r\n        this.props.onChange(speed);\r\n    }\r\n\r\n    render() {\r\n        const options: JSX.Element[] = [];\r\n        for(let i = 1; i <= MAX; i++) {\r\n            options.push(<option key={'option ' + i}>{i}</option>);\r\n        }\r\n        return (\r\n            <div className='slider-container'>\r\n                <div className='slider-text'>\r\n                    Speed: <div className='speed-text'> {this.state.speedText} </div>\r\n                </div>\r\n                    <SteppedRangeSlider min={1} max={MAX} step={1}\r\n                                        default={(this.props.initialSpeed - SPEED_INITIAL) / SPEED_STEP}\r\n                                        sliderStyle='slider speed-slider'\r\n                                        onChange={(value: number) => this.onChangeSpeed(value)}\r\n                />\r\n                <datalist id='step-list'>\r\n                    {options}\r\n                </datalist>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class AlgorithmSettings extends React.Component<AlgorithmProps>\r\n{\r\n    constructor(props: AlgorithmProps) {\r\n        super(props);\r\n        this.state = {\r\n            disabled: false\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <div className='draggable-content-title'>Algorithm</div>\r\n                <Checkbox defaultChecked={false} boxStyle='box'\r\n                          disabled={this.props.disabled}\r\n                          onChange={this.props.onChangeBidirectional}>\r\n                    Bidirectional\r\n                </Checkbox>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class HeuristicSettings extends React.Component<HeuristicProps>\r\n{\r\n    constructor(props: HeuristicProps) {\r\n        super(props);\r\n        this.state = {\r\n            disabled: false\r\n        }\r\n    }\r\n\r\n    disable() {\r\n        this.setState({\r\n            disabled: true\r\n        })\r\n    }\r\n\r\n    enable() {\r\n        this.setState({\r\n            disabled: false\r\n        })\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <div className='draggable-content-title'>Heuristic</div>\r\n                <RadioButtonGroup boxStyle='box'\r\n                                  defaultChecked={0}\r\n                                  disabled={this.props.disabled}\r\n                                  onChange={[\r\n                                      this.props.onClickManhattan, this.props.onClickEuclidean,\r\n                                      this.props.onClickChebyshev, this.props.onClickOctile\r\n                                  ]}\r\n                >\r\n                    {[<span key='Manhattan'>Manhattan</span>, <span key='Euclidean'>Euclidean</span>,\r\n                        <span key='Chebyshev'>Chebyshev</span>, <span key='Octile<'>Octile</span>]}\r\n                </RadioButtonGroup>\r\n            </div>\r\n        )\r\n    }\r\n}","import PathfindingSettings, {getDefaultSettings} from './PathfindingSettings';\r\n\r\nclass SettingsManager\r\n{\r\n    settings: PathfindingSettings = getDefaultSettings();\r\n\r\n    changeAlgo(algo: string) {\r\n        this.settings.algorithm = algo;\r\n    }\r\n\r\n    changeVisualize() {\r\n        this.settings.visualizeAlg = !this.settings.visualizeAlg;\r\n    }\r\n\r\n    changeShowArrows() {\r\n        this.settings.showArrows = !this.settings.showArrows;\r\n    }\r\n\r\n    changeBidirectional() {\r\n        this.settings.bidirectional = !this.settings.bidirectional;\r\n    }\r\n\r\n    changeSpeed(value: number) {\r\n        this.settings.delayInc = value;\r\n    }\r\n\r\n    changeManhattan() {\r\n        this.settings.heuristicKey = 'manhattan';\r\n    }\r\n\r\n    changeEuclidean() {\r\n        this.settings.heuristicKey = 'euclidean';\r\n    }\r\n\r\n    changeChebyshev() {\r\n        this.settings.heuristicKey = 'chebyshev';\r\n    }\r\n\r\n    changeOctile() {\r\n        this.settings.heuristicKey = 'octile';\r\n    }\r\n}\r\n\r\nexport default SettingsManager;","interface PathfindingSettings\r\n{\r\n    visualizeAlg: boolean,\r\n    showArrows: boolean,\r\n    delayInc: number,\r\n    algorithm: string,\r\n    heuristicKey: string,\r\n    navigatorKey: string,\r\n    bidirectional: boolean,\r\n}\r\n\r\nexport function getDefaultSettings(): PathfindingSettings {\r\n    return {\r\n        visualizeAlg: true,\r\n        showArrows: true,\r\n        delayInc: 8,\r\n        algorithm: 'a*',\r\n        heuristicKey: 'manhattan',\r\n        navigatorKey: 'plus',\r\n        bidirectional: false,\r\n    }\r\n}\r\n\r\nexport default PathfindingSettings;","export default __webpack_public_path__ + \"static/media/react.93a4bdf1.png\";","import React, {RefObject} from 'react';\r\nimport TopBar from './navbar/TopBar';\r\nimport {VisualizeButton, SettingsButton} from './navbar/Buttons';\r\nimport {AlgorithmDropDown, ClearDropDown, MazeDropDown, TilesDropDown} from './navbar/DropDownComponents';\r\nimport DraggablePanel from './utility/DraggablePanel';\r\nimport PathfindingVisualizer from './grid/PathfindingVisualizer';\r\nimport {VisualSettings, SpeedSettings, AlgorithmSettings, HeuristicSettings} from './navbar/SettingPanels';\r\nimport SettingsManager from './SettingsManager';\r\nimport PathfinderBuilder from '../pathfinding/algorithms/PathfinderBuilder';\r\nimport {MAZE, MAZE_HORIZONTAL_SKEW, MAZE_VERTICAL_SKEW, RANDOM_TERRAIN} from '../pathfinding/algorithms/TerrainGeneratorBuilder';\r\nimport Icon from './web-content/react.png';\r\n\r\ninterface IProps {}\r\n\r\ninterface IState {\r\n    heuristicDisabled: boolean,\r\n    bidirectionalDisabled: boolean,\r\n    arrowsDisabled: boolean,\r\n\r\n    panelShow: boolean,\r\n\r\n    visualizing: boolean,\r\n    paused: boolean\r\n}\r\n\r\nclass PathfindingApp extends React.Component<IProps, IState>\r\n{\r\n    //expose visualizer to parent to connect to button siblings\r\n    private visualizer: RefObject<PathfindingVisualizer> = React.createRef();\r\n\r\n    //drop down refs needed to invoke behavior between dropdowns\r\n    private algDropDown: RefObject<AlgorithmDropDown> = React.createRef();\r\n    private clrDropDown: RefObject<ClearDropDown> = React.createRef();\r\n    private mazeDropDown: RefObject<MazeDropDown> = React.createRef();\r\n    private tilesDropDown: RefObject<TilesDropDown> = React.createRef();\r\n\r\n    private settingsManager: SettingsManager = new SettingsManager();\r\n\r\n    constructor(props: IProps) {\r\n        super(props);\r\n        this.state = {\r\n            heuristicDisabled: false,\r\n            bidirectionalDisabled: false,\r\n            arrowsDisabled: false,\r\n            panelShow: false,\r\n            visualizing: false,\r\n            paused: false\r\n        }\r\n    }\r\n\r\n    componentDidMount() {\r\n        window.addEventListener('click', () => {\r\n            this.algDropDown.current!.hide();\r\n            this.clrDropDown.current!.hide();\r\n            this.mazeDropDown.current!.hide();\r\n            this.tilesDropDown.current!.hide();\r\n        });\r\n    }\r\n\r\n    onClickAlgDrop() {\r\n        this.clrDropDown.current!.hide();\r\n        this.mazeDropDown.current!.hide();\r\n        this.tilesDropDown.current!.hide();\r\n    }\r\n\r\n    onClickClrDrop() {\r\n        this.algDropDown.current!.hide();\r\n        this.mazeDropDown.current!.hide();\r\n        this.tilesDropDown.current!.hide();\r\n    }\r\n\r\n    onClickMazeDrop() {\r\n        this.clrDropDown.current!.hide();\r\n        this.algDropDown.current!.hide();\r\n        this.tilesDropDown.current!.hide();\r\n    }\r\n\r\n    onClickTilesDrop() {\r\n        this.clrDropDown.current!.hide();\r\n        this.algDropDown.current!.hide();\r\n        this.mazeDropDown.current!.hide();\r\n    }\r\n\r\n    changeVButtonColor(visualizing: boolean) {\r\n        this.setState({\r\n            visualizing: visualizing\r\n        })\r\n    }\r\n\r\n    toggleSettings() {\r\n        this.setState(prevState => ({\r\n            panelShow: !prevState.panelShow\r\n        }));\r\n    }\r\n\r\n    hideSettings() {\r\n        this.setState({\r\n            panelShow: false\r\n        });\r\n    }\r\n\r\n    changeAlgo(algorithm: string) {\r\n        this.setState({\r\n            heuristicDisabled: !PathfinderBuilder.usesHeuristic(algorithm),\r\n            bidirectionalDisabled: !PathfinderBuilder.hasBidirectional(algorithm),\r\n            arrowsDisabled: algorithm === 'dfs'\r\n        });\r\n        this.settingsManager.changeAlgo(algorithm);\r\n    }\r\n\r\n    doPathfinding() {\r\n        this.setState({\r\n            paused: false\r\n        });\r\n        this.visualizer.current!.doDelayedPathfinding();\r\n    }\r\n\r\n    pausePathfinding() {\r\n        this.setState({\r\n            paused: true\r\n        });\r\n        this.visualizer.current!.pausePathfinding();\r\n    }\r\n\r\n    resumePathfinding() {\r\n        this.setState({\r\n            paused: false\r\n        });\r\n        this.visualizer.current!.resumePathfinding();\r\n    }\r\n\r\n    clearPath() {\r\n        this.visualizer.current!.clearPath();\r\n        this.visualizer.current!.clearVisualizationChecked();\r\n    }\r\n\r\n    clearTiles() {\r\n        this.clearPath();\r\n        this.visualizer.current!.clearTilesChecked();\r\n    }\r\n\r\n    resetBoard() {\r\n        this.clearPath();\r\n        this.clearTiles();\r\n        this.visualizer.current!.resetPoints();\r\n    }\r\n\r\n    createMaze() {\r\n        this.visualizer.current!.createTerrain(MAZE);\r\n    }\r\n\r\n    createMazeVSkew() {\r\n        this.visualizer.current!.createTerrain(MAZE_VERTICAL_SKEW);\r\n    }\r\n\r\n    createMazeHSkew() {\r\n        this.visualizer.current!.createTerrain(MAZE_HORIZONTAL_SKEW);\r\n    }\r\n\r\n    createRandomTerrain() {\r\n        this.visualizer.current!.createTerrain(RANDOM_TERRAIN);\r\n    }\r\n\r\n    changeTile(cost: number) {\r\n        this.visualizer.current!.changeTile({\r\n            isSolid: cost === -1,\r\n            pathCost: cost\r\n        });\r\n    }\r\n\r\n    onChangeWOpacity() {\r\n        this.visualizer.current!.setState(prevState => ({\r\n            weightOpacity: prevState.weightOpacity === 1 ? 0.2 : 1\r\n        }));\r\n    }\r\n\r\n    render() {\r\n        const useIcon = window.innerWidth <= 830;\r\n        const title = 'Pathfinding Visualizer';\r\n        const mobile = isMobile();\r\n        const tileWidth =  mobile ? 47 : Math.round(window.screen.availWidth / 57);\r\n        if(mobile) {\r\n            this.settingsManager.changeSpeed(20);\r\n        } else if(window.screen.availWidth > 2500) {\r\n            this.settingsManager.changeSpeed(12);\r\n        }\r\n        return (\r\n            <div>\r\n                <DraggablePanel title='Grid Settings'\r\n                                show={this.state.panelShow}\r\n                                onClickXButton={() => this.hideSettings()}\r\n                                width={350}\r\n                                height={425}\r\n                >\r\n                    <VisualSettings disabled={this.state.arrowsDisabled}\r\n                                    onChangeViz={() => this.settingsManager.changeVisualize()}\r\n                                    onChangeShowArrows={() => this.settingsManager.changeShowArrows()}\r\n                                    onChangeWOpacity={() => this.onChangeWOpacity()}\r\n                    />\r\n                    <SpeedSettings onChange={() => this.settingsManager.changeSpeed}\r\n                                   initialSpeed={this.settingsManager.settings.delayInc}\r\n                    />\r\n                    <AlgorithmSettings disabled={this.state.bidirectionalDisabled}\r\n                                       onChangeBidirectional={() => this.settingsManager.changeBidirectional()}\r\n                    />\r\n                    <HeuristicSettings disabled={this.state.heuristicDisabled}\r\n                                       onClickManhattan={() => this.settingsManager.changeManhattan()}\r\n                                       onClickEuclidean={() => this.settingsManager.changeEuclidean()}\r\n                                       onClickChebyshev={() => this.settingsManager.changeChebyshev()}\r\n                                       onClickOctile={() => this.settingsManager.changeOctile()}\r\n                    />\r\n                </DraggablePanel>\r\n                <TopBar>\r\n                    <a href='https://github.com/JosephPrichard/PathfinderReact' className='title'\r\n                       style={{\r\n                           width: useIcon ? '70px' : 'auto',\r\n                           height: useIcon ? '52px' : '100%'\r\n\r\n                       }}\r\n                    >\r\n                        {\r\n                            useIcon ?\r\n                                <img width={'100%'} height={'100%'}\r\n                                     className='icon'\r\n                                     alt={title} src={Icon}/> :\r\n                                title\r\n                        }\r\n                    </a>\r\n                    <div className='top-container'>\r\n                        <AlgorithmDropDown ref={this.algDropDown}\r\n                                           onClick={() => this.onClickAlgDrop()}\r\n                                           onChange={(alg: string) => this.changeAlgo(alg)}\r\n                        />\r\n                        <VisualizeButton active={this.state.visualizing}\r\n                                         paused={this.state.paused}\r\n                                         onPause={() => this.pausePathfinding()}\r\n                                         onResume={() => this.resumePathfinding()}\r\n                                         onStartStop={() => this.doPathfinding()}\r\n                        />\r\n                        <ClearDropDown ref={this.clrDropDown}\r\n                                       onClick={() => this.onClickClrDrop()}\r\n                                       onClickTiles={() => this.clearTiles()}\r\n                                       onClickPath={() => this.clearPath()}\r\n                                       onClickReset={() => this.resetBoard()}\r\n                        />\r\n                        <TilesDropDown ref={this.tilesDropDown}\r\n                                       onClick={() => this.onClickTilesDrop()}\r\n                                       onClickTileType={(cost: number) => this.changeTile(cost)}\r\n                        />\r\n                        <MazeDropDown ref={this.mazeDropDown}\r\n                                      onClick={() => this.onClickMazeDrop()}\r\n                                      onClickMaze={() => this.createMaze()}\r\n                                      onClickMazeHorizontal={() => this.createMazeHSkew()}\r\n                                      onClickMazeVertical={() => this.createMazeVSkew()}\r\n                                      onClickRandomTerrain={() => this.createRandomTerrain()}\r\n                        />\r\n                        <SettingsButton onClick={() => this.toggleSettings()}/>\r\n                    </div>\r\n                </TopBar>\r\n                <PathfindingVisualizer ref={this.visualizer}\r\n                                       onChangeVisualizing={(viz: boolean) => this.changeVButtonColor(viz)}\r\n                                       settings={this.settingsManager.settings}\r\n                                       tileWidth={tileWidth}/>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nfunction isMobile() {\r\n    return /Android|webOS|iPhone|iPad|Mac|Macintosh|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\r\n}\r\n\r\nexport default PathfindingApp;","import React from 'react';\nimport './App.css';\nimport PathfindingApp from './view/PathfindingApp';\n\nclass App extends React.Component\n{\n    render() {\n        return (\n            <PathfindingApp/>\n        );\n    }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n//import reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n    <React.StrictMode>\n        <App/>\n    </React.StrictMode>,\n    document.getElementById('root')\n);\n\n//reportWebVitals();\n"],"sourceRoot":""}